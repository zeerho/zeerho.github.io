<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Just a repo for documents">
<meta property="og:type" content="website">
<meta property="og:title" content="Tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="zeerho">
<meta property="og:description" content="Just a repo for documents">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-05T02:37:10.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tags">
<meta name="twitter:description" content="Just a repo for documents">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/"/>





  <title>zeerho</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zeerho</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/工具/Vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/工具/Vim/" itemprop="url">Vim</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul>
<li><code>u</code> 撤销从上次进入插入模式到退出插入模式之间的操作。在插入模式中使用光标键会视为产生一个新的撤销块。</li>
<li><code>U</code> 撤销对整行的修改</li>
<li><code>&lt;c-r&gt;</code> 重做被撤销的操作</li>
</ul>
<h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><ul>
<li><code>[n]&lt;C-a&gt;</code> 将光标所在数字（或本行内光标后最近一个数字）加 n（缺省为 1）</li>
<li><code>[n]&lt;C-x&gt;</code> 将光标所在数字（或本行内光标后最近一个数字）减 n（缺省为 1）</li>
</ul>
<p>Vim 缺省会将以 0 开头的数字解释为八进制。在 vimrc 中加入 <code>set nrformats=</code> 来把所有数字解释为十进制。</p>
<h2 id="插入模式下的删除操作符"><a href="#插入模式下的删除操作符" class="headerlink" title="插入模式下的删除操作符"></a>插入模式下的删除操作符</h2><table>
<thead>
<tr>
<th style="text-align:left">按键操作</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;C-h&gt;</code></td>
<td style="text-align:left">删除前一个字符（同退格键）</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;C-w&gt;</code></td>
<td style="text-align:left">删除前一个单词</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;C-u&gt;</code></td>
<td style="text-align:left">删至行首</td>
</tr>
</tbody>
</table>
<p>这些命令在 Vim 的命令行模式以及在 bash shell 中同样有效。</p>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><ul>
<li><code>&lt;c-g&gt;</code> 显示光标所在行位置及文件状态信息</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li><code>/{string}</code> 正向查找指定字符串</li>
<li><code>?{string}</code> 反向查找指定字符串</li>
<li><code>n</code> 以相同方向再次查找该字符串</li>
<li><code>N</code> 以相反方向再次查找该字符串</li>
<li><code>&lt;c-o&gt;</code> 返回之前位置</li>
<li><code>&lt;c-i&gt;</code> 跳至较新位置</li>
<li><code>*</code> 查找光标下单词</li>
</ul>
<h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><p><code>/expr</code> magic 搜索模式。<br><code>/\vexpr</code> very magic 搜索模式。除下划线、字母和数字以外的所有字符都当作具有特殊含义的字符。“#”依然会按其原义匹配，原因是“任何还未具有特殊含义的字符都被保留以备将来扩展时使用”。<br><code>/\Vexpr</code> very nomagic 搜索模式。只有“\”具有特殊含义。<br><em>具体的字符含义见 <code>:h pattern-overview</code></em></p>
<p><code>/\(expr1\)\@&gt;expr2</code> 固化分组。详见另一篇《正则表达式》。<br><code>/expr1\(expr2\)\@=</code> 正向前查找。匹配所有满足后置表达式为 expr2 的 expr1。<br><code>/expr1\(expr2\)\@!</code> 负向前查找。匹配所有满足后置表达式<strong>不</strong>为 expr2 的 expr1。<br><code>/expr1\@&lt;=expr2</code> 正向后查找。匹配所有满足前置表达式为 expr1 的 expr2。<br><code>/expr1\@&lt;!expr2</code> 负向后查找。匹配所有满足前置表达式<strong>不</strong>为 expr1 的 expr2。<br><em>若用 very magic 模式则不需要转义</em></p>
<p><code>*</code> 贪婪匹配<br><code>{-}</code> <code>{-m,n}</code> 非贪婪匹配</p>
<h3 id="配对括号的查找"><a href="#配对括号的查找" class="headerlink" title="配对括号的查找"></a>配对括号的查找</h3><p><code>%</code> 若光标置于括号处（{、[、(、)、]、}），则会跳至与该括号相配对的另一括号处。若光标置于非括号处，则会跳至与“当前位置之后第一个括号”相配对的另一括号处（仅在本行查找）。</p>
<h2 id="在-VIM-内执行外部命令"><a href="#在-VIM-内执行外部命令" class="headerlink" title="在 VIM 内执行外部命令"></a>在 VIM 内执行外部命令</h2><p><code>:![command]</code> 所有的外部命令都可以用这种方式执行，包括带命令行参数的命令。</p>
<h2 id="具有选择性的保存命令"><a href="#具有选择性的保存命令" class="headerlink" title="具有选择性的保存命令"></a>具有选择性的保存命令</h2><ol>
<li>按 <code>v</code> 进入可视模式</li>
<li>移动光标来选取文本</li>
<li>按 <code>:</code> 会看到窗口底部出现 <code>:&#39;&lt;,&#39;&gt;</code></li>
<li>输入 <code>w [FILENAME]</code> 并回车，就把所选文本保存到相应的文件中了。</li>
</ol>
<h2 id="提取和合并文件"><a href="#提取和合并文件" class="headerlink" title="提取和合并文件"></a>提取和合并文件</h2><p><code>:r [FILENAME]</code> 插入指定文件的内容，从光标所在位置的后一行开始<br><code>:r ![command]</code> 插入指定外部命令的输出内容</p>
<h2 id="设置类选项"><a href="#设置类选项" class="headerlink" title="设置类选项"></a>设置类选项</h2><ul>
<li><code>:set ic</code> 查找替换忽略大小写 <em>Ignore Case</em></li>
<li><code>:set noic</code> 禁用忽略大小写</li>
<li><code>:set hls</code> 搜索高亮 <em>hlsearch</em></li>
<li><code>:set nohls</code> <code>:nohls</code> <code>:nohlsearch</code> 禁用搜索高亮</li>
<li><code>:set is</code> 增量搜索 <em>incsearch</em></li>
<li><code>:set nois</code> 禁用增量搜索</li>
<li><code>/[string]\c</code> 仅在本次查找忽略大小写</li>
</ul>
<h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><p><code>&lt;help&gt;</code> 若键盘上有的话<br><code>&lt;F1&gt;</code> 若键盘上有的话<br><code>:help [parameter]</code> 获取帮助信息，参数为可选项</p>
<h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><ul>
<li><code>$myvimrc</code>: vimrc 文件全路径。（关于 vimrc 详见 <code>:h vimrc-intro</code>）</li>
<li><code>$vim</code>: vim 程序根目录。</li>
<li><code>$vimruntime</code>: 其下包含各种 vim 的支持文件。以 vim8.1 为例，默认是 <code>$vim/vim81/</code>。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>gv</code> 重选上次的选区<br><code>o</code> 切换选区的活动端</p>
<h1 id="mswin-vim"><a href="#mswin-vim" class="headerlink" title="mswin.vim"></a>mswin.vim</h1><p><code>{mode} {if_recursive} {map}</code></p>
<ul>
<li><code>mode</code> 表示该映射生效的模式（<em><code>:h vim-modes</code></em>）。取值如下：<ul>
<li>空: normal, visual, select, operator-pending</li>
<li>n: normal only</li>
<li>v: visual and select</li>
<li>o: operator-pending(<em><code>:h Operator-pending-mode</code></em>)</li>
<li>x: visual only(<em><code>:h visual-mode</code></em>)</li>
<li>s: select only(<em><code>:h select-mode</code></em>)</li>
<li>i: insert</li>
<li>c: command-line</li>
<li>l: insert, command-line, regexp-search (and others. Collectively called “Lang-Arg” pseudo-mode)</li>
</ul>
</li>
<li><code>if_recursive</code> 表示该命令是否会递归生效<ul>
<li><code></code> 空缺，表示递归生效</li>
<li><code>nore</code> 表示非递归生效</li>
</ul>
</li>
<li><code>map</code> 固定值，表示映射</li>
</ul>
<h1 id="可重复的操作及如何回退"><a href="#可重复的操作及如何回退" class="headerlink" title="可重复的操作及如何回退"></a>可重复的操作及如何回退</h1><table>
<thead>
<tr>
<th style="text-align:left">目的</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">重复</th>
<th style="text-align:left">回退</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">做出一个修改</td>
<td style="text-align:left">{edit}</td>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">执行替换</td>
<td style="text-align:left">:s/{tar}/{sub}</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">执行一系列修改</td>
<td style="text-align:left"><code>qx{changes}q</code></td>
<td style="text-align:left"><code>@x</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">重复任意 Ex 命令</td>
<td style="text-align:left"><code>:{Ex}</code></td>
<td style="text-align:left"><code>@:</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">在行内查找下一指定字符</td>
<td style="text-align:left"><code>f{char}</code>/<code>t{char}</code></td>
<td style="text-align:left"><code>;</code></td>
<td style="text-align:left"><code>,</code></td>
</tr>
<tr>
<td style="text-align:left">在行内查找上一指定字符</td>
<td style="text-align:left"><code>F{char}</code>/<code>T{char}</code></td>
<td style="text-align:left"><code>;</code></td>
<td style="text-align:left"><code>,</code></td>
</tr>
<tr>
<td style="text-align:left">在文档中查找下一处匹配项</td>
<td style="text-align:left">/pattern<code>{CR}</code></td>
<td style="text-align:left"><code>n</code></td>
<td style="text-align:left"><code>N</code></td>
</tr>
<tr>
<td style="text-align:left">在文档中查找上一处匹配项</td>
<td style="text-align:left">?pattern<code>{CR}</code></td>
<td style="text-align:left"><code>n</code></td>
<td style="text-align:left"><code>N</code></td>
</tr>
</tbody>
</table>
<h1 id="操作符-operator"><a href="#操作符-operator" class="headerlink" title="操作符 operator"></a>操作符 operator</h1><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>c</code></td>
<td style="text-align:left">修改</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code></td>
<td style="text-align:left">光标下单字符修改</td>
</tr>
<tr>
<td style="text-align:left"><code>d</code></td>
<td style="text-align:left">删除</td>
</tr>
<tr>
<td style="text-align:left"><code>y</code></td>
<td style="text-align:left">复制到寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>g~</code></td>
<td style="text-align:left">反转大小写</td>
</tr>
<tr>
<td style="text-align:left"><code>gu</code></td>
<td style="text-align:left">转换为小写</td>
</tr>
<tr>
<td style="text-align:left"><code>gU</code></td>
<td style="text-align:left">转为大写</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">增加缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">减小缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">自动缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">使用外部程序过滤 {motion} 所跨越的行</td>
</tr>
</tbody>
</table>
<p><em>自定义操作符<code>:h map-operator</code></em></p>
<h1 id="Ex-命令"><a href="#Ex-命令" class="headerlink" title="Ex 命令"></a>Ex 命令</h1><ul>
<li><code>:[{range}]d[elete] {reg}</code> 删除指定范围内的到寄存器 {reg} 中</li>
<li><code>:[{range}]y[ank] {reg}</code> 复制指定范围内行[到寄存器 {reg} 中</li>
<li><code>:[{line}]pu[t] {reg}</code> 在指定行后粘贴寄存器 {reg} 中的内容</li>
<li><code>:[{range}]co[py] {to}</code> <code>:t</code> 把指定范围内的行复制到 {to} 所指定的行之下</li>
<li><code>:[{range}]m[ove] {to}</code> 把指定范围内的行移动到 {to} 所指定的行之下</li>
<li><code>:[{range}]j[oin][!]</code> 连接指定范围内的行。<code>!</code> 表示不插入或删除任何空格。</li>
<li><code>:[{range}]norm[al][!] {commands}</code> 对指定范围内的每一行执行普通模式命令</li>
<li><code>:[{range}]s[ubstitute]/{pattern}/{string}/[flags]</code> 把指定范围内出现 {pattern} 的地方替换为 {string}</li>
<li><code>:[{range}]g[lobal]/{pattern}/[cmd]</code> 对指定范围内匹配 {pattern} 的所有行，在其上执行 Ex 命令 {cmd}</li>
</ul>
<h2 id="补全功能"><a href="#补全功能" class="headerlink" title="补全功能"></a>补全功能</h2><ol>
<li>确保 Vim 不是在以兼容模式运行 <code>:set nocp</code></li>
<li><code>&lt;C-d&gt;</code> 列出候选列表</li>
<li><code>&lt;TAB&gt;</code> 在候选列表中切换选项</li>
</ol>
<h2 id="用来构建-Ex-命令的地址和范围的符号"><a href="#用来构建-Ex-命令的地址和范围的符号" class="headerlink" title="用来构建 Ex 命令的地址和范围的符号"></a>用来构建 Ex 命令的地址和范围的符号</h2><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>{number}</code></td>
<td style="text-align:left">行号</td>
</tr>
<tr>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">文件的首行</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">文件的末行</td>
</tr>
<tr>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">虚拟行，位于文件首行上方</td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">光标所在行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;m</code></td>
<td style="text-align:left">包含位置标记 m 的行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;&lt;</code></td>
<td style="text-align:left">最近一次高亮选区的首行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;&gt;</code></td>
<td style="text-align:left">最近一次高亮选区的末行</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">整个文件（<code>:1,$</code> 的简写形式)</td>
</tr>
</tbody>
</table>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code> 将光标下单词插入命令行中</li>
<li><code>&lt;C-r&gt;&lt;C-a&gt;</code> 将光标下字串插入命令行中</li>
<li><code>q/</code> 打开查找命令历史的命令行窗口</li>
<li><code>q:</code> 打开 Ex 命令历史的命令行窗口</li>
<li><code>&lt;C-f&gt;</code> 从命令行模式切换到命令行窗口</li>
<li><code>&lt;up&gt;</code> <code>&lt;down&gt;</code> 向前/向后遍历历史命令。若已输入部分内容，则只遍历已输入内容开头的命令。</li>
<li><code>&lt;C-p&gt;</code> <code>&lt;C-n&gt;</code> 向前/向后遍历历史命令。不会根据已输入内容进行过滤。</li>
</ul>
<h1 id="插入特殊字符"><a href="#插入特殊字符" class="headerlink" title="插入特殊字符"></a>插入特殊字符</h1><p>在插入模式中输入 <code>&lt;C-v&gt;{code}</code>。Vim 接受的字符编码共包含 3 位数字，不满 3 位的在开头补 0，超过 3 位的用 <code>&lt;C-v&gt;u{code}</code> 来输入，其中 {code} 为十六进制编码。</p>
<p><code>ga</code> 命令查看光标所在字符的编码。</p>
<p>如果 <code>&lt;C-v&gt;</code> 后面跟一个非数字键，则会插入这个按键本身所代表的字符。比如若开启了’expandtab’选项，则 {Tab} 键会插入空格，而 <code>&lt;C-v&gt;{Tab}</code> 会插入制表符。</p>
<ul>
<li><code>&lt;C-v&gt;{123}</code> 以十进制字符编码插入字符</li>
<li><code>&lt;C-v&gt;u{1234}</code> 以十六进制字符编码插入字符</li>
<li><code>&lt;C-v&gt;{nodigit}</code> 按原义插入非数字字符</li>
<li><p><code>&lt;C-k&gt;{char1}{char2}</code> 插入以二合字母表示的字符</p>
</li>
<li><p><code>:h digraphs-default</code> 缺省的二合字母集依从的惯例</p>
</li>
<li><code>:h digraph-table</code> 二合字母列表</li>
</ul>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p><strong>新建窗口</strong></p>
<ul>
<li><code>&lt;C-w&gt;s</code>：水平切分当前窗口，新窗口仍显示当前缓冲区</li>
<li><code>&lt;C-w&gt;v</code>：垂直切分当前窗口，新窗口仍显示当前缓冲区</li>
<li><code>:sp[lit] {file}</code>：水平切分当前窗口，并在新窗口中载入{file}</li>
<li><code>:vsp[lit] {file}</code>：垂直切分当前窗口，并在新窗口中载入{file}</li>
</ul>
<p><strong>在窗口间切换，详见 <code>:h window-move-curse</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;w</code> <code>&lt;C-w&gt;&lt;C-w&gt;</code> 在窗口间循环切换</li>
<li><code>&lt;C-w&gt;h</code> 切换到左边的窗口</li>
<li><code>&lt;C-w&gt;j</code> 切换到下边的窗口</li>
<li><code>&lt;C-w&gt;k</code> 切换到上边的窗口</li>
<li><code>&lt;C-w&gt;l</code> 切换到右边的窗口</li>
</ul>
<p><strong>关闭窗口</strong></p>
<ul>
<li><code>:clo[se]</code> <code>&lt;C-w&gt;c</code>：关闭活动窗口</li>
<li><code>:on[ly]</code> <code>&lt;C-w&gt;o</code>：只保留活动窗口，关闭其他所有窗口</li>
</ul>
<p><strong>改变窗口大小及重新排列窗口，详见 <code>:h window-resize</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;=</code>：使所有窗口等宽、等高</li>
<li><code>&lt;C-w&gt;_</code>：最大化活动窗口的高度</li>
<li><code>&lt;C-w&gt;\|</code>：最大化活动窗口的宽度</li>
<li><code>[N]&lt;C-w&gt;_</code>：把活动窗口的高度设为[N]行</li>
<li><code>[N]&lt;C-w&gt;\|</code>：把活动窗口的宽度设为[N]列</li>
</ul>
<p><strong>重排窗口，详见 <code>:h window-moving</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;r</code> <code>&lt;C-w&gt;&lt;C-r&gt;</code>：将所有窗口下移/右移，只影响当前窗口所在列/行</li>
<li><code>&lt;C-w&gt;R</code>：将所有窗口上移/左移，只影响当前窗口所在列/行</li>
<li><code>[N]&lt;C-w&gt;x</code> <code>[N]&lt;C-w&gt;&lt;C-x&gt;</code>：将当前窗口与下一个窗口交换，若无下个窗口，则与上一个窗口交换，光标会切换到目标窗口。通过指定[N]来将当前窗口与第[N]个窗口交换（第一个窗口为1），只影响当前窗口所在行/列<br><code>&lt;C-w&gt;K</code>：将当前窗口移到最上方，并独占最大宽度<br><code>&lt;C-w&gt;J</code>：将当前窗口移到最下方，并独占最大宽度<br><code>&lt;C-w&gt;H</code>：将当前窗口移到最左方，并独占最大高度<br><code>&lt;C-w&gt;L</code>：将当前窗口移到最右方，并独占最大高度<br><code>[N]&lt;C-w&gt;T</code>：将当前窗口移到新标签页。若指定[N]则新标签页会置于第N个标签页之前，否则置于当前标签页之后。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>:lcd {path}</code>：设置当前窗口的本地工作目录</li>
<li><code>:windo lcd {path}</code>：设置当前标签页中所有窗口的本地工作目录</li>
</ul>
<h1 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h1><p><strong>打开及关闭标签页</strong><br><code>:tabe[dit] {filename}</code>：在新标签页中打开{filename}。若省略{filename}，则新标签页会包含空缓冲区<br><code>:tabc[lose]</code>：关闭当前标签页及其中所有窗口<br><code>:tabo[nly]</code>：只保留活动标签页，关闭所有其他标签页<br><code>&lt;C-w&gt;T</code>：若当前标签页不止一个窗口，则把当前窗口移到一个新标签页中</p>
<p><strong>在标签页间切换</strong><br><code>:tabn[ext] {N}</code> <code>{N}gt</code>：跳到标签页{N}，标签页编号从1开始。省略{N}则跳到下一个标签页<br><code>:tabp[revious]</code> <code>{N}gT</code>：同上，方向相反</p>
<p><strong>重排标签页</strong><br><code>:tabmove {N}</code>：当N为0时，当前标签页会被移到开头；若省略了N，则移到末尾；也可鼠标拖动</p>
<h1 id="quickfix"><a href="#quickfix" class="headerlink" title="quickfix"></a>quickfix</h1><ul>
<li><code>:cope[n] [n]</code> 打开 quickfix 窗口，可指定高度。</li>
<li><code>:ccl[ose]</code> 关闭 quickfix 窗口。</li>
<li><code>:cl[ist] [{args}]</code> 列出所有项目。<ul>
<li><code>{from} [, {to}]</code> 指定范围。</li>
<li><code>+{count}</code> 列出当前项目和后面 <code>{count}</code> 个项目。</li>
</ul>
</li>
<li><code>:cc [N]</code> 跳转到第 N 项。</li>
<li><code>:cp[revious]</code> 上一项。</li>
<li><code>:cn[ext]</code> 下一项。</li>
<li><code>:cr[ewind]|cfir[st] [n]</code> 跳转到第 n 项，若省略 n 则跳转到第一项。</li>
<li><code>:cla[st] [n]</code> 跳转到第 n 项，若省略 n 则跳转到最后一项。</li>
<li><code>:cold[er]</code> 切到前一个列表。</li>
<li><code>:cnew</code> 切到后一个列表。</li>
</ul>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p><code>:pwd</code>：打印工作目录</p>
<p><strong>相对于当前工作目录打开一个文件</strong><br><code>:e[dit] {file}</code>：{file} 可以是相对于工作目录的文件路径，也可以是绝对路径<br><code>:e[dit] %:h/{file}</code>：<code>%:h</code>表示当前活动文件的目录路径，也可使用 <code>:e %:h&lt;Tab&gt;</code> 显示出路径后再继续输入文件名<br>在 _vimrc 文件中加入 <code>cnoremap &lt;expr&gt; %% getcmdtype()==&#39;:&#39; ? expand(&#39;%:h&#39;).&#39;/&#39; : &#39;%%&#39;</code></p>
<p><strong>通过文件名查找文件 详见 <code>:h file-searching</code></strong><br><code>set path+={root}/**</code>：首先要设置path变量。{root}为某个目录路径，**通配符表示其下所有子目录<br><code>:find {file}</code>：在 path 中查找文件</p>
<p><strong>打开文件管理器 使用 netrw <a href="http://vimcdoc.sourceforge.net/doc/pi_netrw.html" target="_blank" rel="noopener">API</a></strong><br><code>:e[dit] {path}</code>：打开文件管理器，{path}是目录名而不是文件名<br><code>:e[dit].</code>：打开工作目录<br><code>:e[dit] %:h</code>：打开当前活动缓冲区所在目录<br><code>:E[xplore]</code>：打开当前活动缓冲区所在目录或指定目录<br><code>:Se[xplore]</code>：在一个水平切分窗口里打开当前活动缓冲区所在目录或指定目录<br><code>:Ve[xplore]</code>：在一个垂直切分窗口里打开当前活动缓冲区所在目录或指定目录<br><code>:Te[xplore]</code>：在一个新标签页中打开当前目录或指定目录<br><code>&lt;C-^&gt;</code>：在文件管理器中切换到上一个打开的文件/上一个进入的目录<br><code>%</code>：创建一个新文件<br><code>d</code>：创建一个新目录<br><code>D</code>：删除文件/目录<br><code>-</code>：进入上一层目录，不能返回根目录<br><code>a</code>：在三种方式间切换：正常显示、隐藏（不显示匹配）、显示（只显示匹配）<br><code>c</code>：使浏览中的目录成为当前目录<br><code>i</code>：切换列表方式<br><code>&lt;C-l&gt;</code>：刷新目录列表<br><code>o</code>：打开新浏览窗口，进入光标所在目录，使用水平分割<br><code>v</code>：打开新浏览窗口，进入光标所在目录，使用垂直分割<br><code>p</code>：预览文件<br><code>P</code>：在前次使用的窗口里浏览<br><code>r</code>：反转排序<br><code>R</code>：重命名<br><code>s</code>：选择排序方式：按名字、时间或文件大小<br><code>S</code>：指定按名字排序的后缀优先<br><code>t</code>：在新标签页里打开光标所在的文件/目录<br><code>mf</code>：标记文件/目录，用于后续批量操作<br><code>x</code>：指定某个程序来打开文件</p>
<p><strong>把文件保存到不存在的目录中</strong><br><code>:!mkdir -p %:h</code>：创建任何不存在的中间目录，然后<code>:w</code></p>
<h1 id="缓冲区列表"><a href="#缓冲区列表" class="headerlink" title="缓冲区列表"></a>缓冲区列表</h1><ul>
<li>查看<ul>
<li><code>:ls[!]</code> <code>:buffers[!]</code>: 查看缓冲区列表，加上 <code>!</code> 将同时显示列表外缓冲区。</li>
</ul>
</li>
<li>切换<ul>
<li><code>&lt;C-6&gt;</code>               : 在当前文件和轮换文件间切换。</li>
<li><code>:bp[rev]</code> <code>:bn[ext]</code> : 反向/正向切换一个缓冲区。</li>
<li><code>:bfirst</code> <code>:blast</code>    : 跳到缓冲区列表的开头/结尾。</li>
<li><code>:b[uffer] {num/name}</code>: 打开指定编号/名字的缓冲区。</li>
</ul>
</li>
<li>删除<ul>
<li><code>:bd[elete] {n1} {n2}</code>: 删除指定编号的若干个缓冲区，即置为“列表外缓冲区”。</li>
<li><code>{n},{m} bd[elete]</code>   : 删除编号从 n 到 m 的所有缓冲区，即置为“列表外缓冲区”。</li>
<li><code>:bw[ipeout]</code>         : 彻底删除缓冲区，用法同 <code>:bd[elete]</code>。</li>
</ul>
</li>
<li>执行<ul>
<li><code>:bufdo</code>              : 对所有缓冲区执行命令。</li>
</ul>
</li>
</ul>
<p><strong>隐藏缓冲区</strong></p>
<p>切换缓冲区时（包括执行 <code>:bufdo</code> <code>:argdo</code> 时），若缓冲区尚未保存，则必须在命令后加上 <code>!</code>。可通过 <code>hidden</code> 选项来让被切换走的缓冲区变为隐藏缓冲区。</p>
<ul>
<li><code>set [no]hid[den]</code> 针对全局</li>
<li><code>set bufhidden|bh</code> 针对缓冲区</li>
<li><code>:hide {cmd}</code> 针对命令</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">列表外缓冲区 unlisted-buffer</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">当前缓冲区</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">轮换缓冲区</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">激活缓冲区，缓冲区被加载且显示</td>
</tr>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">隐藏缓冲区，缓冲区被加载但不显示</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">只读缓冲区</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">不可改缓冲区，’modifiable’ 选项不置位</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">已修改缓冲区</td>
</tr>
</tbody>
</table>
<h1 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h1><ul>
<li>查看<ul>
<li><code>:ar[gs]</code>：显示当前参数列表内容</li>
</ul>
</li>
<li>编辑<ul>
<li><code>:ar[gs] {argList}</code>：设置参数列表内容，其中 {argsList} 可以包括文件名、通配符 [^wildcard] 和 shell 命令输出结果（<code>:ar {cmd}</code>）</li>
<li><code>:arge[dit] [{name}]</code>：将 {name} 添加到参数列表并编辑该文件，缺省为当前缓冲区的文件名</li>
<li><code>:arga[dd] [{name}]</code>：将 {name} 添加到参数列表，缺省为当前缓冲区的文件名</li>
<li><code>:argd {pattern}</code> <code>:[range]argd</code>：按照模式删除参数；按照范围删除参数，参数列表从 1 开始计数，<code>$</code> 表示末尾，<code>%</code> 表示全部，<code>.</code> 或不指定表示当前</li>
</ul>
</li>
<li>切换<ul>
<li><code>:[count]n[ext]</code>：编辑当前之后第 count 个文件</li>
<li><code>:[count]N[ext]</code> <code>:[count]prev[ious]</code>：编辑当前之前第 count 个文件</li>
<li><code>:rew[ind]</code> <code>:fir[st]</code>：编辑第一个文件</li>
<li><code>:la[st]</code>：编辑最后一个文件</li>
</ul>
</li>
<li>执行<ul>
<li><code>:[range]argdo {cmd}</code>：对参数列表中的文件批量执行命令；要先设置 <code>hidden</code> 选项。</li>
</ul>
</li>
</ul>
<p>[^wildcard]: <code>*</code> 匹配 0 个或多个字符，范围仅限指定的目录，不含其子目录（如：<code>*.js</code>）；<code>**</code> 也匹配 0 个或多个字符，范围包括指定目录及其子目录（如：<code>**/*.js</code>）。</p>
<h1 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a>在文件中移动</h1><p>动作命令详见 <code>:h motion.txt</code></p>
<h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><ul>
<li><code>&lt;C-u&gt;</code> 向上滚动半屏</li>
<li><code>&lt;C-d&gt;</code> 向下滚动半屏</li>
<li><code>&lt;C-b&gt;</code> 向上滚动一屏</li>
<li><code>&lt;C-f&gt;</code> 向下滚动一屏</li>
<li><code>[{n}]&lt;C-y&gt;</code> 向上滚动 {n} 行，缺省 1 行</li>
<li><code>[{n}]&lt;C-e&gt;</code> 向下滚动 {n} 行，缺省 1 行</li>
</ul>
<h2 id="在实际行和屏幕行间移动"><a href="#在实际行和屏幕行间移动" class="headerlink" title="在实际行和屏幕行间移动"></a>在实际行和屏幕行间移动</h2><ul>
<li><code>j</code>  向下移动一个实际行</li>
<li><code>gj</code> 向下移动一个屏幕行</li>
<li><code>k</code>  向上移动一个实际行</li>
<li><code>gk</code> 向上移动一个屏幕行</li>
<li><code>0</code>  移动到实际行的行首</li>
<li><code>g0</code> 移动到屏幕行的行首</li>
<li><code>^</code>  移动到实际行的第一个非空白字符</li>
<li><code>g^</code> 移动到屏幕行的第一个非空白字符</li>
<li><code>$</code>  移动到实际行的行尾</li>
<li><code>g$</code> 移动到屏幕行的行尾</li>
</ul>
<h2 id="基于单词、字串、句子、段落移动"><a href="#基于单词、字串、句子、段落移动" class="headerlink" title="基于单词、字串、句子、段落移动"></a>基于单词、字串、句子、段落移动</h2><p><strong>基于单词移动</strong></p>
<p><code>w</code>  移动到下一个词头<br><code>b</code>  移动到上一个词头<br><code>e</code>  移动到下一个词尾<br><code>ge</code> 移动到上一个词尾</p>
<p><strong>基于字串移动</strong></p>
<p>只需将上述4个命令中的<code>w</code> <code>b</code> <code>e</code>换成大写</p>
<p>单词由字母、数字、下划线组成，或由连续的其他符号组成；字串由非空白符组成，由空白符分隔。</p>
<p><strong>基于句子移动</strong></p>
<p><code>(</code> <code>)</code> 跳转到上一句/下一句开头</p>
<p><strong>基于段落移动</strong></p>
<p><code>{</code> <code>}</code> 跳转到上一段/下一段开头</p>
<h2 id="行内查找"><a href="#行内查找" class="headerlink" title="行内查找"></a>行内查找</h2><ul>
<li><code>f{char}</code> 正向移动到下一个{char}所在之处</li>
<li><code>F{char}</code> 反向移动到上一个{char}所在之处</li>
<li><code>t{char}</code> 正向移动到下一个{char}所在之处的前一个字符上</li>
<li><code>T{char}</code> 反向移动到上一个{char}所在之处的后一个字符上</li>
<li><code>;</code> 正向重复上一次字符查找命令</li>
<li><code>,</code> 反向重复上一次字符查找命令</li>
</ul>
<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p><code>i</code> 表示分隔符内的文本，<code>a</code> 表示包含分隔符本身及其内部文本。用 surround 插件可以方便地操作分隔符。</p>
<ul>
<li><code>i)</code> <code>ib</code> 圆括号(parentheses)；<code>i)</code>与<code>i(</code>一样，下同</li>
<li><code>i}</code> <code>iB</code> 花括号(braces)</li>
<li><code>i]</code> 方括号(brackets)</li>
<li><code>i&gt;</code> 尖括号(angle brackets)</li>
<li><code>i&#39;</code> 单引号(single quotes)</li>
<li><code>i&quot;</code> 双引号(double quotes)</li>
<li><code>i`</code> 反引号(backticks)</li>
<li><p><code>it</code> XML标签(tags)</p>
</li>
<li><p><code>iw</code> <code>aw</code> 当前单词；当前单词及一个空格</p>
</li>
<li><code>iW</code> <code>aW</code> 当前字串；当前字串及一个空格</li>
<li><code>is</code> <code>as</code> 当前句子；当前句子及一个空格</li>
<li><code>ip</code> <code>ap</code> 当前段落；当前段落及一个空行</li>
</ul>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><ul>
<li><code>m{a-zA-Z}</code> 设置标记。小写只在该缓冲区内可见，大写全局可见</li>
<li><code>`{mark}</code> 跳转到标记处的行和列</li>
<li><code>&#39;{mark}</code> 跳转到标记处的行首</li>
<li><code>:marks</code> 获取所有标记的列表</li>
<li><code>:delmarks {mark1} {mark2}</code> 删除指定标记；同时删除的多个标记之间用空格分隔</li>
</ul>
<p><strong>自动位置标记</strong></p>
<ul>
<li><code>`</code> 当前文件中上次跳转动作之前的位置</li>
<li><code>`.</code> 上次修改的地方</li>
<li><code>`^</code> 上次插入的地方</li>
<li><code>`[</code> 上次修改或复制的起始位置</li>
<li><code>`]</code> 上次修改或复制的结束位置</li>
<li><code>`&lt;</code> 上次高亮选区的起始位置</li>
<li><code>`&gt;</code> 上次高亮选区的结束位置</li>
<li><code>%</code> 在一组开、闭括号间跳转，vim 会在跳转发生的地方设置一个标记</li>
</ul>
<h1 id="在文件间跳转"><a href="#在文件间跳转" class="headerlink" title="在文件间跳转"></a>在文件间跳转</h1><p>哪些动作算<strong>跳转</strong>？</p>
<ul>
<li>简单来说，大范围的动作命令可能被当作跳转，小范围的动作命令只能算作移动；</li>
<li>面向句子、段落，甚至文件之间的移动（如 <code>:edit</code>）都算跳转；</li>
</ul>
<p>以下是部分跳转命令</p>
<ul>
<li><code>[count]G</code> 跳转到指定的行号</li>
<li><code>/pattern&lt;CR&gt;</code> <code>?pattern&lt;CR&gt;</code> <code>n</code> <code>N</code> 跳转到模式匹配处</li>
<li><code>%</code> 跳转到括号匹配处</li>
<li><code>(</code> <code>)</code> 跳转到上一句/下一句开头</li>
<li><code>{</code> <code>}</code> 跳转到上一段/下一段开头</li>
<li><code>H</code> <code>M</code> <code>L</code> 跳转到屏幕最上方/正中间/最下方</li>
<li><code>gf</code> 跳转到光标下的文件名</li>
<li><code>&lt;C-]&gt;</code> 跳转到光标下关键字的定义处</li>
<li><code>&#39;{mark}</code> <code>`{mark}</code> 跳转到一个位置标记</li>
</ul>
<h2 id="Vim-为每个窗口维护了一份独立的跳转列表"><a href="#Vim-为每个窗口维护了一份独立的跳转列表" class="headerlink" title="Vim 为每个窗口维护了一份独立的跳转列表"></a>Vim 为每个窗口维护了一份独立的跳转列表</h2><ul>
<li><code>:ju[mps]</code> 查看跳转列表</li>
<li><code>:cle[arjumps]</code> 清除跳转列表</li>
<li><code>&lt;C-o&gt;</code>/<code>&lt;C-i&gt;</code> 反向/正向遍历跳转列表</li>
</ul>
<h2 id="Vim-为每个缓冲区维护了一份独立的改变列表"><a href="#Vim-为每个缓冲区维护了一份独立的改变列表" class="headerlink" title="Vim 为每个缓冲区维护了一份独立的改变列表"></a>Vim 为每个缓冲区维护了一份独立的改变列表</h2><ul>
<li><code>:changes</code> 查看变列表</li>
<li><code>g;</code>/<code>g,</code> 反向/正向遍历改变列表；不会被记录进跳转列表</li>
<li><code>u&lt;C-r&gt;</code> 返回上次修改处。这是一种取巧的做法，通过“撤销-&gt;重做”来移动光标</li>
</ul>
<h2 id="Vim-会自动创建一些位置标记"><a href="#Vim-会自动创建一些位置标记" class="headerlink" title="Vim 会自动创建一些位置标记"></a>Vim 会自动创建一些位置标记</h2><p><code>gi</code> 返回上次退出 insert 模式的位置，并进入 insert 模式</p>
<h2 id="Vim-会把文档中的文件名当成一个超链接"><a href="#Vim-会把文档中的文件名当成一个超链接" class="headerlink" title="Vim 会把文档中的文件名当成一个超链接"></a>Vim 会把文档中的文件名当成一个超链接</h2><ul>
<li><code>gf</code> 打开光标下的文件名，此动作会在跳转列表中增加一条记录</li>
<li><code>:set suffixesadd+=.suffix</code> 指定一个或多个文件扩展名，当 Vim 用 <code>gf</code> 搜索文件名时，会尝试用这些扩展名</li>
<li><code>:set path+={path}</code>  <code>gf</code> 除了会在工作目录的相对目录中搜索外，也会在 <code>path</code> 中的路径下搜索</li>
</ul>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul>
<li>无名寄存器<ul>
<li><code>&quot;&quot;</code>：缓存最后一次操作内容</li>
</ul>
</li>
<li>具名寄存器<ul>
<li><code>&quot;a</code>~<code>&quot;z</code>：通过指定名称来使用。同一字母大小写是同一个寄存器，小写会覆盖寄存器内原有内容，大写会续接原有内容。</li>
</ul>
</li>
<li>数字寄存器<ul>
<li><code>&quot;0</code>：复制专用寄存器，只受 <code>y{motion}</code> 影响</li>
<li><code>&quot;1</code>~<code>&quot;9</code>：缓存最近 9 次删除内容</li>
</ul>
</li>
<li>行内删除寄存器<ul>
<li><code>&quot;-</code>：行内删除寄存器</li>
</ul>
</li>
<li>只读寄存器<ul>
<li><code>&quot;%</code>：当前文件名</li>
<li><code>&quot;#</code>：轮换文件名（当前交替文件名）</li>
<li><code>&quot;.</code>：上次插入的文本</li>
<li><code>&quot;:</code>：上次执行的 Ex 命令</li>
</ul>
</li>
<li>模式寄存器<ul>
<li><code>&quot;/</code>：上次查找的模式</li>
</ul>
</li>
<li>表达式寄存器<ul>
<li><code>&quot;=</code>：只读，用于执行表达式命令</li>
</ul>
</li>
<li>黑洞寄存器<ul>
<li><code>&quot;_</code>：不缓存内容，用于彻底删除</li>
</ul>
</li>
<li>系统剪贴板<ul>
<li><code>&quot;+</code>：系统剪贴板</li>
<li><code>&quot;*</code>：选择专用寄存器。在X11视窗系统中代表主剪贴板（primary），在其余系统中同系统剪贴板</li>
<li><code>&quot;~</code>：拖放操作寄存器</li>
</ul>
</li>
</ul>
<p><strong>引用一个寄存器</strong></p>
<ul>
<li>insert mode：<code>&lt;C-r&gt;{reg without &quot;}</code>。无需输入寄存器名称中的 <code>&quot;</code>。</li>
<li>normal mode：<code>x</code>、<code>s</code>、<code>d{motion}</code>、<code>c{motion}</code>、<code>y{motion}</code> 以及它们对应的大写命令，在命令前加 <code>{reg}</code> 前缀指定引用某个寄存器。</li>
<li>visual mode：选中高亮内容后同 normal mode。</li>
<li>Ex mode：<code>:delete {reg}</code>、<code>:yank {reg}</code>、<code>:put {reg}</code>。</li>
<li>脚本：<code>@{reg without &quot;}</code></li>
</ul>
<p>缺省引用的是无名寄存器 <code>&quot;&quot;</code>。</p>
<p><strong>查看寄存器内容</strong></p>
<p><code>:reg[s] [{reg}]</code> <code>:di[splay] [{reg}]</code>：查看寄存器，若不指定寄存器名字，则查看全部。</p>
<p><strong>粘贴</strong></p>
<ul>
<li><code>p</code>：粘贴至光标后</li>
<li><code>P</code>：粘贴至光标前</li>
<li><code>gp</code>：粘贴至当前行之前，光标落于被粘贴行末尾</li>
<li><code>gP</code>：粘贴至当前行之后，光标落于被粘贴行开头</li>
</ul>
<p>在终端中使用系统剪贴板进行粘贴时可能会遇到一些问题，详见《Vim实用技巧》之《技巧63》。</p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><strong>录制宏</strong></p>
<ol>
<li><code>q{reg}</code>：开始录制，宏存放于 {reg} 指定的寄存器中，若 {reg} 为大写的具名寄存器，则会将新宏续接在原宏后面</li>
<li><code>q</code>：结束录制</li>
</ol>
<p><strong>执行宏</strong></p>
<ul>
<li><code>[n]@{reg}</code>：执行 {reg} 中保存的宏，可指定运行次数</li>
<li><code>@@</code>：重复上次调用的宏</li>
</ul>
<p><em>以上对寄存器的引用无需使用 <code>&quot;</code></em></p>
<p><strong>编辑宏</strong></p>
<p>以下以寄存器 a 为例。</p>
<ol>
<li>粘贴宏内容：<code>:put a</code> 粘贴至当前行下方，或者 <code>&quot;ap</code> 粘贴至光标之后。</li>
<li>编辑宏内容。</li>
<li>保存新内容至寄存器：<code>0</code>，<code>&quot;ay$</code>。</li>
</ol>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><h2 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h2><p><code>:h perl-patterns</code></p>
<p><strong>全局设置大小写敏感性</strong></p>
<ul>
<li><code>set ignorecase|ic</code> <code>set noignorecase|noic</code>: 大小写敏感关/开（会影响自动补全）。</li>
<li><code>set smartcase|scs</code> <code>set nosmartcase|noscs</code>: 智能模式，只有在设置了 <code>ignorecase</code> 时才生效。</li>
</ul>
<p><strong>临时设置大小写敏感性</strong></p>
<ul>
<li><code>\c</code> <code>\C</code>:忽略/区分大小写，可出现在模式的任意位置</li>
</ul>
<p><strong>4种语法模式</strong></p>
<ul>
<li><code>\v</code>:very magic 模式，除了 <code>_</code>、大小写字母、数字外，都具有特殊含义，<code>#</code> 暂时无特殊含义，但是 Vim 保留扩展其特殊含义的可能</li>
<li><code>\V</code>:very nomagic 模式，除了 <code>\</code>、<code>/</code>、<code>?</code> 外都无特殊含义（后 2 个为查找域结束符）</li>
<li><code>\m</code>:magic 模式，缺省模式，除了 <code>*</code>、<code>^</code>、<code>$</code>、<code>.</code>、<code>~</code>、<code>[</code>、<code>]</code> 外都无特殊含义</li>
<li><code>\M</code>:nomagic 模式，除 了 <code>^</code>、<code>$</code> 外都无特殊含义</li>
</ul>
<p><strong>模式项 详见<code>:h pattern-overview</code></strong></p>
<ul>
<li><code>/(expr1)@&gt;expr2</code>:固化分组。详见另一片正则表达式的博文。</li>
<li><code>/expr1(expr2)@=</code>:肯定型顺序环视。匹配所有满足后置表达式为expr2的expr1。</li>
<li><code>/expr1(expr2)@!</code>:否定型顺序环视。匹配所有满足后置表达式<strong>不</strong>为expr2的expr1。</li>
<li><code>/(expr1)@&lt;=expr2</code>:肯定型逆序环视。匹配所有满足前置表达式为expr1的expr2。</li>
<li><code>/(expr1)@&lt;!expr2</code>:否定型逆序环视。匹配所有满足前置表达式<strong>不</strong>为expr1的expr2。</li>
<li><code>\zs</code>:肯定型逆序环视</li>
<li><code>\ze</code>:肯定型顺序环视</li>
</ul>
<p><strong>不捕获分组内容</strong></p>
<ul>
<li><code>%(pattern)</code>：不捕获分组内容</li>
</ul>
<p><strong>限制符</strong></p>
<ul>
<li><code>{n,m}</code>:  尽可能多地匹配 n ~ m 个元素。</li>
<li><code>{n}</code>:    尽可能多地匹配 n 个元素。</li>
<li><code>{n,}</code>:   尽可能多地匹配 n 及更多个元素。</li>
<li><code>{,m}</code>:   尽可能多地匹配 0 ~ m 个元素。</li>
<li><code>{}</code>:     尽可能多地匹配 0 及更多个元素。</li>
<li><code>{-n,m}</code>: 尽可能少地匹配 n ~ m 个元素。</li>
<li><code>{-n}</code>:   尽可能少地匹配 n 个元素。</li>
<li><code>{-n,}</code>:  尽可能少地匹配 n 及更多个元素。</li>
<li><code>{-,m}</code>:  尽可能少地匹配 0 ~ m 个元素。</li>
<li><code>{-}</code>:    尽可能少地匹配 0 及更多个元素。</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><code>set wrapscan|ws</code>/<code>set nowrapscan|nows</code> 打开/关闭循环查找</li>
<li><code>set hlsearch|hls</code>/<code>set nohlsearch|nohls|hls!</code> 打开/关闭匹配高亮</li>
<li><code>:noh</code> 关闭高亮，直到下一次查找</li>
<li><code>set incsearch|is</code>/<code>set noincsearch|nois</code> 打开/关闭增量查找</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code> 用当前预览的匹配结果对查找域进行自动补全</li>
<li><code>:%s/{pattern}//gn</code> 统计匹配数量。{pattern} 可省略，即使用当前查找模式；<code>n</code> 表示抑制替换</li>
<li><code>q/</code> 调出查找历史命令行窗口</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>完整的substitute语法：<br><code>:[range]s[ubstitute]/{pattern}/{string}/[flags]</code></p>
<p>标志位 <em><code>:h s_flags</code></em>：</p>
<ul>
<li><code>g</code>：在全局范围内执行，即修改一行内所有匹配。</li>
<li><code>c</code>：让用户确认或拒绝每一处修改。<em><code>:h :s_c</code></em><br>  选项：<ul>
<li><code>y</code>：替换此处匹配。</li>
<li><code>n</code>：忽略此处匹配。</li>
<li><code>q</code>：退出替换过程。</li>
<li><code>l</code>：“last”——替换此处匹配后退出。</li>
<li><code>a</code>：“all”——替换此处与之后所有的匹配。</li>
<li><code>&lt;C-e&gt;</code>：向下滚动屏幕，即文本向上移动。</li>
<li><code>&lt;C-y&gt;</code>：向上滚动屏幕，即文本向下移动。</li>
</ul>
</li>
<li><code>n</code>：抑制替换行为，转而报告匹配个数。</li>
<li><code>e</code>：屏蔽错误信息。</li>
<li><code>&amp;</code>：重用上一次 <code>substitute</code> 命令所用的标志位，必须写在 flags 的第一位。</li>
<li><code>i</code>：忽略查找域的大小写。</li>
<li><code>I</code>：不忽略查找域的大小写。</li>
<li><code>p</code>：显示最后一处替换所在行。</li>
<li><code>#</code>：同 <code>p</code>，并加上行号。</li>
<li><code>l</code>：同 <code>p</code>，但显示效果同 <code>:list</code>，即用 <code>^</code> 显示无法打印的字符，并在行尾添加 <code>$</code>。</li>
<li><code>r</code>：只对不带参数的 <code>:&amp;</code> 和 <code>:s</code> 有效，作用同 <code>:~</code>：用最近一次的查找或替换命令中的模式来作为查找域，若最近一次的是替换命令且它的查找域为空，则继续在历史记录中向前查找。</li>
</ul>
<p>替换域中的特殊字符（部分）<br>详见<em><code>:h sub-replace-special</code></em><br>|符号|描述|<br>|:–|:–|<br>|<code>\r</code>|换行符|<br>|<code>\t</code>|制表符|<br>|<code>\\</code>|反斜杠|<br>|<code>\n</code>|第n个子匹配|<br>|<code>\0</code>|匹配模式的所有内容|<br>|<code>&amp;</code>|匹配模式的所有内容|<br>|<code>~</code>|使用上一次调用 <code>:substitute</code> 时的替换域|<br>|<code>\={Vim Script}</code>|执行{Vim Script}表达式，并将结果作为替换域|</p>
<p>替换相关命令<br>|命令|用途|<br>|:–|:–|<br>|<code>:[range]s[ubstitute] [flags] [count]</code> <code>:[range]&amp; [flags] [count]</code>|重复上一次替换操作，但忽略上次的flags，可手动添加flags|<br>|<code>:[range]&amp;&amp; [count]</code>|重复上一次替换操作，并带有上次的flags|<br>|<code>:[range]~[&amp;][flags] [count]</code>|同 <code>:&amp;r</code>|<br>|<code>&amp;</code>|同 <code>:s</code>|<br>|<code>g&amp;</code>|同 <code>:%s//~/&amp;</code>，其中查找域的内容用的是最近一次查找或替换命令所用的查找域<em>global substitute</em>|<br>|<code>:[range]sno[magic]</code>|同<code>:substitute</code>，但使用nomagic模式|<br>|<code>:[range]sm[agic]</code>|同<code>:substitute</code>，但使用magic模式|</p>
<p>global命令</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>:[range]g[lobal]/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">在range（缺省为整个文件<code>%</code>）范围内，对{pattern}匹配处执行cmd命令（缺省为<code>:p[rint]</code>），可以指定cmd的执行范围，<code>.</code>表示{pattern}匹配行，{finish}可通过偏移或匹配命令<code>/{pattern}/</code>指定</td>
</tr>
<tr>
<td style="text-align:left"><code>:[range]g[lobal]!/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">在range（缺省为整个文件<code>%</code>）范围内，对{pattern}不匹配处执行cmd命令（缺省为<code>:p[rint]</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>:[range]v[global]/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">同上</td>
</tr>
</tbody>
</table>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="vim-surroud"><a href="#vim-surroud" class="headerlink" title="vim-surroud"></a>vim-surroud</h2><p><code>ds</code> 和 <code>cs</code> 命令接受一个 target 作为第一个参数。目前所有的 target 都是单字符的。</p>
<ul>
<li><code>(</code> <code>)</code> <code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>&lt;</code> <code>&gt;</code> 代表它们自身以及与其对应的另一个字符。</li>
<li><code>b</code> <code>B</code> <code>r</code> <code>a</code> 分别是 <code>)</code> <code>}</code> <code>]</code> <code>&gt;</code> 的别名，其中前两个沿用 Vim 的设定。</li>
<li><p><code>&#39;</code> <code>&quot;</code> <figure class="highlight plain"><figcaption><span>代表它们自身（成对地），它们仅会在当前行被搜索。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">- `t` 代表一对 HTML/XML 标签。</span><br><span class="line">- `w` `W` `s` `p` 分别代表一个单词、字串、句子、段落。</span><br><span class="line"></span><br><span class="line">`cs` `ys` `vS` 需要一个单字符的 replacement 参数</span><br><span class="line"></span><br><span class="line">- 若使用 `)` `]` `&#125;` `&gt;`，则会正确匹配另一半符号。</span><br><span class="line">- 若使用 `(` `[` `&#123;`（`&lt;` 除外），则会正确匹配另一半符号，并在中间填充额外的空格。</span><br><span class="line">- `b` `B` `r` `a` 分别是 `)` `&#125;` `]` `&gt;` 的别名。</span><br><span class="line">- `&lt;C-]&gt;` 代表了 C 语言风格的 `&#123;&#125;`。</span><br><span class="line">- 若使用 `t` `&lt;`，则 Vim 会要求继续输入标签的属性。可以输入 `&lt;CR&gt;` 或 `&gt;` 来表示完成输入。Vim 会自动匹配闭标签。若使用 `&lt;C-t&gt;`，则生成的标签会自动换行。</span><br><span class="line">- 若使用 `s` ，则 Vim 会自动在开头加个空格，这样可以有效地删除 `()`。</span><br><span class="line">- surround 默认将字母 `l` 作为 Latex 的分隔符。</span><br><span class="line"></span><br><span class="line">除了上述的字符外，其余单字符会与其自身匹配成一对。</span><br><span class="line"></span><br><span class="line">**normal mode**</span><br><span class="line"></span><br><span class="line">- `ds&lt;s&gt;`：删除分隔符 `&lt;s&gt;`</span><br><span class="line">- `cs&lt;s&gt;&lt;t&gt;`：将 `&lt;s&gt;` 替换为 `&lt;t&gt;`</span><br><span class="line">- `cS&lt;s&gt;&lt;t&gt;`：将 `&lt;s&gt;` 替换为 `&lt;t&gt;`，并添加换行和缩进</span><br><span class="line">- `ys&#123;motion&#125;&lt;s&gt;` `ys&#123;文本对象&#125;&lt;s&gt;`：在指定文本外添加分隔符</span><br><span class="line">- `yS&#123;motion&#125;&lt;s&gt;` `yS&#123;文本对象&#125;&lt;s&gt;`：在指定文本外添加分隔符，并添加换行和缩进</span><br><span class="line">- `yss&lt;s&gt;`：在当前行外添加分隔符</span><br><span class="line">- `ySs&lt;s&gt;` `ySS&lt;s&gt;`：在当前行外添加分隔符，并添加换行和缩进</span><br><span class="line"></span><br><span class="line">**visual mode**</span><br><span class="line"></span><br><span class="line">- `S&lt;s&gt;`：在高亮选区外添加分隔符</span><br><span class="line"></span><br><span class="line">**insert mode**</span><br><span class="line"></span><br><span class="line">- `&lt;C-g&gt;s&lt;s&gt;` `&lt;C-S&gt;&lt;s&gt;`：插入分隔符并将光标置入分隔符中间；后者在终端中会使终端冻结</span><br><span class="line"></span><br><span class="line">**个性化**</span><br><span class="line"></span><br><span class="line">*`:h surround-customizing`*</span><br><span class="line"></span><br><span class="line">1. 在特定类型文件中启用自定义的分隔符。</span><br><span class="line">  `autocmd FileType php let b:surround_45 = &quot;&lt;?php \r ?&gt;&quot;`</span><br><span class="line">  其中，</span><br><span class="line">  - `php` 是指定的文件类型；</span><br><span class="line">  - `b` 表示后面的变量作用域为当前缓冲区；</span><br><span class="line">  - `surround_` 为变量名中的固定部分；</span><br><span class="line">  - `45` 为字符 `-` 的 ASCII 码（字符和 ASCII 码之间的转换可用 `char2nr()` 和 `nr2char()` 函数）；</span><br><span class="line">  - 回车符 `\r` 会被原始文本（即被分隔符包围的原文）替换。</span><br><span class="line">2. 动态输入分隔符标签中的内容。</span><br><span class="line">  `let g:surround_108 = &quot;\\begin&#123;\1environment: \1&#125;\r\\end&#123;\1\1&#125;&quot;`</span><br><span class="line">  - `\1` 表示输入参数，最高支持到 `\7`；</span><br><span class="line">  - 两个 `\1` 之间的内容会作为提示在用户输入时弹出，并最终会被输入的内容替换；</span><br><span class="line">  - 回车符 `\r` 会被原始文本（即被分隔符包围的原文）替换。</span><br><span class="line">3. 使用正则表达式完成额外的功能。</span><br><span class="line">    `let g:surround_108 = &quot;\\begin&#123;\1environment: \1&#125;\r\\end&#123;\1\r&#125;.*\r\1&#125;&quot;`</span><br><span class="line">    - 在第二组 `\1` 中，第一个 `\r` 后面跟的是替换操作所用的 pattern，第二个 `\r` 后面跟的是替换操作所用的 replacement。最终的效果是：第一组 `\1` 之间的内容会被输入内容替换；第二组 `\1` 之间的内容先被输入内容替换，然后用 pattern 进行匹配，匹配到的内容会被 replacement 替换，至此确定最终结果。</span><br><span class="line">    `let g:surround_&#123;char2nr(&quot;d&quot;)&#125; = &quot;&lt;div\1id: \r..*\r id=\&quot;&amp;\&quot;\1&gt;\r&lt;/div&gt;&quot;`</span><br><span class="line">    - 其中 `&amp;` 表示在第一组 `\r` 中匹配到的内容（`:h s/\&amp;`）</span><br><span class="line">4. 为分隔符自动添加后缀</span><br><span class="line">    `let g:surround_insert_tail = &quot;&lt;++&gt;&quot;`</span><br><span class="line">    - 在 insert 模式下使用 `&lt;C-g&gt;s&lt;s&gt;` 插入分隔符时会自动给分隔符添加后缀；</span><br><span class="line">    - 该变量的名称固定，且作用域必须是全局 `g:`；</span><br><span class="line">    - `&lt;++&gt;` 为自定义的后缀；</span><br><span class="line">    - 只能在 insert 模式下生效。</span><br><span class="line"></span><br><span class="line">## Vim 内部的 Grep</span><br><span class="line"></span><br><span class="line">`:vim[grep][!] /&#123;pattern&#125;/[g][j] &#123;file&#125;...`</span><br><span class="line">- `g`：缺省只为每个出现匹配的行创建一条记录。此参数的作用：若同一行中有多处匹配，则为每一处匹配创建一条记录。</span><br><span class="line">- `j`：缺省 Vim 会跳转到第一处匹配。此参数的作用：只更新 quickfix 列表，但不跳到第一处匹配。</span><br><span class="line">- `file`：可接受的参数同`:args`。</span><br><span class="line"></span><br><span class="line">## ctrlp</span><br><span class="line"></span><br><span class="line">### 快捷键</span><br><span class="line"></span><br><span class="line">`:h ctrlp-commands`</span><br><span class="line"></span><br><span class="line">- `&lt;C-p&gt;` `:CtrlP [starting-dir]` 启动文件查找模式，可指定目录。</span><br><span class="line">- 在输入框中</span><br><span class="line">  - `&lt;C-d&gt;` 在全路径搜索(`&gt;&gt;&gt;`)和文件名搜索(`&gt;d&gt;`)之间切换。</span><br><span class="line">  - `&lt;C-r&gt;` 在字符串匹配(`&gt;&gt;&gt;`)和正则匹配(`r&gt;&gt;`)之间切换。</span><br><span class="line">  - `&lt;C-f&gt;` `&lt;C-up&gt;` `&lt;C-b&gt;` `&lt;C-down&gt;` 循环切换搜索模式：普通（文件查找）、缓冲区查找、最近历史查找（MRU）。</span><br><span class="line">  - `&lt;tab&gt;` 自动补全目录名。</span><br><span class="line">  - `&lt;S-tab&gt;` 在匹配窗口和输入框之间切换。</span><br><span class="line">    - 在匹配窗口按下任意字符来选中首字符匹配的项目。多次按同一字符会在多个首字符匹配的项目间循环。</span><br><span class="line">- 移动</span><br><span class="line">  - `&lt;C-k&gt;` `&lt;up&gt;` `&lt;C-j&gt;` `&lt;down&gt;` 向上、向下。</span><br><span class="line">  - `&lt;C-a&gt;` `&lt;C-e&gt;` 移至输入框开头/末尾。</span><br><span class="line">  - `&lt;C-h&gt;` `&lt;left&gt;` `&lt;C-^&gt;` `&lt;C-l&gt;` `&lt;right&gt;` 左移、右移。</span><br><span class="line">- 编辑</span><br><span class="line">  - `&lt;C-]&gt;` `&lt;bs&gt;` `&lt;del&gt;` 左删、右删一个字符。</span><br><span class="line">  - `&lt;C-w&gt;` 左删一个词。</span><br><span class="line">  - `&lt;C-u&gt;` 清空。</span><br><span class="line">- 浏览输入记录</span><br><span class="line">  - `&lt;C-n&gt;` `&lt;C-p&gt;` 上翻、下翻。</span><br><span class="line">- 打开/创建文件</span><br><span class="line">  - `&lt;CR&gt;` 在当前窗口打开。</span><br><span class="line">  - `&lt;C-t&gt;` 在新 tab 打开。</span><br><span class="line">  - `&lt;C-v&gt;` 在新水平分割窗口打开。</span><br><span class="line">  - `&lt;C-x&gt;` `&lt;C-x&gt;` `&lt;C-CR&gt;` `&lt;C-s&gt;` 在新垂直分割窗口打开。</span><br><span class="line">  - `&lt;C-y&gt;` 创建新文件。</span><br><span class="line">- 打开多个文件</span><br><span class="line">  - `&lt;C-z&gt;` 标记/取消标记一个待打开的文件；标记/取消标记一个文件，它所在的目录会作为创建新文件的目录 `&lt;C-y&gt;`。</span><br><span class="line">  - `&lt;C-o&gt;` 打开所有被标记的文件。若没有标记文件的话就根据以下选项打开一个控制台对话框：</span><br><span class="line">    - `t` 在 tab 中。</span><br><span class="line">    - `v` 在垂直分割窗口中。</span><br><span class="line">    - `h` 在水平分割窗口中。</span><br><span class="line">    - `r` 在当前窗口。</span><br><span class="line">    - `i` 作为隐藏缓冲区。</span><br><span class="line">    - `x` （可选）使用 `g:ctrlp_open_func` 定义的函数。</span><br><span class="line">    - `a` 标记匹配窗口中的所有文件。</span><br><span class="line">    - `d` 将 ctrlp 的工作目录切换到所选文件的目录。</span><br><span class="line">- 函数快捷键</span><br><span class="line">  - `&lt;F5&gt;` 全量刷新匹配窗口和最近历史记录（MRU）。</span><br><span class="line">  - `&lt;F7&gt;` 清空 MRU 或删除 MRU 中被标记的项目。</span><br><span class="line">- 粘贴</span><br><span class="line">  - `&lt;Insert&gt;` `&lt;MiddleMouse&gt;` 将剪贴板粘贴至输入框。</span><br><span class="line">  - `&lt;C-\&gt;` 弹出一个对话框来选择粘贴的内容：光标下的词、光标下的文件名、搜索寄存器内容、最近的框选内容、系统剪贴板、指定寄存器。</span><br><span class="line"></span><br><span class="line">### 输入格式</span><br><span class="line"></span><br><span class="line">- 简单字符串：&apos;abc&apos; 相当于 `a[^a]\&#123;-&#125;b[^b]\&#123;-&#125;c`。</span><br><span class="line">- 正则表达式：按照 vim 的正则规则。</span><br><span class="line">- 字符串后紧跟 `:&#123;cmd&#125;`：指定打开文件后执行的命令。</span><br><span class="line">- 切换目录</span><br><span class="line">  - `..`：往上一级。后续每多一个点表示再往上一级。</span><br><span class="line">  - `@cd &#123;path&#125;` 切换目录。</span><br><span class="line">  - `@cd %:h` 切换到当前文件的目录。</span><br><span class="line">  - `/` `\` 切换到项目根目录。</span><br><span class="line">- `?` 帮助文件。</span><br><span class="line"></span><br><span class="line">### 自定义</span><br><span class="line"></span><br><span class="line">`:h ctrlp-customization` `:h ctrlp-options`</span><br><span class="line"></span><br><span class="line">- 更改启动命令</span><br><span class="line">  - `let g:ctrlp_map = &apos;&lt;C-p&gt;&apos;`</span><br><span class="line">  - `let g:ctrlp_cmd = &apos;CtrlP&apos;`</span><br><span class="line">- 不带指定目录启动时</span><br><span class="line">  - `let g:ctrlp_working_path_mode = &apos;ra&apos;`</span><br><span class="line">    - `c` 当前文件所在目录。</span><br><span class="line">    - `a` 当前文件所在目录，除非它是 `cwd` 的子目录。</span><br><span class="line">    - `r` 父目录中最近一个包含版本控制信息的目录：`.git`、`.hg`、`.svn`、`.bzr`、`_darcs`。</span><br><span class="line">      - `let g:ctrlp_root_marks = [&apos;pom.xml&apos;, &apos;.p4ignore&apos;]` 自定义父目录的标识。</span><br><span class="line">    - `w` 作为 `r` 的修饰符，从 `cwd` 开始搜索，而不是当前文件所在目录。</span><br><span class="line">    - `0` `&apos;&apos;` 禁用此特性。</span><br><span class="line">- 排除文件和目录</span><br></pre></td></tr></table></figure></p>
<p>“ vim 自带的排除方式<br>set wildignore+=<em>/tmp/</em>,<em>.so,</em>.swp,<em>.zip     “ MacOSX/Linux<br>set wildignore+=</em>\tmp\<em>,</em>.swp,<em>.zip,</em>.exe  “ Windows</p>
<p>“ ctrlp 的排除方式<br>let g:ctrlp_custom_ignore = ‘\v[\/].(git|hg|svn)$’<br>let g:ctrlp_custom_ignore = {<br>  \ ‘dir’:  ‘\v[\/].(git|hg|svn)$’,<br>  \ ‘file’: ‘\v.(exe|so|dll)$’,<br>  \ ‘link’: ‘some_bad_symbolic_links’,<br>  \ }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 排除 `.gitignore` 中的文件和目录</span><br></pre></td></tr></table></figure>
<p>let g:ctrlp_user_command = [‘.git’, ‘cd %s &amp;&amp; git ls-files -co –exclude-standard’]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自定义的搜索规则</span><br></pre></td></tr></table></figure>
<p>let g:ctrlp_user_command = ‘find %s -type f’        “ MacOSX/Linux<br>let g:ctrlp_user_command = ‘dir %s /-n /b /s /a-d’  “ Windows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fugitive</span><br><span class="line"></span><br><span class="line">### 对象 fugitive-objects</span><br><span class="line"></span><br><span class="line">- `:` 同 `:Gstatus`</span><br><span class="line">- `.git/config` 仓库的配置文件</span><br><span class="line">- `HEAD` .git/HEAD</span><br><span class="line">- `refs/heads/x` .git/refs/heads/x</span><br><span class="line">- 当前文件</span><br><span class="line">  - `:%` 当前文件在暂存区中的对应文件</span><br><span class="line">  - `@~2:%` 当前文件在 HEAD 的祖父提交中的对应文件</span><br><span class="line">  - `:1:%` 冲突状态中，当前文件在共同祖先中的对应文件</span><br><span class="line">  - `:2:#` 冲突状态中，当前文件在目标分支中的对应文件</span><br><span class="line">- 指定文件名的文件</span><br><span class="line">  - `./master` 工作目录下名为 master 的文件</span><br><span class="line">  - `Makefile` 工作区中名为 Makefile 的文件</span><br><span class="line">  - `@^:Makefile` HEAD 的父提交中名为 Makefile 的文件</span><br><span class="line">  - `:Makefile` 暂存区中的 Makefile 文件</span><br><span class="line">  - `!:Makefile` 包含当前文件的提交中的名为 Makefile 的文件</span><br><span class="line">- 提交</span><br><span class="line">  - `@` HEAD 指向的提交</span><br><span class="line">  - `master^` master 的父提交</span><br><span class="line">  - `master:` master 指向的 tree 对象</span><br><span class="line">  - `!` 包含当前文件的提交</span><br><span class="line">- 指定缓冲区中的文件</span><br><span class="line">  - `:3:#5` 冲突状态中，缓冲区 #5 中文件在被合并分支中对应的文件</span><br><span class="line">  - `!3^2` 包含缓冲区 #3 中文件的提交的第二父提交</span><br><span class="line"></span><br><span class="line">### 命令</span><br><span class="line"></span><br><span class="line">**通用**</span><br><span class="line"></span><br><span class="line">- `Git &#123;args&#125;` 执行 Git 命令，相当于 `:!git &#123;args&#125;`。</span><br><span class="line">- `Git! &#123;args&#125;` 执行 Git 命令，将结果输出到临时文件。</span><br><span class="line">- `Gcd|Glcd [&#123;dir&#125;]` cd/lcd 到项目根目录。</span><br><span class="line"></span><br><span class="line">**本地仓库**</span><br><span class="line"></span><br><span class="line">- `G[status]` 在新窗口中查看 git status。</span><br><span class="line">  - `g?` 查看 fugitive-mappings。</span><br><span class="line">  - `-` add/reset 某个文件的修改。</span><br><span class="line">  - `=` 展开各个差异块。</span><br><span class="line">- `Gdiff` 查看当前文件工作区到暂存区的差异。</span><br><span class="line">  - `Gsdiff` 横向分割窗口</span><br><span class="line">  - `Gvdiff` 纵向分割窗口</span><br><span class="line">- `Gcommit &#123;args&#125;` 提交当前文件，在新窗口中编辑提交信息。</span><br><span class="line">- `Gmerge &#123;args&#125;` 合并分支，在 quickfix 窗口中列出冲突文件。</span><br><span class="line">- `Grebase`</span><br><span class="line">- `Gmove` git mv 同时会重命名缓冲区。</span><br><span class="line">- `Gdelete` git rm 同时会删除缓冲区。</span><br><span class="line">- `Gread` git checkout -- filename</span><br><span class="line">- `Gwrite` 将缓冲区写到工作区和暂存区。</span><br><span class="line">- `Ge` `Gsp` `Gvsp` `Gtabe` 查看指定的对象、树、提交或标签。</span><br><span class="line"></span><br><span class="line">**远程仓库**</span><br><span class="line"></span><br><span class="line">- `Gfetch &#123;args&#125;` `Gpull &#123;args&#125;` `Gpush &#123;args&#125;`</span><br><span class="line"></span><br><span class="line">**历史日志**</span><br><span class="line"></span><br><span class="line">- `Gblame [flags]` flags 会被传递给 git-blame。</span><br><span class="line">  在 blame 窗口可以使用以下热键：</span><br><span class="line">  - `g?` 帮助</span><br><span class="line">  - `A` 重置尺寸至作者列</span><br><span class="line">  - `C` 重置尺寸至提交列</span><br><span class="line">  - `D` 重置尺寸至日期列</span><br><span class="line">  - `q` 退出 blame</span><br><span class="line">  - `gq` 退出 blame 并 `:Gedit` 工作区中的版本（不懂跟 `q` 有什么区别）</span><br><span class="line">  - `&lt;CR&gt;` 打开光标下的提交</span><br><span class="line">  - `o` 在水平分割窗口打开提交</span><br><span class="line">  - `O` 在新标签页打开提交</span><br><span class="line">  - `p` 在预览窗口打开提交</span><br><span class="line">  - `-` 在光标下的提交上再做 blame</span><br><span class="line">  - `~` 在第 [count] 个第一父提交上再做 blame</span><br><span class="line">  - `P` 在第 [count] 父提交上再做 blame（相当于 HEAD^[count]）</span><br><span class="line">- `0Glog` 通过 quickfix 窗口遍历当前文件历史。</span><br><span class="line">- `Glog &#123;args&#125;` 通过 quickfix 窗口浏览提交历史。</span><br><span class="line">  - `--` 查看所有提交，否则查看涉及当前文件的提交。</span><br><span class="line">- `Gllog &#123;args&#125;` 类似 `Glog`，不过是用 location list。</span><br><span class="line"></span><br><span class="line">### 热键</span><br><span class="line"></span><br><span class="line">这些热键大多数都能在 `:Gstatus` 窗口和 fugitive 对象窗口使用。</span><br><span class="line"></span><br><span class="line">**暂存和撤销**</span><br><span class="line"></span><br><span class="line">- `s` stage 光标下的文件或块。</span><br><span class="line">- `u` unstange 光标下的文件或块。</span><br><span class="line">- `-` stage/unstage 光标下的文件或块。</span><br><span class="line">- `&lt;C-N&gt;` 跳到下个文件或块。</span><br><span class="line">- `&lt;C-P&gt;` 跳到上个文件或块。</span><br><span class="line">- `X` 放弃光标下的改动，即 checkout 或 clean。</span><br><span class="line">- `=` 在光标处切换内联差异比较。</span><br><span class="line">- `&lt;` 在光标处插入内联差异比较。</span><br><span class="line">- `&gt;` 在光标处移除内联差异比较。</span><br><span class="line">- `i` 对于未跟踪文件，执行 `git add --intent-to-add`。否则移至下个块并展开内联差异比较</span><br><span class="line">- `dd` 对光标下的文件执行 `:Gdiff`。</span><br><span class="line">- `ds` 对光标下的文件执行 `:Gsdiff`。</span><br><span class="line">- `dv` 对光标下的文件执行 `:Gvdiff`。</span><br><span class="line">- `P` 对光标下的文件执行 `:Git add --patch` 或 `:Git reset --patch`。</span><br><span class="line"></span><br><span class="line">**导航**</span><br><span class="line"></span><br><span class="line">- `&lt;CR&gt;` 打开光标下的文件或对象。</span><br><span class="line">- `o` `gO` 在新窗口中打开光标下的文件或对象。</span><br><span class="line">- `O` 在新标签页中打开光标下的文件或对象。</span><br><span class="line">- `~` 相当于 Git 的 `~`。</span><br><span class="line">- `P` 相当于 Git 的 `^`。</span><br><span class="line">- `C` 打开包含当前文件的提交。</span><br><span class="line">- `&lt;C-W&gt;C` 在新窗口中打开包含当前文件的提交。</span><br><span class="line"></span><br><span class="line">**提交**</span><br><span class="line"></span><br><span class="line">- `cc` 创建提交。</span><br><span class="line">- `ca` commit --amend 并编辑提交信息。</span><br><span class="line">- `ce` commit --amend 且不编辑提交信息。</span><br><span class="line">- `cw` 编辑最近一次提交。</span><br><span class="line">- `cvc` 带 `-v` 提交。</span><br><span class="line">- `cva` 带 `-v` amend。</span><br><span class="line">- `cf` 为光标下的提交创建一个 fixup 提交。</span><br><span class="line">- `cs` 为光标下的提交创建一个 squash 提交。</span><br><span class="line">- `cA` 为光标下的提交创建一个 squash 提交并编辑信息。</span><br><span class="line"></span><br><span class="line">**Rebase**</span><br><span class="line"></span><br><span class="line">- `ri` 执行交互式 rebase，以光标下提交的父提交作为基准。</span><br><span class="line">- `rf` 执行自动压缩 rebase，以光标下提交的父提交作为基准。</span><br><span class="line">- `ru` 以 upstream 分支为基准执行交互式 rebase。</span><br><span class="line">- `rp` 以 push 分支为基准执行交互式 rebase。</span><br><span class="line"></span><br><span class="line">### 其他</span><br><span class="line"></span><br><span class="line">`set statusline=%&#123;FugitiveStatusline()&#125;` 在状态栏添加分支信息</span><br><span class="line"></span><br><span class="line">## gitgutter</span><br><span class="line"></span><br><span class="line">更新频率取决于 vim 的 `updatetime` 选项，默认 4000 ms。</span><br><span class="line"></span><br><span class="line">同一文件改动超过 500 处时，会隐藏标记。可设置 `let g:gitgutter_max_signs = 500`</span><br><span class="line"></span><br><span class="line">### 快捷键</span><br><span class="line"></span><br><span class="line">- `[c` `]c` 在改动块间跳转。</span><br><span class="line">- `&lt;leader&gt;hp` 预览改动块。</span><br><span class="line">- `&lt;leader&gt;hs` 暂存改动块。</span><br><span class="line">- `&lt;leader&gt;hu` 回退改动块。（不是 unstage）</span><br><span class="line">- 整体开关</span><br><span class="line">  - `:GitGutterDisable`</span><br><span class="line">  - `:GitGutterEnable`</span><br><span class="line">  - `:GitGutterToggle`</span><br><span class="line">- 缓冲区独立开关</span><br><span class="line">  - `:GitGutterBufferDisable`</span><br><span class="line">  - `:GitGutterBufferEnable`</span><br><span class="line">  - `:GitGutterBufferToggle`</span><br><span class="line">- 标记开关</span><br><span class="line">  - `:GitGutterSignsDisable`</span><br><span class="line">  - `:GitGutterSignsEnable`</span><br><span class="line">  - `:GitGutterSignsToggle`</span><br><span class="line">- 行高亮</span><br><span class="line">  - `:GitGutterLineHighlightsDisable`</span><br><span class="line">  - `:GitGutterLineHighlightsEnable`</span><br><span class="line">  - `:GitGutterLineHighlightsToggle`</span><br><span class="line"></span><br><span class="line">### 文本对象</span><br><span class="line"></span><br><span class="line">- `ic` 改动块中的所有行。</span><br><span class="line">- `ac` 改动块中的所有行以及后面紧跟的所有空行。</span><br><span class="line"></span><br><span class="line">### 折叠</span><br><span class="line"></span><br><span class="line">- `:GitGutterFold` 折叠/展开所有未改动的行。</span><br><span class="line">- `zr` 展开改动块前后 3 行。</span><br><span class="line"></span><br><span class="line"># 折叠</span><br><span class="line"></span><br><span class="line">## 折叠相关的 Vim 变量</span><br><span class="line"></span><br><span class="line">|变量          |含义                                    |</span><br><span class="line">|:-------------|:---------------------------------------|</span><br><span class="line">|`v:foldstart` |折叠首行的行号                          |</span><br><span class="line">|`v:foldend`   |折叠末行的行号                          |</span><br><span class="line">|`v:folddashes`|一个含有连字符的字符串，用来表示折叠级别|</span><br><span class="line">|`v:foldlevel` |折叠级别                                |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 折叠选项</span><br><span class="line"></span><br><span class="line">- **颜色 COLORS**</span><br><span class="line">关闭的折叠的颜色由 Folded 高亮组（*hl-Folded*）设定。折叠栏的颜色由 FoldColumn 组（*hl-FoldColumn*）设定。</span><br><span class="line">`:highlight Folded guibg=grey guifg=blue`</span><br><span class="line">`:highlight FoldColumn guibg=darkgrey guifg=white`</span><br><span class="line">- **折叠级别 FOLDLEVEL**</span><br><span class="line">包含行数小于等于 `foldlevel` 的折叠始终以展开的形式来显示。</span><br><span class="line">`foldlevel` 被改变后立即生效。</span><br><span class="line">- **折叠文本 FOLDTEXT**</span><br><span class="line">`foldtext` 是一个字符串表达式，定义了关闭折叠时所显示的文字。如：</span><br><span class="line">` :set foldtext=v:folddashes.substitute(getline(v:foldstart),&apos;/\\*\\\|\\*/\\\|&#123;&#123;&#123;\\d\\=&apos;,&apos;&apos;,&apos;g&apos;)`</span><br><span class="line">在折叠时显示被折叠文本的首行的内容，并删除了其中的&quot;/*&quot;、&quot;*/&quot;、&quot;&#123;&#123;&#123;&quot;。</span><br><span class="line">以上功能也可通过一段函数来实现：</span><br></pre></td></tr></table></figure>
<p>  set foldtext=MyFoldText()<br>  function MyFoldText()</p>
<pre><code>let line = getline(v:foldstart)
let sub = substitute(line, &apos;/\*\|\*/\|{{{\d\=', '', 'g')
      return v:folddashes . sub
    endfunction
    ```
- **折叠栏 FOLDCOLUMN**
折叠栏显示在窗口左侧，展示了所有折叠的结构。可以通过点击折叠栏中的“+”号来展开该折叠，通过点击任何其他非空字符来关闭该行所在折叠。
通过设定 `foldcolumn` 的值（0~12）来改变折叠栏的宽度。
- **其他选项**
`foldenable` `fen`：复位时打开所有折叠。
`foldexpr` `fde`：用于 `expr` 折叠模式的表达式。
`foldignore` `fdi`：用于 `indent` 折叠模式的字符。
`foldmarker` `fmr`：用于 `marker` 折叠模式的标志。
`foldmethod` `fdm`：当前折叠模式。
`foldminlines` `fml`：关闭折叠时的最小显示行数。
`foldnestmax` `fdn`：用于 `indent` 和 `syntax` 折叠模式的最大嵌套层数。
`foldopen` `fdo`：哪些命令可以打开已关闭的折叠。
`foldclose` `fcl`：非光标所在折叠是否关闭。缺省为""。若设置为“all”则所有高于 `foldlevel` 且非光标所在折叠都会自动关闭。

## 折叠方式

`set foldmethod = {method}` or `set fdm = {method}`

其中 {method} 有6个选项，各方式之间不兼容：

|命令  |含义                    |
|:-----|:-----------------------|
|manual|手工定义折叠            |
|indent|同等的缩进表示同级的折叠|
|expr  |用表达式来定义折叠      |
|syntax|用语法高亮来定义折叠    |
|diff  |对没有更改的文本进行折叠|
|marker|用特定标志标识折叠      |

当从 `manual` 模式切换到其他模式时，所有已存在的折叠会被删除并创建新折叠。而反过来则不会删除已存在的折叠。所以通常先选择 `manual` 之外的某种模式，得到自动生成的折叠，然后切换到 `manual` 模式。

- **manual**
  使用命令来创建折叠。折叠级别由嵌套层级决定。可以通过对某些行反复定义折叠来增加折叠级别。
  当退出编辑时，手工折叠会丢失。使用 `:mkview` 来保存折叠，使用 `:loadview` 来载入折叠。
- **indent**
  折叠级别由缩进除以 `shiftwidth` 并向下取整得到。嵌套的层数受 `foldnestmax` 限制。
  某些行会被忽略并得到相邻行的折叠级别（取较小值），这类行包括空行和以 `foldignore` 中某个字符开始的行。
- **expr**
  折叠级别通过对每行计算 `foldexpr` 的值来定义。该模式比较复杂，不常用。详见 `:h fold-expr`。
- **syntax**
  折叠由带有“fold”参数的语法项来定义（`:h syn-fold`）。折叠级别由折叠的嵌套层数决定。嵌套的折叠数量受 `foldnestmax` 限制。详见 `:h fold-syntax`。
- **diff**
  对未改动的文本或靠近改动的文本自动定义折叠。仅对当前窗口已设定 `diff` 选项来显示不同之处时有效，不然，整个缓冲区就是一个大折叠。详见 `:h fold-diff`。
- **marker**
  折叠根据 `foldmarker` 的值来定义，缺省值为“{{{,}}}”，建议不要修改。
</code></pre><p>折叠行所显示的文本取决于 <code>foldtext</code> 选项，缺省为 foldtext() 的返回值，即折叠标志之前的文本。<br>“3x{” 标志一个折叠的开始。可以用 “3x}” 标志一个折叠的结束（也可以不用，假如所有折叠都处于一个大嵌套中的话）。“3x{” 和 “3x}” 后都可以紧跟一个数字（0除外），表示该折叠的级别，数字越大，折叠所在的嵌套越深。<br>带数字的标志和不带数字的标志可以混合使用。</p>
</li>
</ul>
<h2 id="创建和删除折叠"><a href="#创建和删除折叠" class="headerlink" title="创建和删除折叠"></a>创建和删除折叠</h2><ul>
<li><code>zf{motion}</code> <code>{visual}zf</code> <code>{count}zF</code> <code>:{range}fo[ld]</code><br>创建折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zd</code> <code>{visual}zd</code><br>删除光标所在行的折叠，该折叠内的折叠将自动上移一级，或删除选中区域的所有折叠，且不可撤销。只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zD</code> <code>{visual}zD</code><br>删除光标所在行及其内的所有折叠，或删除选中区域及其内的所有折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zE</code><br>删除（eliminate）当前窗口内的所有折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
</ul>
<h2 id="展开和关闭折叠"><a href="#展开和关闭折叠" class="headerlink" title="展开和关闭折叠"></a>展开和关闭折叠</h2><p>包含行数小于 <code>foldminlines</code> / <code>fdm</code> 的折叠将始终以展开的形式显示。<code>foldminlines</code>缺省为 1。</p>
<ul>
<li><code>[count]zo</code>：打开光标下的折叠。当给定计数时，打开相应深度的折叠。在可视模式下，所选区域所有折叠都打开一级。</li>
<li><code>zO</code>：打开光标所在行及其内的所有折叠。在可视模式下，打开所选区域内的所有折叠。</li>
<li><code>[count]zc</code>：关闭光标下的折叠。当给定计数时，关闭从光标所在折叠开始的相应级数的折叠。在可视模式下，所选区域内的折叠被关闭一级。</li>
<li><code>zC</code>：关闭光标所在行及其内的所有折叠。在可视模式下，关闭所选区域内的所有折叠。</li>
<li><code>[count]za</code>：打开/关闭光标所在折叠。当给定计数时，打开/关闭相应数量的折叠。</li>
<li><code>zA</code>：打开/关闭光标所在折叠及其内的所有折叠。</li>
<li><code>zv</code>：查看（view）折叠，打开光标所在折叠及其上级的所有折叠。</li>
<li><code>zx</code>：更新折叠。撤销被手动打开和关闭的折叠：再次应用 <code>foldlevel</code>。然后使用 <code>zv</code>。同时强制重新计算折叠。使用 <code>foldexpr</code> 并且缓冲区发生改变但折叠不能正确地更新时，这会有用。</li>
<li><code>zX</code>：类似 <code>zx</code>。</li>
<li><code>zm</code>：折叠更多（more）：<code>foldlevel</code> 减1。</li>
<li><code>zM</code>：关闭所有折叠，将 <code>foldlevel</code> 设为0。</li>
<li><code>zr</code>：折叠减少（reduce）：<code>foldlevel</code> 加1。</li>
<li><code>zR</code>：打开所有折叠，将 <code>foldlevel</code> 设为最高级别。</li>
<li><code>:{range}foldo[pen][!]</code>：在 {range} 内打开一级折叠，若加上 <code>!</code> 则打开 {range} 内的所有折叠。</li>
<li><code>:{range}foldc[lose][!]</code>：在 {range} 内关闭一级折叠，若加上 <code>!</code> 则关闭 {range} 内的所有折叠。</li>
<li><code>zn</code>：不折叠（none）：重置 <code>foldenable</code>。所有折叠被打开。</li>
<li><code>zN</code>：正常折叠（normal）：设定 <code>foldenable</code>。所有折叠都表现为之前的样子。</li>
<li><code>zi</code>：反转 <code>foldenable</code> 的值。</li>
</ul>
<h2 id="在折叠间移动"><a href="#在折叠间移动" class="headerlink" title="在折叠间移动"></a>在折叠间移动</h2><p><code>[count][z</code>：移动到当前打开折叠的开始。若已经在当前打开折叠的开始，则移动到上级折叠的开始。当给定计数时，重复[count]次<code>[z</code>命令。<br><code>[count]]z</code>：移动到当前打开折叠的末尾。若已经在当前打开折叠的末尾，则移动到上级折叠的末尾。当给定计数时，重复[count]次<code>]z</code>命令。<br><code>[count]zj</code>：移动到下一个折叠的开始，包括关闭的折叠。当给定计数时，重复[count]次<code>zj</code>命令。此命令可接在一个操作符（operator）后面。<br><code>[count]zk</code>：移动到上一个折叠的末尾，包括关闭的折叠。当给定计数时，重复[count]次<code>zk</code>命令。此命令可接在一个操作符（operator）后面。</p>
<h2 id="对折叠执行命令"><a href="#对折叠执行命令" class="headerlink" title="对折叠执行命令"></a>对折叠执行命令</h2><p><code>:[range]foldd[oopen] {cmd}</code>：对所有 [range] 范围内的、处于关闭折叠之外的行执行 {cmd}。执行过程类似 <code>:global</code> 命令：先标记所有需执行命令的行，然后执行命令。所以即使 {cmd} 会对折叠产生影响也不会改变 {cmd} 的执行范围。<br><code>:[range]folddoc[losed] {cmd}</code>：对所有 [range] 范围内的、处于关闭折叠之内的行执行 {cmd}。类似上一个命令。</p>
<h2 id="折叠行为"><a href="#折叠行为" class="headerlink" title="折叠行为"></a>折叠行为</h2><p>详见<code>:h fold-behavior</code>。</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><ul>
<li>encoding（enc）：encoding 是 Vim 的内部使用编码，encoding 的设置会影响 Vim 内部的 Buffer、消息文字等。若载入的文件与 encoding 不同，则 Vim 会先转换成 encoding，然后在写入时再转回去。在 Unix 环境下，encoding 的默认设置等于 locale；Windows 环境下会和当前代码页相同。在中文 Windows 环境下 encoding 的默认设置是 cp936（GBK）。</li>
<li>fileencodings（fencs）：Vim 在打开文件时会根据 fileencodings 选项来识别文件编码，fileencodings 可以同时设置多个编码，Vim 会根据设置的顺序来猜测所打开文件的编码。</li>
<li>fileencoding（fenc）：Vim 在保存新建文件时会根据 fileencoding 的设置编码来保存。如果是打开已有文件，Vim 会根据打开文件时所识别的编码来保存，除非在保存时重新设置 fileencoding。</li>
<li>termencodings（tenc）：在终端环境下使用 Vim 时，通过 termencoding 项来告诉 Vim 终端所使用的编码。</li>
</ul>
<p>保存文件时使用 <code>:set fileencoding=utf-8</code> 来使用指定的编码进行保存。</p>
<h1 id="自动配置选项"><a href="#自动配置选项" class="headerlink" title="自动配置选项"></a>自动配置选项</h1><p><em>:h auto-setting</em></p>
<h2 id="modeline"><a href="#modeline" class="headerlink" title="modeline"></a>modeline</h2><p>有两种形式的 modeline：</p>
<ul>
<li><code>[text]{white}{vi:|vim:|ex:}[white]{options}</code><ul>
<li><code>text</code>：任意文本。</li>
<li><code>white</code>：空格或 tab。</li>
<li><code>options</code>：若干选项，用空格或“:”分隔，每个选项都被作为 <code>:set</code> 的命令。</li>
</ul>
</li>
<li><code>[text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]</code><ul>
<li><code>se[t]</code>：当使用“Vim”时必须用 <code>set</code>。</li>
</ul>
</li>
</ul>
<p><code>ex:</code> 和 <code>Vim:</code> 前的空格是必需的，<code>vi:</code> 和 <code>vim:</code> 前的空格可选（为了兼容 3.0 版本）。</p>
<h1 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h1><p>用户自定义命令必须首字母大写，来避免与内建命令冲突，除了 <code>:Next</code>、<code>:X</code>，它们不能用于自定义命令。<code>:Print</code> 也是内建命令，但因为已废弃所以可以覆盖。</p>
<p>调用命令时可以用缩写，若根据缩写找到的命令不唯一则会报错。内建命令总是优先。</p>
<ul>
<li><code>:[verbose] com[mand] [{cmd}]</code> 列出所有用户定义的命令。展示结果前两列的符号：<ul>
<li><code>!</code> 该命令带有 <code>-bang</code> 属性。</li>
<li><code>&quot;</code> 该命令带有 <code>-register</code> 属性。</li>
<li><code>b</code> 该命令仅在当前缓冲区有效。</li>
<li><code>verbose</code> 额外显示命令的定义处。</li>
<li><code>{cmd}</code> 仅展示以 <code>{cmd}</code> 开头的命令。</li>
<li><code>:filter {subStr} command</code> 仅展示包含 <code>{subStr}</code> 的命令。</li>
</ul>
</li>
<li><code>:com[mand][!] [{attr}...] {cmd} {rep}</code> 定义一个命令。名称为 <code>{cmd}</code>，命令内容为 <code>{rep}</code>（其中可能包含代替换的文本），属性为 <code>{attr}</code>。若命令已存在会报错。使用 <code>!</code> 强制覆盖已有命令。<br>-</li>
<li><code>:delc[ommand] {cmd}</code> 删除命令。</li>
<li><code>comc[lear]</code> 删除所有用户定义命令。</li>
</ul>
<h2 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h2><p>命令执行前会自动替换命令内容中的 <code>&lt;...&gt;</code> 占位符。若要避免被替换，需用 <code>&lt;lt&gt;</code> 代替 <code>&lt;</code>。</p>
<ul>
<li><code>&lt;line1&gt;</code> 命令处理范围的开始行。</li>
<li><code>&lt;line2&gt;</code> 命令处理范围的结束行。</li>
<li><code>&lt;range&gt;</code> 命令范围这个参数本身的参数个数：0，1，2。</li>
<li><code>&lt;count&gt;</code> 传入的计数值。</li>
<li><code>&lt;bang&gt;</code> 若命令执行时带有 <code>!</code> 则会展开为 <code>!</code>，否则不展开。</li>
<li><code>&lt;mods&gt;</code> 命令修饰符，若执行时没带则不展开。<code>:aboveleft</code>, <code>:belowright</code>, <code>:botright</code>, <code>:browse</code>, <code>:confirm</code>, <code>:hide</code>, <code>:keepalt</code>, <code>:keepjumps</code>, <code>:keepmarks</code>, <code>:keeppatterns</code>, <code>:leftabove</code>, <code>:lockmarks</code>, <code>:noswapfile</code>, <code>:rightbelow</code>, <code>:silent</code>, <code>:tab</code>, <code>:topleft</code>, <code>:verbose</code>, <code>:vertical</code></li>
<li><code>&lt;reg&gt;</code> <code>&lt;register&gt;</code> 寄存器，若执行时没带则不展开。</li>
<li><code>&lt;args&gt;</code> 命令参数，但不包含计数和寄存器参数。</li>
<li><code>&lt;lt&gt;</code> 代表 <code>&lt;</code>，用来保留 <code>&lt;...&gt;</code> 类文本避免被替换。</li>
<li><code>&lt;q-{abc}&gt;</code> 若某个转义序列以“q-”开始，则它整体会被引号包裹起来，作为一个字符串。</li>
<li><code>&lt;f-args&gt;</code> 将命令入参根据空格分割成列表然后作为函数入参。<code>:h &lt;f-args&gt;</code></li>
</ul>
<h2 id="命令属性"><a href="#命令属性" class="headerlink" title="命令属性"></a>命令属性</h2><h3 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h3><ul>
<li>不显式声明参数。认为是不带参数，若调用时带参数会报错。</li>
<li><code>-nargs=0</code> 不带参数，同上。</li>
<li><code>-nargs=1</code> 有且仅有一个参数，包括空格。</li>
<li><code>-nargs=*</code> &gt;= 0 个参数，空格分隔。</li>
<li><code>-nargs=?</code> 0 或 1 个参数。</li>
<li><code>-nargs=+</code> &gt;= 1 个参数。</li>
</ul>
<p>若仅有一个参数，则空格会作为参数的一部分；若有多个参数，空格和 tab 会作为参数间的分隔符。</p>
<p>参数会作为文本传入命令然后解析，而不是作为表达式先解析再传入命令。也就是说若将变量作为实参，那么会在命令定义的作用域内查找该变量，而不是在命令的调用处的作用域内。</p>
<h3 id="补全行为"><a href="#补全行为" class="headerlink" title="补全行为"></a>补全行为</h3><p>命令的参数默认不会被补全，除非声明下列一个或多个参数。</p>
<ul>
<li><code>-complete=arglist</code> 参数列表中的文件名</li>
<li><code>-complete=augroup</code> 自动命名组</li>
<li><code>-complete=buffer</code> 缓冲区名称</li>
<li><code>-complete=behave</code> :behave 子选项</li>
<li><code>-complete=color</code> 颜色方案</li>
<li><code>-complete=command</code> Ex 命令及其参数</li>
<li><code>-complete=compiler</code> 编译器</li>
<li><code>-complete=cscope</code> :cscope 子选项</li>
<li><code>-complete=dir</code> 目录名</li>
<li><code>-complete=environment</code> 环境变量名</li>
<li><code>-complete=event</code> 自动命令事件</li>
<li><code>-complete=expression</code> Vim 表达式</li>
<li><code>-complete=file</code> 文件名和目录名</li>
<li><code>-complete=file_in_path</code> “path”中的文件名和目录名</li>
<li><code>-complete=filetype</code> 文件类型名</li>
<li><code>-complete=function</code> 函数名</li>
<li><code>-complete=help</code> 帮助主题</li>
<li><code>-complete=highlight</code> 高亮组</li>
<li><code>-complete=history</code> :history 子选项</li>
<li><code>-complete=locale</code> locale 名 (和 <code>locale -a</code> 给出的相同)</li>
<li><code>-complete=mapclear</code> 缓冲区参数</li>
<li><code>-complete=mapping</code> 映射名</li>
<li><code>-complete=menu</code> 菜单</li>
<li><code>-complete=messages</code> :messages 子选项</li>
<li><code>-complete=option</code> 选项</li>
<li><code>-complete=packadd</code> 可选包名</li>
<li><code>-complete=shellcmd</code> Shell 命令</li>
<li><code>-complete=sign</code> :sign 子选项</li>
<li><code>-complete=syntax</code> 语法文件名</li>
<li><code>-complete=syntime</code> :syntime 子选项</li>
<li><code>-complete=tag</code> 标签</li>
<li><code>-complete=tag_listfiles</code> 标签，但敲入 <code>&lt;C-d&gt;</code> 时显示文件名</li>
<li><code>-complete=user</code> 用户名</li>
<li><code>-complete=var</code> 用户变量</li>
<li><code>-complete=custom,{func}</code> 用户自定义补全，通过 <code>{func}</code> 定义。</li>
<li><code>-complete=customlist,{func}</code> 用户自定义补全，通过 <code>{func}</code> 定义。</li>
</ul>
<h3 id="范围处理"><a href="#范围处理" class="headerlink" title="范围处理"></a>范围处理</h3><ul>
<li><code>-range</code> 允许范围，默认当前行</li>
<li><code>-range=%</code> 允许范围，默认全文</li>
<li><code>-range={n}</code> 计数（默认 n），用法类似 <code>:3{cmd}</code></li>
<li><code>-count=[{n}]</code> 计数（默认 n，若不声明则默认 0），用法类似 <code>:3{cmd}</code> 或 <code>:{cmd} 3</code></li>
<li><code>-addr=lines</code> 将范围应用于行（默认）</li>
<li><code>-addr=arguments</code> 将范围应用于参数</li>
<li><code>-addr=buffers</code> 将范围应用于缓冲区，包括未加载的</li>
<li><code>-addr=loaded_buffers</code> 将范围应用于已加载的缓冲区</li>
<li><code>-addr=windows</code>    将范围应用于窗口</li>
<li><code>-addr=tabs</code> 将范围应用于标签页</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><code>-bang</code> 命令接受强制执行 <code>!</code></li>
<li><code>-bar</code> 命令接受管道符 <code>|</code> 和后续命令。此时命令参数中不允许出现 <code>|</code>。同时会检查 <code>&quot;</code> 作为注释的开始。</li>
<li><code>-register</code> 命令的第一个参数可以是一个可选的寄存器名（类似 <code>:del</code>）</li>
<li><code>-buffer</code> 命令仅在当前缓冲区可用</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Javascript/JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Javascript/JavaScript/" itemprop="url">JavaScript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ul>
<li>区分大小写。</li>
<li>转义序列表示任一 Unicode 内码：<code>\u01AB</code>，其中后 4 位是可变 16 进制数。注释中的转义序列不会被解释为 Unicode 内码。</li>
</ul>
<h2 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h2><ul>
<li>标识符必须以<strong>字符</strong>、<strong>下划线</strong>或<strong>美元符号（$）</strong>开始，后续可以是字母、数字、下划线或美元符。</li>
<li>出于可移植性和可读性的考虑，通常只用 ASCII 字母和数字来书写标识符。但从技术上来讲，JavaScript 允许标识符中出现 Unicode 字符全集中的字母和数字。ECMAScript 标准也允许在标识符首字符后面出现 Unicode 字符集中的 Mn 类、Mc 类和 Pc 类[^1]。</li>
</ul>
<p><strong>JavaScript 保留关键字</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abstract</td>
<td style="text-align:left">arguments</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">break</td>
<td style="text-align:left">byte</td>
<td style="text-align:left">case</td>
<td style="text-align:left">catch</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">class#</td>
<td style="text-align:left">const</td>
<td style="text-align:left">continue</td>
<td style="text-align:left">debugger</td>
<td style="text-align:left">default</td>
<td style="text-align:left">delete</td>
</tr>
<tr>
<td style="text-align:left">do</td>
<td style="text-align:left">double</td>
<td style="text-align:left">else</td>
<td style="text-align:left">enum#</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">export#</td>
<td style="text-align:left">extends#</td>
</tr>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">final</td>
<td style="text-align:left">finally</td>
<td style="text-align:left">float</td>
<td style="text-align:left">for</td>
<td style="text-align:left">function</td>
<td style="text-align:left">goto</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left">implements</td>
<td style="text-align:left">import#</td>
<td style="text-align:left">in</td>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">int</td>
<td style="text-align:left">interface</td>
</tr>
<tr>
<td style="text-align:left">let</td>
<td style="text-align:left">long</td>
<td style="text-align:left">native</td>
<td style="text-align:left">new</td>
<td style="text-align:left">null</td>
<td style="text-align:left">package</td>
<td style="text-align:left">private</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">public</td>
<td style="text-align:left">return</td>
<td style="text-align:left">short</td>
<td style="text-align:left">static</td>
<td style="text-align:left">super#</td>
<td style="text-align:left">switch</td>
</tr>
<tr>
<td style="text-align:left">synchronized</td>
<td style="text-align:left">this</td>
<td style="text-align:left">throw</td>
<td style="text-align:left">throws</td>
<td style="text-align:left">transient</td>
<td style="text-align:left">true</td>
<td style="text-align:left">try</td>
</tr>
<tr>
<td style="text-align:left">typeof</td>
<td style="text-align:left">var</td>
<td style="text-align:left">void</td>
<td style="text-align:left">volatile</td>
<td style="text-align:left">while</td>
<td style="text-align:left">with</td>
<td style="text-align:left">yield</td>
</tr>
</tbody>
</table>
<p><em><code>#</code> 标记的关键字是 ECMAScript5 中新添加的。</em></p>
<p><strong>JavaScript 对象、属性和方法</strong></p>
<p>应该避免使用 JavaScript 内置的对象、属性和方法的名称作为 Javascript 的变量或函数名</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">Date</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">function</td>
<td style="text-align:left">hasOwnProperty</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">isFinite</td>
<td style="text-align:left">isNaN</td>
<td style="text-align:left">isPrototypeOf</td>
<td style="text-align:left">length</td>
</tr>
<tr>
<td style="text-align:left">Math</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">name</td>
<td style="text-align:left">Number</td>
<td style="text-align:left">Object</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td style="text-align:left">String</td>
<td style="text-align:left">toString</td>
<td style="text-align:left">undefined</td>
<td style="text-align:left">valueOf</td>
</tr>
</tbody>
</table>
<p><strong>Java 保留关键字</strong></p>
<p>JavaScript 经常与 Java 一起使用，应该避免使用一些 Java 对象和属性作为 JavaScript 标识符</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getClass</td>
<td style="text-align:left">java</td>
<td style="text-align:left">JavaArray</td>
<td style="text-align:left">javaClass</td>
<td style="text-align:left">JavaObject</td>
<td style="text-align:left">JavaPackage</td>
</tr>
</tbody>
</table>
<p><strong>Windows 保留关键字</strong></p>
<p>JavaScript 可以在 HTML 外部使用。它可在许多其他应用程序中作为编程语言使用。<br>在 HTML 中，必须（为了可移植性，也应该这么做）避免使用 HTML 和 Windows 对象和属性的名称作为 Javascript 的变量及函数名</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">alert</td>
<td style="text-align:left">all</td>
<td style="text-align:left">anchor</td>
<td style="text-align:left">anchors</td>
<td style="text-align:left">area</td>
</tr>
<tr>
<td style="text-align:left">assign</td>
<td style="text-align:left">blur</td>
<td style="text-align:left">button</td>
<td style="text-align:left">checkbox</td>
<td style="text-align:left">clearInterval</td>
</tr>
<tr>
<td style="text-align:left">clearTimeout</td>
<td style="text-align:left">clientInformation</td>
<td style="text-align:left">close</td>
<td style="text-align:left">closed</td>
<td style="text-align:left">confirm</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">crypto</td>
<td style="text-align:left">decodeURI</td>
<td style="text-align:left">decodeURIComponent</td>
<td style="text-align:left">defaultStatus</td>
</tr>
<tr>
<td style="text-align:left">document</td>
<td style="text-align:left">element</td>
<td style="text-align:left">elements</td>
<td style="text-align:left">embed</td>
<td style="text-align:left">embeds</td>
</tr>
<tr>
<td style="text-align:left">encodeURI</td>
<td style="text-align:left">encodeURIComponent</td>
<td style="text-align:left">escape</td>
<td style="text-align:left">event</td>
<td style="text-align:left">fileUpload</td>
</tr>
<tr>
<td style="text-align:left">focus</td>
<td style="text-align:left">form</td>
<td style="text-align:left">forms</td>
<td style="text-align:left">frame</td>
<td style="text-align:left">innerHeight</td>
</tr>
<tr>
<td style="text-align:left">innerWidth</td>
<td style="text-align:left">layer</td>
<td style="text-align:left">layers</td>
<td style="text-align:left">link</td>
<td style="text-align:left">location</td>
</tr>
<tr>
<td style="text-align:left">mimeTypes</td>
<td style="text-align:left">navigate</td>
<td style="text-align:left">navigator</td>
<td style="text-align:left">frames</td>
<td style="text-align:left">frameRate</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">history</td>
<td style="text-align:left">image</td>
<td style="text-align:left">images</td>
<td style="text-align:left">offscreenBuffering</td>
</tr>
<tr>
<td style="text-align:left">open</td>
<td style="text-align:left">opener</td>
<td style="text-align:left">option</td>
<td style="text-align:left">outerHeight</td>
<td style="text-align:left">outerWidth</td>
</tr>
<tr>
<td style="text-align:left">packages</td>
<td style="text-align:left">pageXOffset</td>
<td style="text-align:left">pageYOffset</td>
<td style="text-align:left">parent</td>
<td style="text-align:left">parseFloat</td>
</tr>
<tr>
<td style="text-align:left">parseInt</td>
<td style="text-align:left">password</td>
<td style="text-align:left">pkcs11</td>
<td style="text-align:left">plugin</td>
<td style="text-align:left">prompt</td>
</tr>
<tr>
<td style="text-align:left">propertyIsEnum</td>
<td style="text-align:left">radio</td>
<td style="text-align:left">reset</td>
<td style="text-align:left">screenX</td>
<td style="text-align:left">screenY</td>
</tr>
<tr>
<td style="text-align:left">scroll</td>
<td style="text-align:left">secure</td>
<td style="text-align:left">select</td>
<td style="text-align:left">self</td>
<td style="text-align:left">setInterval</td>
</tr>
<tr>
<td style="text-align:left">setTimeout</td>
<td style="text-align:left">status</td>
<td style="text-align:left">submit</td>
<td style="text-align:left">taint</td>
<td style="text-align:left">text</td>
</tr>
<tr>
<td style="text-align:left">textarea</td>
<td style="text-align:left">top</td>
<td style="text-align:left">unescape</td>
<td style="text-align:left">untaint</td>
<td style="text-align:left">window</td>
</tr>
</tbody>
</table>
<p><strong>HTML 事件句柄</strong></p>
<p>应该避免使用 HTML 事件句柄的名称作为 Javascript 的变量及函数名。</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:left">onclick</td>
<td style="text-align:left">onerror</td>
<td style="text-align:left">onfocus</td>
</tr>
<tr>
<td style="text-align:left">onkeydown</td>
<td style="text-align:left">onkeypress</td>
<td style="text-align:left">onkeyup</td>
<td style="text-align:left">onmouseover</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">onmouseup</td>
<td style="text-align:left">onmousedown</td>
<td style="text-align:left">onsubmit</td>
</tr>
</tbody>
</table>
<p><strong>非标准 JavaScript</strong></p>
<p>除了保留关键字，在 JavaScript 实现中也有一些非标准的关键字。<br>一个实例是 <code>const</code> 关键字，用于定义变量。 一些 js 引擎把 <code>const</code> 当作 <code>var</code> 的同义词。另一些引擎则把 <code>const</code> 当作只读变量的定义。<br><code>const</code> 是 js 的扩展。js 引擎支持它用在 Firefox 和 Chrome 中。但是它并不是 JavaScript 标准 ES3 或 ES5 的组成部分。建议：不要使用它。</p>
<h2 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h2><ul>
<li>js 只有在缺少了分号就无法正确解析代码时才会自动填补分号。有两个例外：<ul>
<li>若 <code>return</code>、<code>break</code> 和 <code>continue</code> 后紧跟换行，js 会填补分号；</li>
<li>对于 <code>++</code> 和 <code>--</code> 运算符，若既可以解释为表达式前缀，又可以解释为后缀，js 会优先解释为前缀；</li>
</ul>
</li>
<li>通常以 <code>(</code>、<code>[</code>、<code>/</code>、<code>+</code>、<code>-</code> 开始的语句较有可能和前一条语句一起解析，保守起见可在此类语句前加分号，这样即使前一条语句结尾的分号被误删了，当前语句也能正常执行。</li>
</ul>
<h1 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h1><ul>
<li>基本类型：数字、字符串、布尔值、null、undefined。</li>
<li>除基本类型外都是对象类型。js 核心定义了五种类：Array、Function、Date、RegExp、Error。</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>采用 IEEE 754 标准定义的 64 位浮点格式，最大值 ±1.7976931348623157x10^308，最小值 ±5x10^-324。整数范围 -2^53~2^53，包含边界值。若超过此范围则无法保证低位的精度。</li>
<li><strong>Javascript 在实际操作时基于 32 位整数</strong>，这在操作大数时可能会出现意外的情况。</li>
<li>ECMAScript 标准不支持八进制数字，但某些 JavaScript 实现允许以数字 0 开始的八进制数字。在 ES6 的严格模式下，八进制直接量是明令禁止的。</li>
<li>数字表示方式：<code>[digits][.digits][(E|e)[+|-]digits]</code>。</li>
<li>数字溢出以 <code>Infinity</code> <code>-Infinity</code> 表示，基于它们的加减乘除结果还是无穷大。</li>
<li>数字下溢以 <code>0</code> <code>-0</code> 表示。</li>
<li>零除以零、无穷大除以无穷大、负数做开方、数字运算符与非数字或无法转换成数字的对象一起使用时，会返回 <code>NaN</code>。</li>
<li>ECMAScript 3 中 <code>Infinity</code> 和 <code>NaN</code> 是可读可写可修改的，ES5 中修复了这个 bug。</li>
<li>NaN 与任何值都不相等，包括自身。也就是说不能通过 <code>x==NaN</code> 来判断，而要通过 <code>x!=x</code> 来判断。或者使用 <code>isNaN()</code> 函数判断。</li>
<li>正负零值严格相等，除了它们作为除数时得到的结果。</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li>字符串是一组由 16 位值组成的不可变的有序序列，每个字符通常来自于 Unicode 字符集。</li>
<li>js 采用 UTF-16 编码，这意味着字符串的长度是其所含 16 位值的个数，而不是字面上的字符个数。</li>
<li>js 定义的字符串操作方法均作用于 16 位值，而非字符，且不会对代理项做单独处理。同样，js 不会对字符串做标准化加工，甚至不能保证字符串是合法的 UTF-16 格式。</li>
<li>js 中没有表示单个字符的“字符类型”。</li>
<li>在 ES3 中，字符串直接量必须写在一行中。在 ES5 中，可以将字符串拆分成数行，每行以 <code>\</code> 结束，<code>\</code> 和后面隐含的换行符都不算字符串直接量的组成部分。如果想换行，可以使用 <code>\n</code>。</li>
<li>若 <code>\</code> 后的字符不存在对应的转义字符，则会忽略 <code>\</code>，仍解释为该字符本身。</li>
<li>在 ES5 中，字符串可以当作只读数组，使用 charAt() 方法或方括号来访问其中的字符。以 Mozilla 为首的多数浏览器都在 ES5 之前就支持这种特性，除了 IE。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\o</code></td>
<td style="text-align:left">NUL 字符（\u0000）</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">退格符（\u0008）</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">水平制表符（\u0009）</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">换行符（\u000A）</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">垂直制表符（\u000B）</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">换页符（\u000C）</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">回车符（\u000D）</td>
</tr>
<tr>
<td style="text-align:left"><code>\&quot;</code></td>
<td style="text-align:left">双引号（\u0022）</td>
</tr>
<tr>
<td style="text-align:left"><code>\&#39;</code></td>
<td style="text-align:left">撇号或单引号（\u0027）</td>
</tr>
<tr>
<td style="text-align:left"><code>\\</code></td>
<td style="text-align:left">反斜线（\u005C）</td>
</tr>
<tr>
<td style="text-align:left"><code>\xXX</code></td>
<td style="text-align:left">由两位十六进制数指定的 Latin-1 字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\uXXXX</code></td>
<td style="text-align:left">由四位十六进制数制定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>任意 js 的值都可以转换为布尔值。</p>
<p>以下值会被转换为 false：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NaN</li>
<li>“”</li>
</ul>
<p>其他所有值（包括对象）都会被转换为 true。</p>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><ul>
<li>typeof(null) === “object”</li>
<li>typeof(undefined) === “undefined”</li>
<li>null == undefined –&gt; true</li>
<li>null === undefined –&gt; false</li>
</ul>
<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>当 js 解释器启动时，或浏览器加载新页面时，将创建一个新的全局对象，并给它一组定义的初始属性：</p>
<ul>
<li>全局属性，比如 undefined，Infinity，NaN</li>
<li>全局函数，比如 isNaN()，parseInt()，eval()</li>
<li>构造函数，比如 Date()，RegExp()，String()，Object()，Array()</li>
<li>全局对象，比如 Math，JSON</li>
</ul>
<p>全局对象的初始属性不是保留字，但应该当作保留字来对待。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">字符串</th>
<th style="text-align:left">数字</th>
<th style="text-align:left">布尔值</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">“undefined”</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">“null”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">“true”</td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">new Boolean(true)</td>
</tr>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">“false”</td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td style="text-align:left">new Boolean(false)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">“”</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">new String(“”)</td>
</tr>
<tr>
<td style="text-align:left">“1.2”</td>
<td style="text-align:left"></td>
<td style="text-align:left">1.2</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“1.2”)</td>
</tr>
<tr>
<td style="text-align:left">“one”</td>
<td style="text-align:left"></td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“one”)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(0)</td>
</tr>
<tr>
<td style="text-align:left">-0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(-0)</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">“NaN”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(NaN)</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">“Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(Infinity)</td>
</tr>
<tr>
<td style="text-align:left">-Infinity</td>
<td style="text-align:left">“-Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(-Infinity)</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">“1”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(1)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">{}任意对象</td>
<td style="text-align:left">#1</td>
<td style="text-align:left">#2</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[]任意数组</td>
<td style="text-align:left">“”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[9]1个数字元素</td>
<td style="text-align:left">“9”</td>
<td style="text-align:left">9</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[‘a’]其它数组</td>
<td style="text-align:left">使用join()方法</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">function(){}任意函数</td>
<td style="text-align:left">@</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
</tr>
</tbody>
</table>
<ol>
<li>对象 -&gt; 字符串：<ul>
<li>尝试 toString() 方法，若返回一个原始值，则转为字符串。</li>
<li>若无 toString() 方法，或返回的不是原始值，则调用 valueOf() 方法，若返回一个原始值，则转为字符串。</li>
<li>若无法通过以上两种方法获取原始值，则抛出类型异常。</li>
</ul>
</li>
<li>对象 -&gt; 数字：<ul>
<li>尝试 valueOf() 方法，若返回一个原始值，则转为数字。</li>
<li>否则，尝试 toString() 方法，将得到的字符串转为数字。</li>
<li>否则，抛出类型异常。</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li>一个值转换为另一个值并不意味两个值“相等”。比如在期望布尔值的地方使用了 undefined，它将会转换 false，但这并不表明 undefined == false。“==”运算符从不试图将其操作数转换为布尔值。</li>
<li>对于 Boolean()、Number()、String() 或 Object()，当不通过 new 调用这些函数时，它们会作为类型转换函数。</li>
<li>如果试图把 undefined 和 null 转换为对象，会抛出 TypeError，但用 Object() 显式转换不会抛异常，而是返回一个空对象。</li>
<li>数字转字符串的不同方法（3 个方法都会适当地四舍五入或填充 0）：<ul>
<li>toFixed()：指定小数点后的位数，从不使用指数记数法。</li>
<li>toExponential()：使用指数记数法，其中小数点前固定 1 位，小数点后位数由参数决定。</li>
<li>toPrecision()：指定有效数字的位数，若指定的有效数字位数小于整数部分位数，则转换成指数形式。</li>
</ul>
</li>
<li>使用 Number() 将字符串转换为数字直接量，只能基于十进制，且不能出现非法的尾随字符。</li>
<li>parseInt() 只解析整数，parseFloat() 可解析整数和浮点数。两者都会跳过任意数量的前导空格，并尽可能多地解析字符，并忽略后面无法解析的部分。若第一个非空字符即非数字，则返回 NaN。若字符串前缀为 0x 或 0X，则 parseInt() 将其解释为十六进制数。parseInt() 可接受第二个参数来指定基数，范围 2~36。</li>
</ul>
<h1 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h1><h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">结合性</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">++</td>
<td style="text-align:left">前/后增量</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→num</td>
</tr>
<tr>
<td style="text-align:left">–</td>
<td style="text-align:left">前/后增量</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→num</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">求反</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">num→num</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">转换为数字</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">num→num</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">按位求反</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">int→int</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">逻辑非</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">bool→bool</td>
</tr>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">删除属性</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→bool</td>
</tr>
<tr>
<td style="text-align:left">typeof</td>
<td style="text-align:left">检测操作数类型</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">any→str</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">返回 undefined 值</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">any→undef</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">*、/、%</td>
<td style="text-align:left">乘、除、取余</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→num</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">+、-</td>
<td style="text-align:left">加、减</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→num</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">字符串拼接</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,str→str</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左位移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left">>&gt;</td>
<td style="text-align:left">有符号右移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left">>&gt;&gt;</td>
<td style="text-align:left">无符号右移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&lt;、&lt;=、&gt;、&gt;=</td>
<td style="text-align:left">比较数字顺序</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→bool</td>
</tr>
<tr>
<td style="text-align:left">&lt;、&lt;=、&gt;、&gt;=</td>
<td style="text-align:left">比较在字母表中的顺序</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,str→bool</td>
</tr>
<tr>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">测试对象类</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">obj,func→bool</td>
</tr>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">测试属性是否存在</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,obj→bool</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">判断相等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">判断不等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">===</td>
<td style="text-align:left">判断恒等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">!==</td>
<td style="text-align:left">判断非恒等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">按位异或</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">按位或</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td>int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑与</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">逻辑或</td>
<td style="text-align:left">→</td>
<td>2</td>
<td>any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">?:</td>
<td style="text-align:left">条件运算符</td>
<td style="text-align:left">←</td>
<td style="text-align:left">3</td>
<td style="text-align:left">bool,any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">变量赋值或对象属性赋值</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">lval,any→any</td>
</tr>
<tr>
<td style="text-align:left">*=、/=、%=、+=、-=、&amp;=、^=、\</td>
<td style="text-align:left">=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td>
<td style="text-align:left">运算且赋值</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td>lval,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">,</td>
<td style="text-align:left">忽略第一个、返回第二个操作数</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→any</td>
</tr>
</tbody>
</table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>位运算符要求操作数是整数，并表示为 32 位整型而不是 64 位浮点型。必要时位运算符会先将操作数转换为数字并强制表示为 32 位整型，这会忽略小数部分和超过32位的二进制部分。</li>
<li>移位运算符要求右运算符在 0~31 之间。</li>
<li>位运算符会将 NaN、Infinity 和 -Infinity 都转换为 0。</li>
</ul>
<h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><ul>
<li>逻辑与（&amp;&amp;）和逻辑或（||）将所有操作数都当作真、假值来计算，并将其中某个操作数当作真、假值结果来返回。</li>
<li>考虑到逻辑表达式具有短路的性质，因此当计算到某个操作数就可以确定整个逻辑表达式的结果时，就不再继续计算，且将该操作数作为真、假值结果来返回。</li>
<li>逻辑非（!）运算符与 &amp;&amp; 和 || 不同，它不是将操作数当作真、假值，而是将操作数转换为布尔值然后取反。</li>
</ul>
<h2 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h2><p><strong>“+”运算符</strong></p>
<ul>
<li>若其中一个操作数为对象，则按照规则将其转换为原始类值。</li>
<li>转换之后，若其中一个操作数为字符串，则将另一个也转为字符串然后进行拼接。</li>
<li>否则，将两者都转为数字或 NaN，然后做加法。</li>
</ul>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p><strong>typeof</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">x</th>
<th style="text-align:left">typeof x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">“undefined”</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">true/flase</td>
<td style="text-align:left">“boolean”</td>
</tr>
<tr>
<td style="text-align:left">任意数字或 NaN</td>
<td style="text-align:left">“number”</td>
</tr>
<tr>
<td style="text-align:left">任意字符串</td>
<td style="text-align:left">“string”</td>
</tr>
<tr>
<td style="text-align:left">任意函数</td>
<td style="text-align:left">“function”</td>
</tr>
<tr>
<td style="text-align:left">任意内置对象（非函数）</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">任意宿主对象</td>
<td style="text-align:left">由编译器各自实现的字符串，但不是”undefined”、”boolean”、”number”或”string”</td>
</tr>
</tbody>
</table>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式是 ES5 的一个受限制的子集。与非严格模式的区别：</p>
<ul>
<li>禁止使用 with 语句。</li>
<li>如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将抛出一个引用错误异常。（在非严格模式中会给全局对象添加一个属性）</li>
<li>调用的函数（不是方法）中的 this 值是 undefined。（在非严格模式中是全局对象）。可以此判断是否支持严格模式：<code>var hasStrictMode = (function(){&quot;use strict&quot;; return this === undefined}());</code></li>
<li>当通过 <code>call()</code> 或 <code>apply()</code> 来调用函数时，其中的 this 值就是 <code>call()</code> 或 <code>apply()</code> 传入的第一个参数（在非严格模式中 null 和 undefined 值被全局对象和转换为对象的非对象值代替）。</li>
<li>给只读属性赋值和给不可扩展的对象创建成员都会抛出类型错误异常（非严格模式中只是失败，不会抛异常）。</li>
<li>传入 <code>eval()</code> 的代码不能在调用程序所在的上下文中声明变量或定义函数。变量和函数的定义是在 <code>eval()</code> 创建的新作用域中，这个作用域在 <code>eval()</code> 返回时弃用。</li>
<li>函数里的 arguments 对象拥有传入函数值的静态副本。在非严格模式中，两者是指向同一个值的引用。</li>
<li>当 delete 运算符后跟随非法标识符（变量、函数、函数参数）时，将抛出语法错误异常（在非严格模式中什么也不做，并返回 false）。</li>
<li>在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（非严格模式下不会报错）。</li>
<li>函数声明中存在两个或多个同名参数将产生一个语法错误（非严格模式下不会报错）。</li>
<li>不允许使用八进制整数直接量（以 0 为前缀）。</li>
<li>标识符 <code>eval</code> 和 <code>arguments</code> 当作关键字，它们的值不能修改，不能给它们赋值、声明为变量、用作函数名、用作函数参数或用作 catch 块的标识符。</li>
<li>限制了对调用栈的检测能力。在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。严格模式的函数同样具有 caller 和 arguments 属性，访问它们时会抛出类型错误异常（一些 js 实现在非严格模式里定义了这些非标准的属性）。</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><ul>
<li>属性名字里有空格或连字符的，必须用字符串表示。</li>
<li>ES5 和部分 ES3 的实现中，保留字可以用作不带引号的属性名。保险起见，属性名字是保留字的，要用字符串表示。</li>
<li>ES5 中，对象直接量中最后一个属性后的逗号会被忽略。在 ES3 的大部分实现中也会忽略，除了 IE。</li>
</ul>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>ES5 中定义了 Object.create() 方法，第一个参数是这个对象的原型，第二个可选参数用以对对象的属性进行描述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);<span class="comment">//创建的对象没有原型，也就是没有任何基础方法，比如 toString() 之类的</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><h3 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h3><p>设置属性会失败的场景：</p>
<ul>
<li>o 中的属性 p 是只读的：不能给只读属性重新赋值（<code>defineProperty()</code> 方法中有一个例外，可以对可配置的只读属性重新赋值）。</li>
<li>o 中的属性 p 是继承属性，且是只读的：不能通过同名自有属性覆盖只读的继承属性。</li>
<li>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性是 false。如果 o 中不存在 p，且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。</li>
</ul>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><ul>
<li><code>&quot;x&quot; in o</code>：包括自有属性和继承属性。</li>
<li><code>o.hasOwnProperty(&quot;x&quot;)</code>：包括自有属性。</li>
<li><code>o.propertyIsEnumerable(&quot;x&quot;)</code>：包括自有属性，且属性是可枚举的。</li>
<li><code>o.x !== undefined</code>：同 <code>in</code>，但不能区分赋值为 undefined 的属性。</li>
<li><code>o.x != null</code>：不区分 null 和 undefined。</li>
</ul>
<h2 id="属性-getter-和-setter"><a href="#属性-getter-和-setter" class="headerlink" title="属性 getter 和 setter"></a>属性 getter 和 setter</h2><p>在 ES5 中，属性值可以由 getter 和 setter 方法来代替，这种属性称为“存取器属性”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  $n = <span class="number">0</span>; <span class="comment">// $ 暗示是私有属性</span></span><br><span class="line">  get next() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$n++;</span><br><span class="line">  &#125;</span><br><span class="line">  set next(n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="keyword">this</span>.$n) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$n = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"blabla"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>属性的 4 个特性：值 value、可写性 writable、可枚举性 enumerable、可配置性 configurable。<br>存取器属性没有值和可写性，取而代之的是读取 get、写入 set。</p>
<p>ES3 中无法配置这些特性，ES5 中定义了一个“属性描述符”的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;value: 1, writable:true, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;get:[Function: get x], set:undefined, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;get x()&#123;&#125;&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在的属性和继承属性</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"x"</span>);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"toString"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建或修改属性的特性</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> pd = &#123;<span class="attr">value</span>:<span class="number">1</span>, <span class="attr">writable</span>:<span class="literal">true</span>, <span class="attr">enumerble</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, pd);<span class="comment">//创建属性并定义特性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">writable</span>:<span class="literal">false</span>&#125;);<span class="comment">//修改特性</span></span><br><span class="line"><span class="comment">//多个属性的特性，返回修改后的对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  x: &#123;<span class="attr">value</span>:<span class="number">1</span>, <span class="comment">/*...*/</span>&#125;,</span><br><span class="line">  y: &#123;<span class="attr">value</span>:<span class="number">2</span>, <span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>任何对 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 违反规则的使用都会抛出类型错误异常：</p>
<ul>
<li>若对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。</li>
<li>若属性是不可配置的，则不能修改它的可配置性和可枚举性。</li>
<li>若存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。</li>
<li>若数据属性是不可配置的，则不能将它转换为存取器属性。</li>
<li>若数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 改为 false。</li>
<li>若数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写，然后修改值，最后转换为不可写）。</li>
</ul>
<h2 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h2><p>原型、类、可扩展性</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>通过对象直接量创建：Object.prototype。</li>
<li>通过 new 构造函数创建：构造函数的 prototype。</li>
<li>通过 <code>Object.create()</code> 创建：使用第一个参数，可以是 null。</li>
</ul>
<p>在 ES5 中，通过 <code>Object.getPrototypeOf()</code> 查询对象的原型。在 ES3 中没有对应的函数，可以通过 <code>o.constructor.prototype</code> 来查询原型，但这种方式并不可靠。</p>
<p>通过对象直接量创建的对象和通过 <code>Object.create()</code> 创建的对象都含有 constructor 属性，它们的这个属性都指向构造函数 <code>Object()</code>。但只有对象直接量创建的对象的原型是 <code>Object()</code> 函数的 prototype 属性，而 <code>Object.create()</code> 创建的对象往往不是。</p>
<p>要检测 a 对象是否是 b 对象的原型（或在原型链上），应使用 <code>b.isPrototypeOf(a)</code>。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>可扩展性表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的。</p>
<ul>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.preventExtensions()</code>：转为不可扩展，然后就无法转回可扩展了。只影响对象本身，依然可以给原型添加属性，此对象仍会继承添加的属性。</li>
<li><code>Object.seal()</code>：将对象设置为不可扩展，且所有自有属性都不可配置。已封闭的对象不能解封，可用 <code>Object.isSealed()</code> 来检测。</li>
<li><code>Object.freeze()</code>：在 seal 的基础上，还将所有自有数据属性置为只读（若存取器属性有 setter 方法则仍能赋值）。可用 <code>Object.isFrozen()</code> 来检测。</li>
</ul>
<h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p><code>JSON.stringify()</code> 和 <code>JSON.parse()</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>判断数组中的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a[i]); <span class="comment">// null、undefined 和不存在的元素</span></span><br><span class="line"><span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>); <span class="comment">// undefined 和不存在的元素</span></span><br><span class="line"><span class="keyword">if</span> (!(i <span class="keyword">in</span> a)); <span class="comment">// 不存在的元素</span></span><br></pre></td></tr></table></figure>
<p>由于 for/in 循环会枚举继承的属性，所以对于数组要么不用 for/in 循环，要么手动判断继承的属性。</p>
<p>for/in 循环的遍历顺序不能确定，可以改用传统的 for 循环，或用 ES5 中新增的 forEach() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//operations on the element</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>拼接数组元素，默认使用逗号，也可以自定义连接符。是 string.split() 的逆向操作。</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转排列。在原数组中反转，而不是新建一个数组。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>默认按字母表顺序排序，必要时会把元素临时转为字符串进行比较。undefined 元素会被排到末尾。</p>
<p>可传入比较函数，若第一个参数应排在前面，则函数应返回小于 0 的数值。</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>返回一个<strong>新数组</strong>，其中包含原有的元素和所有入参。若参数是数组，则添加的是其中的每个元素，而不是将该数组整个作为一个元素。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>返回一个<strong>新数组</strong>，该数组是原数组的一部分。</p>
<ul>
<li>两个入参：两个索引，子数组包含了第一个索引的元素到第二个索引前面一个元素。</li>
<li>一个入参：入参表示开始位置，结束位置固定为数组末尾。</li>
<li>入参为负数：表示相对于 0 索引的位置。</li>
</ul>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>对<strong>原数组</strong>进行删除和插入操作。被操作的元素后面的元素会自动调整位置。返回结果是一个数组，包含了被删除的元素，可能为空数组。</p>
<ul>
<li>第一个参数：删除和插入的起始位置。</li>
<li>第二个参数：删除的元素个数。</li>
<li>第三个开始的所有参数：要插入的元素，若参数为数组，则这个数组本身作为一个元素（这一点与 <code>concat()</code> 不同）。</li>
</ul>
<h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push 和 pop"></a>push 和 pop</h3><p>在<strong>原数组</strong>的末尾插入和弹出元素。若插入的是数组，则数组本身作为一个元素。</p>
<p><code>push()</code> 返回插入后的数组长度。<code>pop()</code> 返回弹出的元素。</p>
<h3 id="unshift-和-shift"><a href="#unshift-和-shift" class="headerlink" title="unshift 和 shift"></a>unshift 和 shift</h3><p>在<strong>原数组</strong>的开始插入和弹出元素。若插入的是数组，则数组本身作为一个元素。</p>
<p><code>unshift()</code> 返回插入后的数组长度。<code>shift()</code> 返回弹出的元素。</p>
<p>同时插入多个元素时会一次性插入，而不是一个个插入，也就是说插入后的元素顺序跟参数里的顺序一致。</p>
<h2 id="ES5-中的数组方法"><a href="#ES5-中的数组方法" class="headerlink" title="ES5 中的数组方法"></a>ES5 中的数组方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach()</code> 方法的第一个参数是一个函数。该函数有 3 个参数，依次为：数组元素、元素的索引、数组本身。</p>
<p><code>forEach()</code> 方法只能通过在函数中抛出 <code>foreach.break</code> 异常来提前中断。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>传入一个映射函数，对每个元素做映射，然后返回一个包含新元素的新数组。</p>
<p>若原数组是稀疏数组，则新数组也是稀疏数组，缺失的元素一样。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>传入一个判断函数，该函数返回 true/false，通过判断的元素会被放入新数组中。</p>
<p>稀疏数组中缺失的元素会被跳过，即返回的数组总是稠密的。</p>
<h3 id="every-和-some"><a href="#every-和-some" class="headerlink" title="every 和 some"></a>every 和 some</h3><p>传入一个判断函数，该函数返回 true/false，对所有元素应用该函数。</p>
<ul>
<li>every：仅当所有元素都通过判断时才返回 true。</li>
<li>some：当至少有一个元素通过判断时就返回 true。</li>
</ul>
<p>一旦确认返回值就会直接返回。根据数学上的惯例，对于空数组，every 返回 true，some 返回 false。</p>
<h3 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce 和 reduceRight"></a>reduce 和 reduceRight</h3><p>传入的第一个参数是一个组合函数，对数组内的元素进行组合，最终返回一个组合后的值。第二个参数是初始值，缺省为第一个元素。</p>
<p>reduce 是按照索引从低到高，reduceRight 则相反。</p>
<h3 id="indexOf-和-lasIndexOf"><a href="#indexOf-和-lasIndexOf" class="headerlink" title="indexOf 和 lasIndexOf"></a>indexOf 和 lasIndexOf</h3><p>在数组中查找指定元素，返回找到的第一个元素的索引，若未找到则返回 -1。</p>
<p>第二个参数是可选的，它指定开始搜索的位置。</p>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>ES5 中可以使用 <code>Array.isArray()</code> 来判断对象是否为数组。ES3 要自行判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">"[object Aray]"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p><strong>函数声明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function funcName(params) &#123;/*code*/&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = function(a, b) &#123;return a * b&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);</span><br></pre></td></tr></table></figure>
<p>但一般不使用构造函数。</p>
<p><strong>函数提升（Hoisting）</strong></p>
<p>“提升”是 JavaScript 默认将当前作用域提升到前面去的行为。<br>“提升”应用在变量的声明与函数的声明，但不应用于变量和函数的赋值。<br>因此，函数可以在声明之前调用。<br>“提升”是在 js 引擎预编译的时候进行的，即运行前。</p>
<p><strong>函数是对象</strong></p>
<p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” 。<br>但是 JavaScript 函数描述为一个对象更加准确。<br>JavaScript 函数有 属性 和 方法。<br>arguments.length 属性返回函数调用过程接收到的参数个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return arguments.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>toString()</code> 方法将函数作为一个字符串返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">var txt = myFunction.toString();</span><br></pre></td></tr></table></figure>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>有 4 种方式来调用 JavaScript 函数：</p>
<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过函数的 <code>call()</code> 和 <code>apply()</code> 方法间接调用</li>
</ul>
<h3 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h3><p>根据 ECMAScript 3 和非严格的 ECMAScript 5 对函数调用的规定，调用上下文 this 的值是全局对象。而在严格模式下调用上下文则是 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前是否为严格模式</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span>; &#125;());</span><br></pre></td></tr></table></figure>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用的上下文是包含方法的那个对象。</p>
<p>嵌套函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套函数作为函数调用，其 this 的值要么是全局对象（非严格模式）要么是 undefined （严格模式）。</p>
<p>若内部函数想访问外层函数的 this，则要在外层函数中把 this 赋给一个变量（通常为 self），然后内部函数访问这个变量。</p>
<h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>如果函数或方法调用之前带有关键字 new，就构成构造函数调用。</p>
<p>没有形参的构造函数调用可以省略括号。</p>
<p>构造函数调用新对象，该对象继承自构造函数的 prototype 属性。</p>
<p>构造函数中的 this 指向它新创建的对象，而不是调用构造函数的对象。比如 <code>new o.m()</code> 中，this 指向的不是 o。</p>
<h3 id="即调函数-IIFE"><a href="#即调函数-IIFE" class="headerlink" title="即调函数 IIFE"></a>即调函数 IIFE</h3><blockquote>
<p>Immediately-Invoked Function Expression</p>
</blockquote>
<p><strong>为什么需要 IIFE</strong></p>
<p>由于 js 在作用域方面比较薄弱，只有全局作用域和方法作用域，直到 ES6 才有块作用域，所以只能通过将逻辑封装到函数声明中来实现作用域隔离。</p>
<p>很多时候，我们需要执行一段逻辑，而这段逻辑很可能只需要执行一次，那么让这段逻辑的方法名和里面变量名去占用全局的命名空间就很不划算，这时候就需要使用 IIFE。</p>
<p>函数表达式可以 “自调用”。<br>自调用表达式会自动调用。<br>如果表达式后面紧跟 <code>()</code> ，则会自动调用。<br>不能自调用声明的函数。<br>通过添加括号，来说明它是一个函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var x = &quot;Hello!!&quot;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">//实际上只要想办法把函数声明转换成表达式就行</span><br><span class="line">(function() &#123;</span><br><span class="line">    var x = &quot;Hello!&quot;;</span><br><span class="line">&#125;());</span><br><span class="line">//再比如</span><br><span class="line">!function() &#123;</span><br><span class="line">    var x = &quot;Hello!&quot;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>虽然各种把函数声明转换成表达式的方式都能生效，但是性能会有差别。</p>
<p>js 引擎为了提升执行速度，在函数声明的时候只会做简单的语法分析，然后在函数执行的时候再做进一步的处理。对于自调函数显然应该直接做完整的处理。然而由于 js 引擎是通过符号特征来识别自调函数的（比如 <code>(function</code>），而有些引擎漏掉了一些不常见的特征，从而导致使用这些语法把函数声明转换成表达式的时候引擎不会把它当成自调函数来做优化，因而影响性能。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p><strong>函数显式参数(Parameters)与隐式参数(Arguments)</strong></p>
<blockquote>
<p>显示参数在函数定义时给出，相当于形参。<br>隐式参数在函数调用时传递，相当于实参。</p>
</blockquote>
<p><strong>参数规则</strong></p>
<p>JavaScript 函数定义时显式参数没有指定数据类型。<br>JavaScript 函数对隐式参数没有进行类型检测。<br>JavaScript 函数对隐式参数的个数没有进行检测。</p>
<h3 id="实参对象"><a href="#实参对象" class="headerlink" title="实参对象"></a>实参对象</h3><p>实参对象 <code>arguments</code> 不是一个数组，而是一个对象，只是它的属性碰巧是以数字为索引。</p>
<p>在非严格模式下，<code>arguments</code> 中的属性和对应的实参指向的是同一个对象，即修改时两处会同时改变。（ES5 中移除了此特性）</p>
<p><strong>callee 和 caller 属性</strong></p>
<p>实参对象还定义了 <code>callee</code> 和 <code>caller</code> 属性。</p>
<p>在 ECMAScript 5 严格模式下，对这两个属性读写会产生类型错误。在非严格模式下，ES 规范规定 <code>callee</code> 属性指代当前正在执行的函数，而 <code>caller</code> 是非标准的，大多数浏览器实现这个属性指代调用当前执行函数的那个函数。</p>
<h2 id="函数属性、方法和构造函数"><a href="#函数属性、方法和构造函数" class="headerlink" title="函数属性、方法和构造函数"></a>函数属性、方法和构造函数</h2><h3 id="call-方法和-apply-方法"><a href="#call-方法和-apply-方法" class="headerlink" title="call() 方法和 apply() 方法"></a>call() 方法和 apply() 方法</h3><p>第一个参数作为方法中 <code>this</code> 的值，后面的参数作为方法的实参。</p>
<p>在 ES5 的严格模式中，第一个参数即使是原始类型或者 null 或者 undefined 也会作为 <code>this</code> 的值。在 ES3 和非严格模式中，原始类型会被包装对象替代，null 和 undefined 会被全局对象替代。</p>
<p>call() 从第二个参数开始依次作为函数的实参。apply() 将函数的所有实参放入一个数组中作为第二个参数。</p>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h3><p>bind() 方法的第 1 个参数是一个对象，它会被作为被绑定方法的 this。从第 2 个参数开始是可选的，它们依次绑定到被绑定方法的入参上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y + <span class="keyword">this</span>.z; &#125;;</span><br><span class="line"><span class="keyword">var</span> newSum = sum.bind(&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = newSum(<span class="number">2</span>);<span class="comment">// x=1,y=2,z=3</span></span><br></pre></td></tr></table></figure>
<p>通常被用来实现科里化。</p>
<h1 id="类和模块"><a href="#类和模块" class="headerlink" title="类和模块"></a>类和模块</h1><h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><p>构造函数的 prototype 属性被用作新对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数首字母大写，这是编程约定而不是语法限制。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">  <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">  includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rangeObj = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和类的标识"><a href="#构造函数和类的标识" class="headerlink" title="构造函数和类的标识"></a>构造函数和类的标识</h3><p>两个对象是否为同一个类的实例，取决于它们的 prototype 是否指向同一个对象，而不是取决于它们是否从同一个构造函数创建的。</p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>因为任何函数都可以作为构造函数，而调用构造函数是需要用到 prototype 属性的，所以每个函数（除 ES5 中的 <code>Function.bind()</code>）都自动拥有一个 prototype 属性。该属性包含唯一一个不可枚举属性 constructor，它的值是一个函数对象。</p>
<p>像上述那样显式定义 Range.prototype 的话就不存在 constructor 属性了，需要显式定义。</p>
<p>另一种方式是在预设的 prototype 上添加方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.includes = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">Range.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Javascript-中的-Java-式类继承"><a href="#Javascript-中的-Java-式类继承" class="headerlink" title="Javascript 中的 Java 式类继承"></a>Javascript 中的 Java 式类继承</h2><ul>
<li>构造函数对象：构造函数为类定义了名字。任何添加到构造函数对象中的属性都是类属性或类方法。</li>
<li>原型对象：原型对象的属性被类的所有实例继承。</li>
<li>实例对象：添加到实例对象中的属性是该对象独享的。</li>
</ul>
<h2 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 右边的参数是构造函数，但计算过程实际上是检测了对象的原型继承关系，而不是创建对象的构造函数。</p>
<p>也可以不用构造函数，而直接用对象来判断继承关系：<code>examplePrototype.isPrototypeOf(obj)</code>。</p>
<p>这两种方法的缺点是：</p>
<ul>
<li>只能检测对象是否属于某个类，而不能在类未知的情况下通过对象获取类名。</li>
<li>在 Web 客户端中，每个窗口和框架子页面都有独立的上下文，概念上相同的类/对象在不同上下文中都是独立的。</li>
</ul>
<h3 id="构造函数的名称"><a href="#构造函数的名称" class="headerlink" title="构造函数的名称"></a>构造函数的名称</h3><p>为解决不同上下文中的类型检测问题，可以通过构造函数名称来区分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t, c, n; <span class="comment">// type, class, name</span></span><br><span class="line">  <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">  <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">"NaN"</span></span><br><span class="line">  <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">"object"</span>) <span class="keyword">return</span> t; <span class="comment">// 原始值的类型和函数</span></span><br><span class="line">  <span class="keyword">if</span> ((c = classof(o) !== <span class="string">"Object"</span>) <span class="keyword">return</span> c; <span class="comment">// 可以识别出大多数的内置对象</span></span><br><span class="line">  <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">"function"</span> &amp;&amp; (n = o.constructor.getName())) <span class="keyword">return</span> n; <span class="comment">// 若构造函数名字存在的话</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Object"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字（可能是空字符串），不是函数的话返回 null</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*)\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的问题在于，不是所有对象都有 constructor 属性，也不是所有函数都有名字，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个构造函数没名字</span></span><br><span class="line"><span class="keyword">var</span> Complex = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> Range = <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">f, t</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="鸭式辩型"><a href="#鸭式辩型" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h3><blockquote>
<p>不要关注“对象的类是什么”，而是关注“对象能做什么”。</p>
</blockquote>
<h2 id="Javascript-中的面向对象技术"><a href="#Javascript-中的面向对象技术" class="headerlink" title="Javascript 中的面向对象技术"></a>Javascript 中的面向对象技术</h2><h3 id="标准转换方法"><a href="#标准转换方法" class="headerlink" title="标准转换方法"></a>标准转换方法</h3><ul>
<li>toString：在希望使用字符串的地方（比如将对象用作属性名或用“+”拼接字符串），JavaScript 会自动调用此方法。</li>
<li>toLocaleString：默认情况下 toLocalString 方法只是简单的调用了 toString 方法。</li>
<li>valueOf：用来将对象转换为原始值。比如当数字运算符（除了“+”）和关系运算符作用于数字文本表示的对象时，会自动调用 valueOf。</li>
<li>toJSON：由 JSON.stringify() 自动调用，用来进行对象序列化。</li>
</ul>
<h3 id="私有状态"><a href="#私有状态" class="headerlink" title="私有状态"></a>私有状态</h3><p>通过将变量（或参数）闭包在一个构造函数内来模拟私有实例字段。但是这样会降低运行速度、占用更多内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funtion Range(<span class="keyword">from</span>, to) &#123;</span><br><span class="line">  <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;;</span><br><span class="line">  <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式的模式匹配"><a href="#正则表达式的模式匹配" class="headerlink" title="正则表达式的模式匹配"></a>正则表达式的模式匹配</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>一些 Perl 正则语法不被 ECMAScript 支持：</p>
<ul>
<li>s（单行模式）和 x（扩展语法）标记。</li>
<li>\a、\e、\l、\u、\L、\U、\E、\Q、\A、\Z、\z、\G 转义字符。</li>
<li><code>(?&lt;=</code> 正向后行断言、<code>(?&lt;!</code> 负向后行断言。</li>
<li><code>(?#</code> 注释和扩展 <code>(?</code> 的语法。</li>
</ul>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>i：不区分大小写。</li>
<li>g：全局匹配。</li>
<li>m：多行匹配。<code>^</code> 匹配字符串开头和换行后的开头，<code>$</code> 同理。</li>
</ul>
<h2 id="用于模式匹配的-String-方法"><a href="#用于模式匹配的-String-方法" class="headerlink" title="用于模式匹配的 String 方法"></a>用于模式匹配的 String 方法</h2><p><code>&quot;abc&quot;.search(/ab/);</code></p>
<p>传入正则表达式（若不是则自动通过 RegExp 构造函数转换），返回 -1（匹配不到）或匹配结果的首字符的索引。不支持全局搜索（即使使用修饰符 g）。</p>
<p><code>&quot;abc&quot;.replace(/ab/, &quot;cd&quot;);</code></p>
<p>传入两个参数。第一个参数是正则表达式（若不是则自动通过 RegExp 构造函数转换），第二个参数是要替换的字符串或是用来计算字符串的函数。第二个参数中可以通过 <code>$</code> 加数字来引用分组。</p>
<p><code>&quot;abc&quot;.match(/ab/);</code></p>
<p>传入正则表达式（若不是则自动通过 RegExp 构造函数转换），返回由匹配结果组成的数组。需要在表达式中使用修饰符 g 来获取全部匹配结果。若是全局匹配，则结果数组包含了所有匹配。若不是全局匹配，则 a[0] 是完整的匹配，a[1] 开始的元素依次是每个分组的匹配。</p>
<p><code>&quot;abc&quot;.split(/a/);</code></p>
<p>入参可以是字符串或正则表达式。返回分割之后的数组。</p>
<h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p>构造函数接受一个必选参数，一个可选参数。</p>
<p>必选参数是字符串形式的正则表达式。可选参数是字符串形式的修饰符。</p>
<h3 id="RegExp-的属性"><a href="#RegExp-的属性" class="headerlink" title="RegExp 的属性"></a>RegExp 的属性</h3><ul>
<li>source：只读的字符串，包含正则表达式的文本。</li>
<li>global：只读的布尔值，说明是否带有修饰符 g。</li>
<li>ignoreCase：只读的布尔值，说明是否带有修饰符 i。</li>
<li>multiline：只读的布尔值，说明是否带有修饰符 m。</li>
<li>lastIndex：可读/写的整数，如果带有修饰符 g，则这个属性存储在整个字符串中下次检索的开始位置。</li>
</ul>
<h3 id="RegExp-的方法"><a href="#RegExp-的方法" class="headerlink" title="RegExp 的方法"></a>RegExp 的方法</h3><p><strong>exec()</strong></p>
<p>传入一个字符串。如果没有匹配，则返回 null；如果有一个匹配，则返回一个数组，a[0] 是匹配结果，a[1] 开始依次是分组匹配，index 属性包含了发生匹配的字符位置，input 属性包含了正在检索的字符串。跟 <code>String.match()</code> 不同，不管有没有修饰符 g，都会返回一样的数组。</p>
<p>若带有修饰符 g，则可以反复调用此方法来尝试获得多个匹配。此方法会通过设置正则表达式的 lastIndex 属性来实现此功能。</p>
<p><strong>test()</strong></p>
<p>和 <code>exec()</code> 等价，当 <code>exec()</code> 返回不是 null 时，此方法返回 true。如带有修饰符 g，则也可以反复调用此方法来尝试进行多次匹配。</p>
<p><strong>与 String 的方法的区别</strong></p>
<p>String 的 <code>search()</code>、<code>replace()</code>、<code>match()</code> 方法不会用到 lastIndex 属性，它们只是简单地将该属性置为 0。如果让一个全局正则表达式对多个字符串执行 <code>exec()</code> 和 <code>test()</code> 方法，要么找出所有匹配以便将 lastIndex 属性置为 0，要么手动进行设置，否则会影响后续匹配的起始位置。</p>
<h1 id="JavaScript-的子集和扩展"><a href="#JavaScript-的子集和扩展" class="headerlink" title="JavaScript 的子集和扩展"></a>JavaScript 的子集和扩展</h1><h2 id="JavaScript-的子集"><a href="#JavaScript-的子集" class="headerlink" title="JavaScript 的子集"></a>JavaScript 的子集</h2><h3 id="子集的安全性"><a href="#子集的安全性" class="headerlink" title="子集的安全性"></a>子集的安全性</h3><p>为了让 js 代码静态地通过安全检查，必须移除一些特性：</p>
<ul>
<li><code>eval()</code> 和 <code>Function()</code> 构造函数在任何安全子集里都是禁止的，因为它们可以执行任意代码，无法对这些代码做静态分析。</li>
<li>禁止使用 <code>this</code>，因为在非严格模式中，函数可以通过 <code>this</code> 访问全局对象。而沙箱系统的一个重要目标就是禁止对全局对象的访问。</li>
<li>禁止使用 <code>with</code>，因为会增加静态代码检查的难度。</li>
<li>禁止使用某些全局变量。<code>window</code> 和 <code>document</code> 对象可以操作浏览器和页面，因而存在隐患。一种方法是完全禁用这些全局对象，提供自定义的一组 API 来进行有限制的操作。另一种方法是在沙箱代码运行的“容器”内定义一个只对外提供安全的标准 DOM API 的 facade 或 proxy。</li>
<li>禁止使用某些属性和方法，以免沙箱中的代码拥有过多权限。包括 <code>arguments</code> 的 <code>caller</code> 和 <code>callee</code> 属性（甚至是 <code>arguments</code> 本身）、函数的 <code>call()</code> 和 <code>apply()</code>，以及 <code>constructor</code> 和 <code>prototype</code> 属性。</li>
<li>相对于 <code>.</code> 运算符访问属性而言，<code>[]</code> 中的字符串表达式无法做静态分析。因此，安全子集通常禁止使用方括号，除非里面是数字或字符串直接量。安全子集将 <code>[]</code> 替换为全局函数，这些全局函数在存取属性之前会执行运行时检查以确保不会读写那些禁止访问的属性。</li>
</ul>
<p>一些比较重要的安全子集实现：</p>
<ul>
<li>ADsafe：只包含静态检查，使用 JSLint 作为检验器。禁止访问大部分全局变量，并定义了一个 <code>ADSAFE</code> 变量，提供了一组安全的 API，包括一些特殊的 DOM 方法。</li>
<li>dojox.secure：基于静态检查，静态检查受限于子集范围内。使用标准 DOM API。同时，它包含一个用 JavaScript 实现的检查器。</li>
<li>Caja：它定义了两个语言子集。Cajita （小沙盒）是一个与 ADsafe 和 dojox.secure 相似的严格子集。Valija (手提箱或行李箱）范围更广，接近 ECMAScript 5 的严格模式（不含 eval()）。Caja 本身也是一个编译器的名字，可以将一段网页内容转换为一个安全的模块</li>
<li>FBJS：它是 JavaScript 的变种，依赖代码转换来保证代码的安全性，转换器同时提供运行时检查，以避免通过 <code>this</code> 访问全局对象，并对所有顶层标识符重命名，给它们增加了一个标识模块的前缀。因为这种重命名，任何对全局变量和其他模块的变量的操作都无法进行。FBJS 模拟实现了 DOM API 的一个安全子集。</li>
<li>Microsoft Web Sandbox：定义了 JavaScript 的一个更宽泛的子集，包含 HTML 和 CSS，它的代码重写规则非常激进，有效地重新实现了一个安全的 JavaScript 虚拟机，针对不安全的 js 顶层代码进行处理。</li>
</ul>
<h2 id="常量和局部变量"><a href="#常量和局部变量" class="headerlink" title="常量和局部变量"></a>常量和局部变量</h2><p>在 js 1.5 及以后版本中可以用 <code>const</code> 定义常量。对常量重新赋值会失败但不会报错，重新声明会报错。常量会被提升至函数顶部。<code>const</code> 是 js 保留字，所以无需加入版本号。</p>
<p><code>const</code> 类似 Java 中的 <code>final</code>，只能保证引用不被修改，不保证引用的对象内部不被修改。</p>
<p>js 1.7 针对没有块级作用域的缺陷增加了 <code>let</code> 关键字，由于不是保留字，所以需要手动加入版本号。</p>
<p>这里的版本号指的是 Mozilla 的语言版本。在 Spidermonkey 和 Rhino 解析器和 Firefox Web 浏览器中实现了这些语言版本。</p>
<p>在 Spidermonkey 或 Rhino 中，可以通过命令行选项指定版本，或通过一个内置函数 <code>version()</code> 指定。指定的版本号是实际版本号乘以 100。在 Firefox 中，可以在 script 标签中指定版本：<code>&lt;script type=&quot;application/javascript; version=1.8&quot;&gt;</code>。</p>
<p><code>let</code> 4 种使用方式：</p>
<ul>
<li>作为变量声明，和 <code>var</code> 一样。</li>
<li>在 for 循环种，作为 <code>var</code> 的替代方案。</li>
<li>在语句块中定义一个新变量并显式指定它的作用域。</li>
<li>定义一个在表达式内部作用域中的变量，只在表达式内可用。</li>
</ul>
<p>其中第 4 种用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let 语句块</span></span><br><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> (x=x+<span class="number">1</span>, y=x+<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y); <span class="comment">//5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x+y);   <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let 表达式</span></span><br><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">let</span>(x=x+<span class="number">1</span>, y=x+<span class="number">2</span>) x+y);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 语句中的变量初始化表达式不是语句块的一部分，并且是在作用域外部解析的。</p>
<p>在 ES6 之前，全局变量会自动挂构成顶层对象（比如浏览器中的 window）的属性，反之亦然。ES6 规定，<code>let</code>、<code>const</code>、<code>class</code> 声明的变量不属于顶层对象的属性。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>Spidermonkey 1.7 实现了一种混合式赋值，即“解构赋值”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// let x=1, y=2</span></span><br><span class="line"><span class="keyword">let</span> [,x,,y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// let x=2, y=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构赋值运算的返回值是右侧的整个数据结构，而不是提取出来的某个值</span></span><br><span class="line"><span class="keyword">let</span> a, b, all;</span><br><span class="line">all = [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a=1, b=2, all=[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于数组嵌套的情况，左侧应当是同样格式的嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> [a, [b, c]] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]; <span class="comment">// a=1, b=2, c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:a, <span class="attr">age</span>:b&#125; = &#123;<span class="attr">name</span>: <span class="string">"tom"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>(a + <span class="string">" "</span> + b); <span class="comment">// tom 18</span></span><br></pre></td></tr></table></figure>
<p>左侧多余的变量赋值为 undefined，右侧多余的变量被忽略。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for/each 循环"></a>for/each 循环</h3><p>for/each 循环是由 E4X 规范（ECMAScript for XML）定义的一种新的循环语句。遍历范围包含继承来的可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> each (<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> each (<span class="keyword">let</span> p <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器必须包含 <code>next()</code> 方法，返回集合中的下一个值。</li>
<li>当没有下一个值时，会抛出 <code>StopIteration</code>。它是 JavaScript 1.7 中的全局对象的属性。</li>
</ul>
<p>一般不直接用迭代器，而是用可迭代对象。</p>
<ul>
<li>可迭代对象必须包含 <code>_iterator_()</code> 方法，该方法返回一个迭代器。</li>
<li>JavaScript 1.7 的 for/in 循环会自动调用 <code>_iterator_()</code> 方法，并处理 StopIteration 异常。</li>
</ul>
<p>JavaScript 1.7 中有一个全局函数 <code>Iterator()</code>。</p>
<ul>
<li><code>Iterator()</code> 会自动调用参数的 <code>_iterator_()</code>，并返回该迭代器。</li>
<li>若参数没有 <code>_iterator_()</code> 方法，则会返回参数的一个自定义迭代器。该迭代器每次返回一个包含两个值的数组，第一个元素是属性名，第二个是对应的值。<ul>
<li>该迭代器只对自有属性进行遍历，忽略继承属性。</li>
<li>如果传入 <code>Iterator()</code> 的第二个参数是 true，返回的迭代器只对属性名进行遍历，忽略属性值。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">in</span> Iterator(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k + <span class="string">"="</span> + v); <span class="comment">// a=1 b=2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是 JavaScript 1.7 中的特性。</p>
<p>任何使用关键字 <code>yield</code> 的函数（哪怕不可达）都称为生成器函数。生成器函数通过 <code>yield</code> 返回值，通过 <code>return</code> 来终止函数而不带返回值。对生成器函数的调用不是执行函数体本身，而是返回一个生成器对象。</p>
<p>生成器是一个迭代器对象，表示生成器函数当前的执行状态。它有几个方法：</p>
<ul>
<li><code>next()</code>：该方法可恢复生成器函数的执行，直到下一条 <code>yield</code> 语句，<code>yield</code> 的返回值就是 <code>next()</code> 的返回值，而 <code>return</code> 会使 <code>next()</code> 抛出一个 <code>StopIteration</code>。</li>
<li><code>close()</code>：用来释放生成器对象，相当于在挂起位置执行了 <code>return</code>。</li>
<li><code>send()</code>：<code>yield</code> 是一个表达式而不是语句，也就是说它是可以有值的。<code>send()</code> 和 <code>next()</code> 一样继续执行生成器，不同的是它可以传入一个参数作为 <code>yield</code> 表达式的值。</li>
<li><code>throw()</code>：继续执行生成器，可以传入一个参数，<code>yield</code> 表达式会将该参数作为异常抛出。</li>
</ul>
<h3 id="数组推导"><a href="#数组推导" class="headerlink" title="数组推导"></a>数组推导</h3><p>语法：<code>[expression for (variable in object) if (condition)]</code></p>
<p>数组推导包含三部分：</p>
<ol>
<li>一个没有循环体的 for/in 或 for/each 循环。其中，变量之前没有 <code>var</code> 或 <code>let</code>，实际上是使用了隐式的 <code>let</code>，因而不会覆盖外部的变量。</li>
<li>在执行循环获得对象之后，用 if 条件判断，若为 true 则继续。if 判断是可选的。</li>
<li>将变量用 expression 计算，并将结果插入要创建的数组中。</li>
</ol>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>在 JavaScript 1.8 中，将数组推导中的方括号替换成圆括号就成了一个生成器表达式。该表达式的值是一个生成器对象，而不是数组。</p>
<h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>JavaScript 1.8 中，函数有一种简写形式。如果函数只是计算并返回一个表达式的值，那么可以写成：<code>function(arg) expression</code>。</p>
<h2 id="多-catch-从句"><a href="#多-catch-从句" class="headerlink" title="多 catch 从句"></a>多 catch 从句</h2><p>从 JavaScript 1.5 开始支持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e <span class="keyword">if</span> e <span class="keyword">instanceof</span> Example) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e <span class="keyword">if</span> e === <span class="string">"blabla"</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E4X-ECMAScript-for-XML"><a href="#E4X-ECMAScript-for-XML" class="headerlink" title="E4X:ECMAScript for XML"></a>E4X:ECMAScript for XML</h2><p>E4X 是 JavaScript 的一个标准扩展。通常用于服务端，大部分客户端还没支持。</p>
<h1 id="web-浏览器中的-JavaScript"><a href="#web-浏览器中的-JavaScript" class="headerlink" title="web 浏览器中的 JavaScript"></a>web 浏览器中的 JavaScript</h1><h2 id="JavaScript-程序的执行"><a href="#JavaScript-程序的执行" class="headerlink" title="JavaScript 程序的执行"></a>JavaScript 程序的执行</h2><h3 id="客户端-Javascript-时间线"><a href="#客户端-Javascript-时间线" class="headerlink" title="客户端 Javascript 时间线"></a>客户端 Javascript 时间线</h3><p>以下是理想的事件线，但不是所有浏览器都完全实现。</p>
<ol>
<li>浏览器创建 <code>Document</code> 对象，并开始解析页面：在解析 HTML 元素和它们的文本内容后添加 <code>Element</code> 对象和 <code>Text</code> 节点到文档中。此阶段 <code>document.readystate</code> 属性是“loading”。</li>
<li>当 HTML 解析器遇到没有 <code>async</code> 和 <code>defer</code> 属性的 <code>&lt;script&gt;</code> 元素时，它把元素添加到文档中并执行相应脚本。脚本的执行是同步的，在脚本下载（若需要）和执行时解析器会暂停。因此脚本可以通过 <code>document.write()</code> 向输入流写入文本。同步脚本可以看到它自身和之前的文档内容。</li>
<li>当遇到 <code>async</code> 属性的 <code>&lt;script&gt;</code> 元素时，会下载脚本并继续解析文档。脚本会在下载完成后尽快执行，但解析器不会为它暂停。异步脚本禁止使用 <code>document.write()</code>。它可以看到自身和之前的文档内容。</li>
<li>当文档解析完成，<code>document.readystate</code> 变为“interactive”。</li>
<li>按出现顺序依次执行所有 <code>defer</code> 属性脚本。它能访问完整的文档树，但不能使用 <code>document.write()</code>。</li>
<li>浏览器在 <code>Document</code> 对象上触发 <code>DOMContentLoaded</code> 事件，标志着程序执行从同步阶段转到了异步事件驱动阶段。此时可能还有异步脚本没有执行完成。</li>
<li>至此文档已解析完毕，但可能还有其他内容没载入完成，比如图片。当所有内容载入完成、异步脚本执行完成后，<code>document.readystate</code> 属性变为“complete”，浏览器触发 <code>Window</code> 对象上的 <code>load</code> 事件。</li>
<li>开始调用异步事件。</li>
</ol>
<h2 id="兼容性和互用性"><a href="#兼容性和互用性" class="headerlink" title="兼容性和互用性"></a>兼容性和互用性</h2><h3 id="Internet-Explorer-里的条件注释"><a href="#Internet-Explorer-里的条件注释" class="headerlink" title="Internet Explorer 里的条件注释"></a>Internet Explorer 里的条件注释</h3><p>条件注释不是标准规范，而是 IE5 开始引入的功能，主要用于解决 IE 相关的兼容性问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]&gt;</span></span><br><span class="line"><span class="comment">只会在 IE6 显示。</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">在 IE5、6、7 中显示。还可以用 lt、gt、gte。</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;&lt;--&gt;</span></span><br><span class="line">不会在 IE 中显示。</span><br><span class="line"><span class="comment">&lt;!--&gt;&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>
<p>IE 的 JavaScript 解释器也支持条件注释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    alert("in IE");//会在 IE 中执行</span></span><br><span class="line"><span class="comment">  @end</span></span><br><span class="line"><span class="comment">  @*/</span></span><br></pre></td></tr></table></figure>
<h1 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h1><h2 id="浏览器定位和导航"><a href="#浏览器定位和导航" class="headerlink" title="浏览器定位和导航"></a>浏览器定位和导航</h2><p><code>Window</code> 对象和 <code>Document</code> 对象的 <code>location</code> 属性引用同一个 <code>Location</code> 对象，表示当前显示文档的 URL。</p>
<p><code>Document</code> 对象还有一个 <code>URL</code> 属性，是文档首次载入后保存文档 URL 的静态字符串。如果定位到文档中的片段标识符，<code>Location</code> 对象会相应更新，而 <code>document.URL</code> 则不会。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p><code>window.location</code> 引用的是 <code>Location</code> 对象，表示当前显示文档的 URL。</p>
<p><code>location.href</code> 是一个字符串形式的 URL。</p>
<p><code>Location</code> 对象的 <code>toString()</code> 返回 <code>href</code> 的值。</p>
<p><code>Location</code> 对象还有其他属性：<code>protocol</code>、<code>host</code>、<code>hostname</code>、<code>port</code>、<code>pathname</code>、<code>search</code>，分别表示 URL 的各部分。</p>
<p><code>Location</code> 对象的 <code>hash</code> 属性（若存在的话）返回 URL 中的片段标识符部分。<code>search</code> 属性返回问号之后的 URL（含问号）。</p>
<h3 id="载入新的文档"><a href="#载入新的文档" class="headerlink" title="载入新的文档"></a>载入新的文档</h3><p>在 <code>Location</code> 对象中：</p>
<ul>
<li><code>assign()</code> 使窗口载入指定 URL 的文档。</li>
<li><code>replace()</code> 类似 <code>assign()</code>，只是在载入新文档之前会从浏览历史中删除当前文档。</li>
<li>另一种更传统的跳转方法是把新的 URL 赋给 location` 属性。</li>
<li><code>reload()</code> 重现载入当前文档。</li>
</ul>
<h2 id="浏览历史"><a href="#浏览历史" class="headerlink" title="浏览历史"></a>浏览历史</h2><p><code>window.history</code> 属性引用的是 <code>History</code> 对象。<code>History.length</code> 表示浏览历史列表中的元素数量。出于安全考虑，脚本不能访问已保存的 URL，否则任意脚本都能窥探浏览历史。</p>
<p><code>back()</code> 和 <code>forward()</code> 跟浏览器的后退、前进一样。<code>go()</code> 接受一个整数参数，在历史列表中向前（正整数）或向后（负整数）跳跃指定页数。</p>
<p>如果窗口包含多个子窗口（比如 <code>&lt;iframe&gt;</code>），子窗口的历史会按时间顺序穿插在主窗口的历史中。</p>
<h2 id="浏览器和屏幕信息"><a href="#浏览器和屏幕信息" class="headerlink" title="浏览器和屏幕信息"></a>浏览器和屏幕信息</h2><h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><p><code>window.nevigator</code> 引用的是包含浏览器厂商和版本信息的 <code>Navigator</code> 对象（此名字是为了纪念 Netscapte Nevigator 浏览器）。</p>
<ul>
<li><code>appName</code>：Web 浏览器的全称。在 IE 中是“Microsoft Internet Explorer”，在其他浏览器中通常是“Netscape”。</li>
<li><code>appVersion</code>：通常以数字开始，跟着包含浏览器厂商和版本信息的详细字符串。字符串没有标准格式，不能直接用来判断浏览器的类型。</li>
<li><code>userAgent</code>：浏览器在 <code>USER-AGENT</code> 头部中发送的字符串。</li>
<li><code>platform</code>：运行浏览器的操作系统的字符串。</li>
<li><code>onLine</code>：若存在的话表示浏览器当前是否连接到网络。</li>
<li><code>geolocation</code>：用于确定用户地理位置。</li>
<li><code>javaEnabled()</code>：非标准方法，判断浏览器是否可以运行 Java 小程序。</li>
<li><code>cookieEnable()</code>：非标准方法，判断浏览器是否可以保存永久的 cookie。当 cookie 配置为“视具体情况而定”时可能返回不正确的值。</li>
</ul>
<h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><ul>
<li><code>width</code>、<code>height</code>：以像素为单位的窗口大小。</li>
<li><code>availWidth</code>、<code>availHeight</code>：实际可用的大小。</li>
<li><code>colorDepth</code>：显示的 BPP（bits-per-pixel）值，典型的值是 16、24、32。</li>
</ul>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ul>
<li><code>alert()</code>：提示框。</li>
<li><code>confirm()</code>：确认框，返回布尔值。</li>
<li><code>prompt()</code>：提示输入框，返回用户输入的字符串。</li>
<li><code>showModalDialog()</code>：显示一个包含 HTML 格式的“模态对话框”，可以给它传入参数，以及从对话框里返回值。</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><code>Window.onerror</code> 的值是一个事件处理程序。由于历史原因，它接受三个字符串参数而不是一个事件对象。</p>
<ol>
<li>描述错误的一条消息。</li>
<li>引发错误的 js 代码所在文档的 URL 的字符串。</li>
<li>文档中发生错误的行数。</li>
<li>返回 false，表示它通知浏览器事件处理程序已经处理了错误，即浏览器不应该显示错误消息。但由于历史原因，Firefox 里的错误处理程序必须返回 true 来表示它已经处理了错误。</li>
</ol>
<h2 id="多窗口和窗体"><a href="#多窗口和窗体" class="headerlink" title="多窗口和窗体"></a>多窗口和窗体</h2><h3 id="打开和关闭窗口"><a href="#打开和关闭窗口" class="headerlink" title="打开和关闭窗口"></a>打开和关闭窗口</h3><p><code>Window.open()</code> 有 4 个可选参数：</p>
<ol>
<li>新窗口中文档的 URL，若省略或为空字符串，则会使用 about:blank。</li>
<li>新窗口的名字。若指定的是已存在的窗口名字，则会直接使用该窗口。若省略会使用 <code>_blank</code>。<ul>
<li>只有设置了“允许导航”（allowed to navigator）（HTML5 术语）的页面才行。当且仅当窗口包含的文档是同源的，或是此脚本打开了那个窗口（包括递归打开），脚本才能只通过名字来指定存在的窗口。</li>
<li>若两个窗口是内嵌关系，那它们的脚本可以互相导航。此时可以用保留的名字 <code>_top</code> 和 <code>_parent</code> 来获取彼此的上下文。</li>
</ul>
</li>
<li>以逗号分隔的列表，包含大小和各种属性。若省略则会用一个默认的大小，而且带有一整组标准的 UI 组件，即菜单栏、状态栏、工具栏等。这个参数是非标准的。</li>
<li>一个布尔值，只在第二个参数命名的是一个存在的窗口时才有用，声明了由第一个参数指定的 URL 是应该替换掉窗口浏览历史的当前条目（true），还是应该在历史中创建一个新的条目（false），后者是默认值。</li>
</ol>
<p>返回值是代表命名或新创建的窗口的 <code>Window</code> 对象。该对象的 <code>opener</code> 属性引用的是调用 <code>open</code> 方法的那个窗口。</p>
<h3 id="窗体之间的关系"><a href="#窗体之间的关系" class="headerlink" title="窗体之间的关系"></a>窗体之间的关系</h3><p>顶级窗口或标签的 <code>parent</code> 和 <code>top</code> 属性引用的是自身。</p>
<p><code>&lt;iframe&gt;</code> 元素由 <code>contentWindow</code> 属性，引用的是该窗体对象。反过来，窗体的 <code>window.frameElement</code> 属性引用的是相应的 <code>&lt;iframe&gt;</code> 元素对象。顶级窗口对象的 <code>frameElement</code> 属性为 null。</p>
<p>通常用另一种方式来获取其他窗体对象。</p>
<p>每个 <code>Window</code> 对象都有一个 <code>frames</code> 属性，包含了该窗口所包含的窗口或窗体的 <code>Window</code> 对象（而不是 <code>&lt;iframe&gt;</code> 对象）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个子窗体的第三个子窗体。</span></span><br><span class="line"><span class="keyword">var</span> w1 = frames[<span class="number">1</span>].frames[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//兄弟窗体</span></span><br><span class="line"><span class="keyword">var</span> w2 = parent.frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//通过 &lt;iframe&gt; 元素的 name 或 id 来索引</span></span><br><span class="line"><span class="keyword">var</span> w3 = frames[<span class="string">"f1"</span>];</span><br></pre></td></tr></table></figure>
<p>实际上 <code>frames</code> 属性引用的是 <code>window</code> 本身，也就是说 <code>window</code> 本身就是一个由子窗体对象组成的数组。不过通过 <code>frames</code> 来引用会显得清楚一点。</p>
<h1 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h1><h2 id="文档结构和遍历"><a href="#文档结构和遍历" class="headerlink" title="文档结构和遍历"></a>文档结构和遍历</h2><h3 id="作为节点树的文档"><a href="#作为节点树的文档" class="headerlink" title="作为节点树的文档"></a>作为节点树的文档</h3><p><code>Document</code>、<code>Element</code>、<code>Text</code> 对象都是 <code>Node</code> 对象。<code>Node</code> 定义了以下属性：</p>
<ul>
<li><code>parentNode</code>：若无父节点则为 null。</li>
<li><code>childNodes</code>：只读的类数组对象（<code>NodeList</code>）。</li>
<li><code>firstChild</code>、<code>lastChild</code></li>
<li><code>nextSibling</code>、<code>previousSibling</code></li>
<li><code>NodeType</code>：节点类型。9：Document，1：Element，3：Text，8：Comment，11：DocumentFragment。</li>
<li><code>NodeValue</code>：Text 节点或 Comment 节点的文本内容。</li>
<li><code>nodeName</code>：元素的标签名，大写。</li>
</ul>
<h1 id="Javascript核心参考"><a href="#Javascript核心参考" class="headerlink" title="Javascript核心参考"></a>Javascript核心参考</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>属性</strong></p>
<ul>
<li><code>length</code>: 字符数。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><code>charAt</code> 返回指定索引处的字符。</li>
<li><code>charCodeAt</code> 返回指定索引处的字符的编码。</li>
<li><code>concat</code> 将若干值拼接成一个字符串。</li>
<li><code>indexOf</code> 返回子字符串第一次出现的位置。</li>
<li><code>lastIndexOf</code> 返回子字符串最后一次出现的位置。</li>
<li><code>localeCompare</code> 使用本地定义的顺序比较字符串。</li>
<li><code>match</code> 使用正则进行匹配。</li>
<li><code>replace</code> 使用正则进行替换。</li>
<li><code>search</code> 返回匹配正则的子字符串。</li>
<li><code>slice(start, end)</code> 返回一个子字符串。<ul>
<li><code>start</code> 起始处索引（包含），可为负数。</li>
<li><code>end</code> 结束处索引（不含），可为负数。若未指定则默认为结尾。</li>
</ul>
</li>
<li><code>split</code> 用指定字符串或正则表达式作为分隔符，返回分割后的字符串数组。</li>
<li><code>substr(start, length)</code> 返回一个子字符串。指定起始索引和子字符串长度。</li>
<li><code>substring(start, end)</code> 返回一个子字符串。索引不能为负数。</li>
<li><code>toLowerCase</code> 转小写。</li>
<li><code>toUpperCase</code> 转大写。</li>
<li><code>trim</code> 删除前后空白字符。</li>
</ul>
<p><strong>静态方法</strong></p>
<ul>
<li><code>fromCharCode</code> 创建指定编码对应的字符串。</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><blockquote>
<p>string.replace(regex, replacement)</p>
</blockquote>
<ul>
<li><code>regex</code> 正则表达式对象。若实际传入的是字符串而不是正则对象，则按照字符串字面量匹配，而不会自动转换成正则对象。</li>
<li><code>replacement</code> 替换用的字符串或函数。<ul>
<li>若为函数（ES3 开始），则函数的入参是：<ul>
<li>匹配到字符串，它的返回值会作为替换用的字符串。</li>
</ul>
</li>
<li>若为字符串，则其中的 <code>$</code> 有特殊含义。<ul>
<li><code>$1</code>, <code>$2</code>, …, <code>$99</code>: 对应 <code>regex</code> 中的分组内匹配到的文本。</li>
<li><code>$&amp;</code>: <code>regex</code> 匹配到的子串。</li>
<li><code>$``</code>: 子串的左边文本。</li>
<li><code>$&#39;</code>: 子串的右边文本。</li>
<li><code>$$</code>: 美元符号本身。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>[^1]:Unicode 对其所有字符做了分类，这种分类用“通用类别值”表示，这里的“Mn”、“Mc”和“Pc”分别表示基字符的修改中出现的非间距字符、基字符的修改中影响了基字符标识位的宽度的间距字符、连接两个字符的连接符或标点符号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/volatile/" itemprop="url">volatile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文内容摘取及参考自<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">此博客</a></em></p>
<h1 id="硬件层面的并发同步问题"><a href="#硬件层面的并发同步问题" class="headerlink" title="硬件层面的并发同步问题"></a>硬件层面的并发同步问题</h1><p>CPU 处理数据时，先将内存中的数据读取到高速缓存中，处理结束之后将高速缓存中的数据写回到内存中。</p>
<p>这种数据处理方式提高了速度，但会引起并发同步问题。即使是单核 CPU，也会以线程调度的形式表现出该问题。</p>
<p>为解决缓存不一致问题，通常有 2 种解决方法：</p>
<ul>
<li>在总线加 LOCK# 锁；</li>
<li>通过缓存一致性协议。</li>
</ul>
<p>在早期的 CPU 中，是通过在总线上加 LOCK# 锁的方式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。但是由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是 Intel 的 MESI 协议。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<hr>
<h1 id="并发编程涉及到的-3-个概念及-Java-提供的方案"><a href="#并发编程涉及到的-3-个概念及-Java-提供的方案" class="headerlink" title="并发编程涉及到的 3 个概念及 Java 提供的方案"></a>并发编程涉及到的 3 个概念及 Java 提供的方案</h1><p>在 Java 虚拟机规范中通过定义一种 Java 内存模型（Java Memory Model，JMM）试图来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。</p>
<p>注意，为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在 Java 内存模型中，也会存在缓存一致性问题和指令重排序的问题</strong>。</p>
<p>Java 内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h2><blockquote>
<p>原子性指的是操作的不可拆解性。具有原子性的操作要么全部执行，要么全部不执行，无法拆解开一步步地执行。</p>
</blockquote>
<p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。如果要实现更大范围操作的原子性，可以通过 <code>synchronized</code> 和 <code>Lock</code> 来实现。<br>在低版本 JDK 中，在 32 位平台下，对 64 位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的 JDK 中，JVM 已经保证对 64 位数据的读取和赋值也是原子性操作了。</p>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><blockquote>
<p>可见性指的是当多线程访问同一变量时，若某一线程更改了该变量，则其他线程能立即获知该变量已被修改，并去读取最新的值。</p>
</blockquote>
<p>对于可见性，Java 提供了 <code>volatile</code> 关键字来保证可见性。当一个共享变量被 <code>volatile</code> 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，会去主存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过 <code>synchronized</code> 和 <code>Lock</code> 也能够保证可见性，<code>synchronized</code> 和 <code>Lock</code> 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><blockquote>
<p>有序性指的是程序按照源代码的编写顺序执行。</p>
</blockquote>
<p>在 Java 内存模型中，允许编译器和处理器对指令进行重排序（Instruction Reorder），但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在 Java 里面，可以通过 volatile 关键字来保证一定的“有序性”。另外可以通过 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性，很显然，<code>synchronized</code> 和 <code>Lock</code> 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 “<strong>happens-before</strong>” 原则。如果两个操作的执行次序无法从“happens-before”原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p><strong>happens-before</strong> 原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。（这条实际上指的是编译器的指令重排一定不会影响单线程状态下的正确性，即对于单线程来说，程序就像是按照代码顺序执行的一样）</li>
<li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作</li>
<li>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</li>
<li>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始</li>
</ul>
<hr>
<h1 id="深入剖析-volatile"><a href="#深入剖析-volatile" class="headerlink" title="深入剖析 volatile"></a>深入剖析 volatile</h1><h2 id="volatile-的两层语义"><a href="#volatile-的两层语义" class="headerlink" title="volatile 的两层语义"></a>volatile 的两层语义</h2><ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ol>
<h2 id="volatile-是否保证原子性"><a href="#volatile-是否保证原子性" class="headerlink" title="volatile 是否保证原子性"></a>volatile 是否保证原子性</h2><p>volatile 不保证原子性。可用 synchronized、Lock、java.util.concurrent.atomic.* 来保证原子性</p>
<h2 id="volatile-是否保证可见性"><a href="#volatile-是否保证可见性" class="headerlink" title="volatile 是否保证可见性"></a>volatile 是否保证可见性</h2><ol>
<li>使用 volatile 关键字会强制将修改的值立即写入主存；</li>
<li>使用 volatile 关键字的话，当线程 2 修改某共享变量时，会导致线程 1 的工作内存中的该变量的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）；</li>
<li>由于线程 1 的工作内存中的缓存变量的缓存行无效，所以线程 1 再次读取变量的值时会去主存读取。</li>
</ol>
<h2 id="volatile-是否保证有序性"><a href="#volatile-是否保证有序性" class="headerlink" title="volatile 是否保证有序性"></a>volatile 是否保证有序性</h2><p>volatile 关键字禁止指令重排序有两层意思：</p>
<ol>
<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对 volatile 变量访问的语句前面的语句放在其后面执行，也不能把在对 volatile 变量访问的语句后面的语句放到其前面执行。</li>
</ol>
<h2 id="volatile-的原理和实现机制"><a href="#volatile-的原理和实现机制" class="headerlink" title="volatile 的原理和实现机制"></a>volatile 的原理和实现机制</h2><p>“观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令”——《深入理解Java虚拟机》</p>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：</p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zeerho</p>
              <p class="site-description motion-element" itemprop="description">Just a repo for documents</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZephyrHuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zephyrhuang21@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeerho</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
