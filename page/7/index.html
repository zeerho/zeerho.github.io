<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Just a repo for documents">
<meta property="og:type" content="website">
<meta property="og:title" content="Tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="zeerho">
<meta property="og:description" content="Just a repo for documents">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-05T02:37:10.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tags">
<meta name="twitter:description" content="Just a repo for documents">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/"/>





  <title>zeerho</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zeerho</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/操作系统/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/操作系统/Linux/" itemprop="url">Linux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h2 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h2><p>常用分区计划：</p>
<table>
<thead>
<tr>
<th style="text-align:left">挂载点</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">设备类型</th>
<th style="text-align:left">文件系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>/boot</code></td>
<td style="text-align:left">1024M</td>
<td style="text-align:left">standard Partition</td>
<td style="text-align:left">xfs</td>
</tr>
<tr>
<td style="text-align:left"><code>swap</code></td>
<td style="text-align:left">内存容量</td>
<td style="text-align:left">LVM</td>
<td style="text-align:left">swap</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">剩余</td>
<td style="text-align:left">LVM</td>
<td style="text-align:left">xfs</td>
</tr>
</tbody>
</table>
<p>安装前强制使用 GPT 分区表。</p>
<ol>
<li>光标移至 <code>Install CentOS 7</code></li>
<li>按 Tab 键，在下方输入参数</li>
<li><code>vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet inst.gpt</code> 关键是 <code>inst.gpt</code>。</li>
</ol>
<h1 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h1><ol>
<li>BIOS：开机主动执行的固件，会识别用户设定的用于启动系统的存储设备。</li>
<li>MBR：用于启动系统的存储设备的第一个扇区（或 LBA）内的主要启动记录区块，内含开机管理程序。</li>
<li>开机管理程序（boot loader）：用于读取并执行系统核心文件。<ol>
<li>提供选单：用户可以选择不同的开机项目。</li>
<li>载入核心文件：直接指向开机程序的地址分段来启动操作系统。</li>
<li>转交其他 loader：将开机管理功能转交给其他 loader 负责。每个分区的启动扇区里都可以放入一个 boot loader，该 loader 只认识本分区的系统核心文件和其他分区的 loader。</li>
</ol>
</li>
<li>核心文件：启动操作系统的各种功能</li>
</ol>
<p>一些发行版使用一个表来管理开机自启的进程，该表通常位于 /etc/inittab 文件中。另一些发行版则采用 /etc/init.d/ 目录，将开机时启动或停止某个应用的脚本放到该目录下，这些脚本通过 /etc/rcX.d/ 目录下的符号链接（链接到 /etc/init.d/ 目录中的启动脚本）启动，其中 X 代表运行级（run level）。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><code>$ export VAR=&quot;test&quot;</code> 临时变量，重启系统后失效。</p>
<p>/etc/environment 是整个系统的环境，/etc/profile 是所有用户的环境。</p>
<p>login shell：通过终端凭借用户名和密码登录的动作。<br>non-login shell：在图形界面启动一个 terminal，或者执行 /bin/bash，/usr/bin/bash。</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">非交互+登录</th>
<th style="text-align:center">交互+登录</th>
<th style="text-align:center">交互+非登录</th>
<th style="text-align:center">非交互+非登录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/etc/profile</td>
<td style="text-align:center">加载</td>
<td style="text-align:center">加载</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/bashrc</td>
<td style="text-align:center">加载</td>
<td style="text-align:center">加载</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">~/.bash_profile</td>
<td style="text-align:center">加载</td>
<td style="text-align:center">加载</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">~/.bashrc</td>
<td style="text-align:center">加载</td>
<td style="text-align:center">加载</td>
<td style="text-align:center">加载</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">BASH_ENV</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">加载</td>
</tr>
</tbody>
</table>
<p>可以修改 shell 来模拟交互登录式的动作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/path/to/my_sh -ilex</span></span><br><span class="line"><span class="comment">#e 一旦出错就退出当前 shell</span></span><br><span class="line"><span class="comment">#i 交互式</span></span><br><span class="line"><span class="comment">#l 登录式</span></span><br><span class="line"><span class="comment">#x 显示所执行的每条命令</span></span><br></pre></td></tr></table></figure>
<p><strong>login shell 读取配置的顺序</strong></p>
<ol>
<li>/etc/profile<ul>
<li>-&gt; /etc/inputrc</li>
<li>-&gt; /etc/profile.d/*.sh -&gt; /etc/sysconfig/i18n</li>
</ul>
</li>
<li>读到任意一个就忽略后面的（注意：调用链括号部分跟上面有重复）<ol>
<li>~/.bash_profile -&gt; ~/.bashrc -&gt; /etc/bashrc (-&gt; /etc/profile.d/*.sh -&gt; /etc/sysconfig/i18n)</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ol>
</li>
</ol>
<p><strong>non-login shell 读取配置的顺序</strong></p>
<ol>
<li>~/.bashrc -&gt; /etc/bashrc -&gt; /etc/profile.d/*.sh -&gt; /etc/sysconfig/i18n</li>
</ol>
<p><strong>总结：</strong>两者的交点是 ~/.bashrc（用户级）和 /etc/bashrc（系统级）。</p>
<h2 id="etc-profile-内容解析"><a href="#etc-profile-内容解析" class="headerlink" title="/etc/profile 内容解析"></a>/etc/profile 内容解析</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 根据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录</span></span><br><span class="line"><span class="function"><span class="title">pathmunge</span></span> () &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">":<span class="variable">$&#123;PATH&#125;</span>:"</span> <span class="keyword">in</span></span><br><span class="line">        *:<span class="string">"<span class="variable">$1</span>"</span>:*)</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"<span class="variable">$2</span>"</span> = <span class="string">"after"</span> ] ; <span class="keyword">then</span></span><br><span class="line">                PATH=<span class="variable">$PATH</span>:<span class="variable">$1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                PATH=<span class="variable">$1</span>:<span class="variable">$PATH</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 根据用户的账号设置此变量内容</span></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/id ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$EUID</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># ksh workaround</span></span><br><span class="line">        EUID=`/usr/bin/id -u`</span><br><span class="line">        UID=`/usr/bin/id -ru`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    USER=<span class="string">"`/usr/bin/id -un`"</span></span><br><span class="line">    LOGNAME=<span class="variable">$USER</span></span><br><span class="line">    MAIL=<span class="string">"/var/spool/mail/<span class="variable">$USER</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># Path manipulation</span></span><br><span class="line"> <span class="comment"># 调用前面的 `pathmunge` 函数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$EUID</span>"</span> = <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    pathmunge /usr/sbin</span><br><span class="line">    pathmunge /usr/<span class="built_in">local</span>/sbin</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pathmunge /usr/<span class="built_in">local</span>/sbin after</span><br><span class="line">    pathmunge /usr/sbin after</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">HOSTNAME=`/usr/bin/hostname 2&gt;/dev/null`</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 命令历史纪录相关</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HISTCONTROL</span>"</span> = <span class="string">"ignorespace"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> HISTCONTROL=ignoreboth</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">export</span> HISTCONTROL=ignoredups</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</span><br><span class="line"></span><br><span class="line"> <span class="comment"># By default, we want umask to get set. This sets it for login shell</span></span><br><span class="line"> <span class="comment"># Current threshold for system reserved uid/gids is 200</span></span><br><span class="line"> <span class="comment"># You could check uidgid reservation validity in</span></span><br><span class="line"> <span class="comment"># /usr/share/doc/setup-*/uidgid file</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">"`/usr/bin/id -gn`"</span> = <span class="string">"`/usr/bin/id -un`"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 调用其他配置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh /etc/profile.d/sh.local ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;-#*i&#125;</span>"</span> != <span class="string">"$-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> i</span><br><span class="line"><span class="built_in">unset</span> -f pathmunge</span><br></pre></td></tr></table></figure>
<h1 id="挂载-卸载"><a href="#挂载-卸载" class="headerlink" title="挂载/卸载"></a>挂载/卸载</h1><p><code>df -h</code> 查看挂载情况<br><code>umount {file_system}</code> 卸载，终端中挂载消失，UI 中挂载仍在<br><code>mount {file_system}</code> 挂载<br><code>eject</code> 弹出，UI 中挂载也消失，且无法直接再用<code>mount</code>命令挂载回来</p>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><ol>
<li>安装<ol>
<li>选择要安装 jdk 的位置，如 /usr/ 目录下，新建文件夹 java(<code>sudo mkdir /usr/java</code>)</li>
<li>将文件 jdk-7u40-linux-i586.tar.gz 移动到 /usr/java</li>
<li>解压：<code>sudo tar -zxvf jdk-7u40-linux-i586.tar.gz</code></li>
<li>删除 jdk-7u40-linux-i586.tar.gz</li>
</ol>
</li>
<li>配置<ol>
<li>打开 /home/{user}/.bashrc，加入：<code>source /etc/profile</code></li>
<li>打开 /etc/profile（<code>sudo vim /etc/profile</code>）<br>在最后面添加如下内容，这样使得每次进入该用户的 bash 时都会使添加的环境变量生效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.7.0_40</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>验证是否安装成功：<code>java -version</code></p>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><ol>
<li><code>sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</code><br>将下载源加入系统的源列表</li>
<li><code>wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</code><br>导入谷歌软件的公钥，用于后续步骤对下载软件进行认证</li>
<li><code>sudo apt-get update</code><br>对当前系统可用的更新列表进行更新</li>
<li><code>sudo apt-get install google-chrome-stable</code><br>安装 chrome 稳定版</li>
<li><code>/usr/bin/google-chrome-stable</code><br>启动 chrome</li>
</ol>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol>
<li>下载 RPM包<br><code>wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</code></li>
<li>安装 RPM 包<br><code>yum localinstall mysql57-community-release-el7-9.noarch</code></li>
<li>安装 mysql<br><code>yum install mysql-community-server</code></li>
<li>查看自动生成的随机密码<br><code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></li>
<li>启动、查看 mysql service<br><code>service mysqld start</code><br><code>service mysqld status</code></li>
<li>安全相关设置<br><code>mysql_secure_installation</code></li>
<li>登录成功后修改密码强度限制（测试环境）<ol>
<li><code>set global validate_password_policy=0;</code></li>
<li><code>set global validate_password_length=4;</code></li>
<li><code>set password=password(&#39;root&#39;)</code> 测试环境换个简单的密码</li>
</ol>
</li>
</ol>
<h2 id="erlang"><a href="#erlang" class="headerlink" title="erlang"></a>erlang</h2><p><strong>源码编译</strong></p>
<ol>
<li>下源码。从官网或 github 下：<ul>
<li><code>wget http://www.erlang.org/download/otp_src_20.3.tar.gz</code></li>
<li><code>git clone https://github.com/erlang/otp.git</code></li>
</ul>
</li>
<li>解压 <code>tar -zxvf ~/Downloads/otp_src_20.3.tar.gz</code></li>
<li>配置<ul>
<li>如果是从 github 上下载的源码，要先生成配置脚本 <code>./otp_build autoconf</code></li>
<li>配置中会检查必需的工具。<ul>
<li>GNU <code>make</code></li>
<li>Compiler – GNU C Compiler, gcc or the C compiler frontend for LLVM, clang.</li>
<li>Perl 5</li>
<li>GNU <code>m4</code></li>
<li><code>ncurses</code>, <code>termcap</code>, or <code>termlib</code> – The development headers and libraries are needed, often known as ncurses-devel. Use –without-termcap to build without any of these libraries. Note that in this case only the old shell (without any line editing) can be used.</li>
<li><code>sed</code></li>
</ul>
</li>
<li><code>cd otp_src_20.3</code></li>
<li>配置自定义的安装目录 <code>./configure --prefix=/opt/erlang</code></li>
</ul>
</li>
<li>编译 <code>make</code></li>
<li>安装 <code>make install</code></li>
<li>设置环境变量 <code>vi /etc/profile</code>（<code>whereis erl</code> 查看安装目录）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERL_HOME=/usr/local/erlang</span><br><span class="line">PATH=$ERL_HOME/bin:$PATH</span><br><span class="line">export ERL_HOME PATH</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>yum 安装</strong></p>
<ol>
<li>安装 epel <code>yum -y install http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm</code></li>
<li>更新 erlang 仓库 <code>yum -y install  http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</code></li>
<li>安装 erlang <code>yum install erlang</code></li>
</ol>
<h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><ol>
<li>下包。<code>wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpm</code></li>
<li>可能要安装 socat：<code>yum -i socat</code></li>
<li>安装。<code>rpm -i rabbitmq-server-3.7.4-1.el7.noarch.rpm</code></li>
<li>如果不是用这种包管理的方式安装的话可能要手动创建几个文件夹<ul>
<li><code>mkdir -p /var/log/rabbitmq</code></li>
<li><code>mkdir -p /var/log/rabbitmq/mnesia/rabbit</code></li>
</ul>
</li>
<li>启动服务 <code>sbin/rabbitmq-server</code></li>
</ol>
<h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p><code>apt-get purge</code> <code>apt-get remove --purge</code></p>
<p>删除软件包和配置文件，保留依赖包。</p>
<p><code>apt-get remove</code></p>
<p>删除软件包，保留依赖包和配置文件。</p>
<p><code>apt-get autoremove</code></p>
<p>删除不需要的依赖包。</p>
<p><code>apt-get autoclean</code></p>
<p>APT 的底层包是 dpkg，dpkg 会把 .deb 文件放在 /var/cache/apt/archives 中。</p>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><code>yum search {keyword}</code><br>根据关键字搜索软件包</p>
<p><code>yum list</code><br>列出可安装包</p>
<p><code>yum list [updates|installed|{name}|extras]</code><br>列出可更新包|已安装包|指定包|所有已安装但不在 Yum Repository 中的包</p>
<p><code>yum info</code><br>列出所有软件包信息</p>
<p><code>yum info [updates|installed|{name}|extras]</code><br>列出可更新包|已安装包|指定包|所有已安装但不在 Yum Repository 中的包的信息</p>
<p><code>yum provides {name}</code><br>列出软件包提供哪些文件</p>
<p><code>yum clean packages</code><br>清除缓存目录(/var/cache/yum)下的软件包<br><code>yum clean headers</code><br>清除缓存目录(/var/cache/yum)下的 headers<br><code>yum clean oldheaders</code><br>清除缓存目录(/var/cache/yum)下旧的 headers<br><code>yum clean, yum clean all</code> (= <code>yum clean packages</code>;<code>yum clean oldheaders</code>)<br>清除缓存目录(/var/cache/yum)下的软件包及旧的headers</p>
<p><code>yum update</code> 升级系统<br><code>yum install {name}</code> 安装指定软件包<br><code>yum update {name}</code> 升级指定软件包<br><code>yum remove {name}</code> 卸载指定软件<br><code>yum grouplist</code> 查看系统中已经安装的和可用的软件组，可用的可以安装<br><code>yum grooupinstall {name}</code> 安装上一个命令显示的可用的软件组中的一个<br><code>yum grooupupdate {name}</code> 更新指定软件组的软件包<br><code>yum grooupremove {name}</code> 卸载指定软件组中的软件包<br><code>yum deplist {name}</code> 查询指定软件包的依赖关系<br><code>yum list yum\*</code> 列出所有以yum开头的软件包<br><code>yum localinstall {name}</code> 从硬盘安装rpm包并使用yum解决依赖</p>
<h2 id="配置阿里云源"><a href="#配置阿里云源" class="headerlink" title="配置阿里云源"></a>配置阿里云源</h2><p><strong>ubuntu</strong></p>
<p>源文件是 <code>/etc/apt/sources.list</code>，记录了 apt 所用的包仓库位置。类似的还有 <code>/etc/apt/sources.list.d/</code> 下的各种 <code>.list</code> 文件。</p>
<ol>
<li>备份。<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></li>
<li>查看系统版本信息 <code>lsb_release -c</code>。冒号后面是系统代号，后面要用。</li>
<li><p>编辑 <code>sources.list</code> 文件，将其中内容全删后粘贴以下内容。其中的 <code>bionic</code> 是系统代号，要根据实际情况替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新软件列表 <code>sudo apt update</code></p>
</li>
</ol>
<p><code>sources.list</code> 文件内容是以下格式。后面的 component 是对软件包的分类。Ubuntu 下是 main、restricted、universe、multiverse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://&#123;host&#125;/&#123;debian-distribution&#125; component1 component2 component3</span><br><span class="line">deb-src http://&#123;host&#125;/&#123;debian-distribution&#125; component1 component2 component3</span><br></pre></td></tr></table></figure>
<p><strong>centos</strong></p>
<p>1、用wget下载repo文件</p>
<p><code>wget  http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>
<p>如果wget命令不生效，说明还没有安装wget工具，输入<code>yum -y install wget</code> 回车进行安装。</p>
<p>2、移至源目录</p>
<p><code>mv ./Centos-7.repo /etc/yum.repos.d/</code></p>
<p>3、备份系统原来的repo文件</p>
<p><code>mv CentOs-Base.repo CentOs-Base.repo.bak</code></p>
<p>4、替换系统原理的repo文件</p>
<p><code>mv Centos-7.repo CentOs-Base.repo</code></p>
<p>5、执行yum源更新命令</p>
<p><code>yum clean all</code><br><code>yum makecache</code><br><del><code>yum update</code></del></p>
<h1 id="用户-用户组管理"><a href="#用户-用户组管理" class="headerlink" title="用户/用户组管理"></a>用户/用户组管理</h1><p>管理用户和用户组的命令基本都是对 <code>/etc/passwd</code>、<code>/etc/group</code> 和 <code>/etc/shadow</code> 进行操作。</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><strong>新增用户</strong></p>
<p><code>useradd [-D] [opts] {newUser}</code></p>
<ul>
<li><code>-D</code> 变更预设值。</li>
<li><code>-c {comment}</code> 备注，会保存在 <code>/etc/passwd</code> 的备注栏中。</li>
<li><code>-d {loginDir}</code> 用户登录时的初始目录。</li>
<li><code>-e {effectiveTime}</code> 账号的有效期限。</li>
<li><code>-f {effectiveDays}</code> 密码过期后多少天关闭账号。</li>
<li><code>-g {mainGroup}</code> 主用户组，缺省与用户同名。</li>
<li><code>-G {supplementaryGroup}</code> 附加组。</li>
<li><code>-m|-M</code> 自动建立/不建立用户的登录目录。</li>
<li><code>-n</code> 取消建立与用户同名的组。</li>
<li><code>-r</code> 建立系统账号。</li>
<li><code>-s {shell}</code> 用户登录后使用的 shell。</li>
<li><code>-u {uid}</code> 指定用户 ID。</li>
</ul>
<p><strong>关于 <code>adduser</code> 和 <code>useradd</code></strong></p>
<p>Ubuntu 中 <code>useradd</code> 是一个二进制程序，<code>adduser</code> 是一个脚本，是对前者的封装；CentOS 中，<code>adduser</code> 是另一个的符号链接。 <strong>一般使用 <code>useradd</code>，它在不同发行版中都一样。</strong></p>
<p><strong>修改用户信息</strong><br><code>usermod [-LU] [opts] {user}</code></p>
<ul>
<li><code>-L|-U</code> 锁定密码/解锁密码。</li>
<li><code>-c {comment}</code> 备注，会保存在 <code>/etc/passwd</code> 的备注栏中。</li>
<li><code>-d {loginDir}</code> 用户登录时的初始目录。</li>
<li><code>-e {effectiveTime}</code> 账号的有效期限。</li>
<li><code>-f {effectiveDays}</code> 密码过期后多少天关闭账号。</li>
<li><code>-g {mainGroup}</code> 主用户组，缺省与用户同名。</li>
<li><code>-G {supplementaryGroup}</code> 附加组，会覆盖已有的附加组。搭配 <code>-a</code> 可以新增而不覆盖。</li>
<li><code>l</code> 修改用户名。</li>
<li><code>-s {shell}</code> 用户登录后使用的 shell。</li>
<li><code>-u {uid}</code> 指定用户 ID。</li>
</ul>
<p><strong>删除用户</strong></p>
<p><code>userdel [-r] {user}</code></p>
<ul>
<li><code>-r</code> 连同用户目录一起删除。</li>
</ul>
<p><strong>修改密码</strong></p>
<p><code>passwd [opts] {user}</code></p>
<ul>
<li><code>-l</code> 锁定用户，禁止登录。</li>
<li><code>-u</code> 接触锁定。</li>
<li><code>--stdin</code> 允许通过标准输入修改密码，比如 <code>echo &quot;abc&quot; | passwd --stdin tom</code>。</li>
<li><code>-d</code> 可用空密码登录。</li>
<li><code>-e</code> 强制该用户下次登录时修改密码。</li>
<li><code>-S</code> 显示密码是否被锁定，以及密码所采用的加密算法名称。</li>
</ul>
<h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><strong>查看用户所属的组</strong></p>
<p><code>groups [user]</code> 若不指定用户则为当前用户。</p>
<p><strong>创建用户组</strong></p>
<p><code>groupadd [-r] {group}</code></p>
<ul>
<li><code>[-r]</code> 创建系统用户组，即 GID 小于 500。</li>
</ul>
<p><strong>修改用户组</strong></p>
<ul>
<li><code>groupmod -n {new} {old}</code> 修改用户组名，不会改变 GID。</li>
<li><code>groupmod -g {newGID} {group}</code> 修改 GID。</li>
</ul>
<p><strong>删除用户组</strong></p>
<p><code>groupdel {group}</code></p>
<p>若该用户组是某用户的主用户组，则必须先删除该用户，在删除该用户组。</p>
<h2 id="用户和用户组之间的操作"><a href="#用户和用户组之间的操作" class="headerlink" title="用户和用户组之间的操作"></a>用户和用户组之间的操作</h2><p><strong>添加用户到用户组/从用户组中删除用户</strong></p>
<ul>
<li><code>gpasswd -a {user} -g {group}</code> 将指定用户添加到指定组。</li>
<li><code>gpasswd -d {user} -g {group}</code> 从指定组中删除指定用户。</li>
</ul>
<p><strong>修改</strong></p>
<p><code>groupmems [option] [action]</code></p>
<ul>
<li>option<ul>
<li><code>-g</code> 更改为指定组。</li>
</ul>
</li>
<li>action<ul>
<li><code>-a</code> 指定用户加入组。</li>
<li><code>-d</code> 从组中删除用户。</li>
<li><code>-p</code> 从组中删除所有成员。</li>
<li><code>-l</code> 显示组成员列表。</li>
</ul>
</li>
</ul>
<h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><ul>
<li><code>sudo -V</code> 显示版本号</li>
<li><code>sudo -h</code> 帮助</li>
<li><code>sudo -l</code> 显示当前执行者的权限</li>
<li><code>sudo -v</code> 重新验证用户并顺延验证失效时间</li>
<li><code>sudo -k</code> 强制在下次执行 <code>sudo</code> 时验证密码</li>
<li><code>sudo [-b] [-u {username}|{uid}] {cmd}</code><ul>
<li><code>-b</code> 后台执行此命令</li>
<li><code>-u {username}|{uid}</code> 用指定用户执行命令。缺省为 root。</li>
</ul>
</li>
</ul>
<p>赋予 sudo 特权实际上是修改 <code>/etc/sudoers</code>。该文件只能用 root 用户通过 <code>visudo</code> 来编辑。</p>
<p><code>/etc/sudoers</code> 中包含两类内容：别名定义、授权规则。</p>
<p><strong>别名定义</strong></p>
<p><code>{aliasType} {name1} = {val1}, {val2}...[: {name2} = {val3}, {val4}...]</code></p>
<ul>
<li><code>{aliasType}</code> 有以下几种<ul>
<li><code>Host_Alias</code> 主机别名</li>
<li><code>User_Alias</code> 用户别名，可以是用户或用户组，若是用户组，前面要加 <code>%</code></li>
<li><code>Runas_Alias</code> runas 别名，即 <code>sudo</code> 允许切换至的用户</li>
<li><code>Cmnd_Alias</code> 命令别名</li>
</ul>
</li>
</ul>
<p><strong>授权规则</strong></p>
<p><code>{user}|{group} {host}=[({runAs})] [NOPASSWD:] [!]{cmd1}[, {cmd2}...]</code></p>
<ul>
<li><code>{user}|{group}</code> 授权用户或用户组，用户组前面要加 <code>%</code></li>
<li><code>{host}</code> 授权规则对应的主机</li>
<li><code>({runAs})</code> 切换到哪些用户/组。缺省为 <code>(root:root)</code>。若为 <code>(ALL)</code>，即 <code>(ALL:ALL)</code>，则可切换到任意用户/组。</li>
<li><code>NOPASSWD:</code> 不需要验证密码。</li>
<li><code>[!]{cmd1}[, {cmd2}...]</code> 允许执行的命令。<code>!</code> 表示禁止执行。为了避免执行到同名命令导致安全问题，应写命令的全路径，执行时同理。可以使用通配符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> # 井号为注释</span><br><span class="line"></span><br><span class="line"> # 默认有这么一行，可以当作参照</span><br><span class="line">root  ALL=(ALL)  ALL</span><br><span class="line"></span><br><span class="line"> # 给指定用户添加 sudo 权限</span><br><span class="line">tom  ALL=(ALL)  ALL</span><br><span class="line"></span><br><span class="line"> # 给指定用户组的所有用户添加 sudo 权限</span><br><span class="line">%example  ALL=(ALL)  ALL</span><br><span class="line"></span><br><span class="line"> # 使用 `sudo` 时不需要输入密码，一般不这样做，不太安全</span><br><span class="line">ben  ALL=(ALL)  NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"> # 指定可以通过 `sudo` 执行的命令的白名单。</span><br><span class="line"> # 多个命令之间用 `, ` 分隔。</span><br><span class="line"> # 命令必须写全路径，执行时也一样。为的是避免其他路径的同名命令被执行。</span><br><span class="line"> # `!` 表示禁止执行。</span><br><span class="line">%example  ALL=/sbin/mount /mnt/example, !/sbin/umount /mnt/example</span><br></pre></td></tr></table></figure>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>concatenate 显示文件内容。</p>
<p><code>cat {file1} [{file2}]...</code><br>显示一个或多个文件的内容。对于多个文件，会将内容拼接起来显示。</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定目录的内容，缺省参数为当前目录。</p>
<p><code>-a</code> <code>--all</code> 显示 dot 文件。<br><code>-A</code> <code>--almost-all</code> 显示 dot 文件，除了 . 和 ..。<br><code>--block-size=[K|M|G|T|P|E|Z|Y]</code> 定义显示文件大小的单位。<br><code>-c</code> 结合 <code>-lt</code>：显示最近修改时间，并按其排序；结合 <code>-l</code>：显示最近修改时间，按文件名排序；否则按最近修改时间排序。<br><code>-d</code> <code>--directory</code> 显示文件夹本身，而不是它的内容。<br><code>-F</code> 显示文件类型信息。<br><code>-hide={pattern}</code> 不显示匹配的文件。<br><code>-i</code> <code>--inode</code> 显示文件的 inode 号。<br><code>-I</code> <code>--ignore={pattern}</code> 不显示匹配的文件。<br><code>-l</code> 显示详细的列表。<br><code>-L</code> 当显示符号链接的文件信息时，显示符号链接指向的对象而非链接本身的信息。<br><code>-n</code> <code>--numeric-uid-gid</code> 类似 <code>-l</code>，但显示用户和用户组的 ID。<br><code>-o</code> 类似 <code>-l</code>，但不显示组信息。<br><code>-r</code> 反向排序。<br><code>-R</code> <code>--recursive</code> 递归显示子目录。<br><code>-S</code> 按文件大小排序。<br><code>-t</code> 按修改时间排序，由新到旧。<br><code>-u</code> 结合 <code>-lt</code>：显示最近打开时间并按其排序；结合 <code>-l</code>：显示最近打开时间，并按文件名排序；否则，按最近打开时间排序。<br><code>-U</code> 不排序。<br><code>-w</code> <code>--width={cols}</code> 定义屏幕宽度。<br><code>-X</code> 按扩展名的字母顺序排序。</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件。</p>
<p><code>cp {file1} {file2}</code><br>将 file1 复制到 file2。<br><code>cp {file1} ... {file2} {dir}</code><br>将文件复制到指定目录。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>重命名或移动文件。</p>
<p><code>mv {file1} {file2}</code><br>将 file1 重命名为 file2。<br><code>mv {file1} ... {file2} {dir}</code><br>将文件移动到指定目录。</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><blockquote>
<p>创建文件。若文件已存在则更新时间戳。</p>
</blockquote>
<p><code>touch {file}</code></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><blockquote>
<p>删除文件。</p>
</blockquote>
<p><code>rm {file}</code></p>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>将它的参数显示到标准输出。</p>
<p><code>echo {variable}</code></p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><blockquote>
<p>设置当前工作目录。当前工作目录是指进程和 shell 当前所在的工作目录。</p>
</blockquote>
<p><code>cd {dir}</code></p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><blockquote>
<p>创建新目录。</p>
</blockquote>
<p><code>mkdir {dir}</code></p>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><blockquote>
<p>删除目录，只能删除空目录。</p>
</blockquote>
<p><code>rmdir {dir}</code><br>删除指定目录。<br><code>rm -rf {dir}</code><br>删除指定目录及其中所有内容。</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><blockquote>
<p>显示文件和输入流中和参数匹配的行。可识别正则表达式。</p>
</blockquote>
<p><code>grep -[i][v] {keyword} {file}</code><br>-i 表示不区分大小写，-v 表示反转匹配，即显示所有不匹配的行。</p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分屏显示文件内容。</p>
<p><code>less</code> 命令是 <code>more</code> 命令的增强版，在一些没有 <code>less</code> 命令的 Unix 系统和嵌入式系统中可以使用 <code>more</code> 命令。</p>
<p>大部分移动命令同 vim，包括标记跳转。</p>
<p><code>less [opt] {file}...</code></p>
<ul>
<li><code>-b {bufferSize}</code> 缓冲区大小。</li>
<li><code>-e</code> 文件显示结束后自动离开。</li>
<li><code>-f</code> 强制打开特殊文件，如外围设备代号、目录和二进制文件。</li>
<li><code>-g</code> 只标识最后搜索的关键词。</li>
<li><code>-i</code> 搜索忽略大小写。</li>
<li><code>-m</code> 显示类似 <code>more</code> 的百分比。</li>
<li><code>-N</code> 显示行号。</li>
<li><code>-o {file}</code> 将 less 输出内容保存到指定文件。</li>
<li><code>-Q</code> 不使用警告音。</li>
<li><code>-s</code> 将连续空行显示为一行。</li>
<li><code>-S</code> 舍弃行的超长部分。</li>
<li><p><code>-x {n}</code> 将 <code>{tab}</code> 显示为 n 个空格。</p>
</li>
<li><p><code>/{str}</code> <code>?{str}</code> 向下/上搜索字符串。</p>
</li>
<li><code>n</code> <code>N</code> 重复/反向重复上一次搜索。</li>
<li><code>y</code> <code>&lt;enter&gt;</code> 上/下滚一行。</li>
<li><code>u</code> <code>d</code> 上/下滚半页。</li>
<li><code>b</code> <code>&lt;space&gt;</code> 上/下滚一页。</li>
<li><code>&lt;pageup&gt;</code> <code>&lt;pagedown&gt;</code> 向上/下滚一页。</li>
<li><code>:n</code> <code>:p</code> 下/上一个文件。</li>
<li><code>Q</code> 推出 <code>less</code>。</li>
<li><code>h</code> 帮助。</li>
</ul>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><blockquote>
<p>输出当前的工作目录名。</p>
</blockquote>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><blockquote>
<p>查看两个文件之间的不同。</p>
</blockquote>
<p><code>diff {file1} {file2}</code></p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><blockquote>
<p>查看文件的格式信息。</p>
</blockquote>
<p><code>file {file}</code></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote>
<p>查找文件。可以使用模式匹配参数，但必须给模式匹配参数加引号，因为 shell 会在运行命令前展开通配符。</p>
</blockquote>
<p><code>find {dir} -name {file} -print</code></p>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><blockquote>
<p>在系统创建的文件索引中查找文件。该索引由系统周期性地进行更新。</p>
</blockquote>
<p><strong>head</strong> 和 <strong>tail</strong></p>
<blockquote>
<p>显示文件的前 10 行或后 10 行内容。</p>
</blockquote>
<p><code>head|tail [-{n}|+{n}][-f] {file}</code><br>-n 设置显示的行数，+n 设置显示第 n 行开始的内容，-f 设置不停地读取最新内容。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote>
<p>将文件内的所有行按照字母顺序快速排序。-n 按照数字顺序排序那些以数字开始的行，-r 反向排序。</p>
</blockquote>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><blockquote>
<p>将某个 shell 变量设置为环境变量。</p>
</blockquote>
<p><code>export {var}</code></p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h3 id="command-–help-h"><a href="#command-–help-h" class="headerlink" title="{command} –help|-h"></a>{command} –help|-h</h3><h3 id="info-command"><a href="#info-command" class="headerlink" title="info {command}"></a>info {command}</h3><blockquote>
<p>获取在线帮助。</p>
</blockquote>
<p><code>man [-k] {command}</code><br>获取指定命令的帮助信息，可指定关键词进行查找。</p>
<h3 id="command-gt-file"><a href="#command-gt-file" class="headerlink" title="{command} &gt; {file}"></a>{command} &gt; {file}</h3><h3 id="command-gt-gt-file"><a href="#command-gt-gt-file" class="headerlink" title="{command} &gt;&gt; {file}"></a>{command} &gt;&gt; {file}</h3><h3 id="command-command"><a href="#command-command" class="headerlink" title="{command} | {command}"></a>{command} | {command}</h3><h3 id="command-2-gt-file"><a href="#command-2-gt-file" class="headerlink" title="{command} 2&gt; {file}"></a>{command} 2&gt; {file}</h3><h3 id="command-gt-file-2-gt-amp-1"><a href="#command-gt-file-2-gt-amp-1" class="headerlink" title="{command} &gt; {file} 2&gt;&amp;1"></a>{command} &gt; {file} 2&gt;&amp;1</h3><h3 id="command-lt-file"><a href="#command-lt-file" class="headerlink" title="{command} &lt; {file}"></a>{command} &lt; {file}</h3><blockquote>
<p><code>&gt;</code>将执行结果重定向至文件（缺省为终端屏幕），如果文件不存在，shell 会创建新文件；如果文件存在，shell 会先清空文件内容。bash 中可以通过设置参数<code>set -C</code>来防止清空。<br><code>&gt;&gt;</code>将执行结果重定向至文件末尾。<br><code>|</code>将执行结果作为后一个命令的输入。<br><code>2&gt;</code>重定向标准错误输出。2 是由 shell 修改的流 ID，1 是标准输出，2 是标准错误输出。<br><code>&gt;&amp;</code>将标准输出和标准错误输出重定向到同一个地方。<br><code>&lt;</code>将文件内容重定向为命令的标准输入。</p>
</blockquote>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><blockquote>
<p>查看文件和目录的磁盘使用空间。</p>
</blockquote>
<p><code>du -sh ./*</code><br>显示当前目录下所有文件和目录的磁盘使用情况。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod [ops] {xyz} {path}</code></p>
<ul>
<li><code>-R</code> 对目录内部递归执行。</li>
<li><code>{xyz}</code> 依次对应拥有者、拥有者所在组、其他用户。rwx 641。</li>
</ul>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown [ops] {userOrGroup} {path}</code></p>
<ul>
<li><code>{userOrGroup}</code> 用户名或组名。</li>
<li><code>-c</code> 若拥有者确实发生更改才显示更改动作。</li>
<li><code>-f</code> 若拥有者无法更改，不显示错误信息。</li>
<li><code>-h</code> 更改链接本身，而不是它指向的路径。</li>
<li><code>-v</code> 显示详情。</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>ps</strong></p>
<p>列出所有正在运行的进程。</p>
<p>PID：进程 ID。<br>TTY：进程所在的终端设备。<br>STAT：进程在内存中的状态。完整状态列表参阅帮助手册。<br>TIME：进程占用 CPU 的总时长。<br>COMMAND：命令名，进程有可能将其由初始值改为其他。</p>
<ul>
<li><code>ps x</code> 显示当前用户运行的所有进程。</li>
<li><code>ps ax</code> 显示系统当前运行的所有进程，包括其他用户的进程。</li>
<li><code>ps u</code> 显示更详细的进程信息。</li>
<li><code>ps w</code> 显示命令的全名，而非仅显示一行以内的内容。</li>
<li><code>ps {PID}</code> 显示指定进程的信息，可用 $$ 表示当前 shell 的进程。</li>
</ul>
<p><strong>kill</strong></p>
<p>向进程发送一个信号。</p>
<p><code>kill [-{SIG}] {PID}</code><br>{SIG} 是具体的信号。缺省是 <code>TERM</code>。<code>STOP</code> 表示暂停，<code>CONT</code> 表示继续，<code>INT</code> 或 <code>CTRL-C</code> 表示中断，<code>KILL</code> 表示强行终止。也可使用数字代替信号名。</p>
<ul>
<li><code>KILL</code> 在内核层面立即终止进程，该信号不能被阻塞、处理或忽略。</li>
<li><code>INT</code> 通知前台进程组终止进程。</li>
<li><code>QUIT</code> 和 INT 类似, 但由 QUIT 字符(通常是 <code>Ctrl-\</code>)来控制。进程在因收到 QUIT 退出时会产生 core 文件, 在这个意义上类似于一个程序错误信号。</li>
<li><code>TERM</code> 要求进程自己正常退出，该信号可以被阻塞或处理。</li>
</ul>
<h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">星号</td>
<td style="text-align:left">正则表达式，通用字符</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">句点</td>
<td style="text-align:left">当前目录，文件/主机名的分隔符</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">感叹号</td>
<td style="text-align:left">逻辑非运算符，命令历史</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">管道</td>
<td>命令管道</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">斜线</td>
<td style="text-align:left">命令分隔符，搜索命令</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">反斜线</td>
<td style="text-align:left">常量，宏（非目录）</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">美元符号</td>
<td style="text-align:left">变量符号，行尾</td>
</tr>
<tr>
<td style="text-align:left">‘</td>
<td style="text-align:left">单引号</td>
<td style="text-align:left">字符串常量</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">反引号</td>
<td style="text-align:left">命令替换</td>
</tr>
<tr>
<td style="text-align:left">“</td>
<td style="text-align:left">双引号</td>
<td style="text-align:left">半字符串常量</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">脱字符</td>
<td style="text-align:left">逻辑非运算，行头</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">波浪字符</td>
<td style="text-align:left">逻辑非运算符，目录快捷方式</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">井号</td>
<td style="text-align:left">注释，预处理，替换</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">方括号</td>
<td style="text-align:left">范围</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">大括号</td>
<td style="text-align:left">声明块，范围</td>
</tr>
<tr>
<td style="text-align:left">_</td>
<td style="text-align:left">下划线</td>
<td style="text-align:left">空格的简单替代</td>
</tr>
</tbody>
</table>
<p>控制键 CTRL 通常用 ^ 来表示。</p>
<h1 id="命令行按键"><a href="#命令行按键" class="headerlink" title="命令行按键"></a>命令行按键</h1><table>
<thead>
<tr>
<th style="text-align:left">按键</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CTRL-B</td>
<td style="text-align:left">左移光标</td>
</tr>
<tr>
<td style="text-align:left">CTRL-F</td>
<td style="text-align:left">右移光标</td>
</tr>
<tr>
<td style="text-align:left">CTRL-P</td>
<td style="text-align:left">查看上一条命令（或上移光标）</td>
</tr>
<tr>
<td style="text-align:left">CTRL-N</td>
<td style="text-align:left">查看下一条命令（或下移光标）</td>
</tr>
<tr>
<td style="text-align:left">CTRL-A</td>
<td style="text-align:left">移动光标至行首</td>
</tr>
<tr>
<td style="text-align:left">CTRL-E</td>
<td style="text-align:left">移动光标至行尾</td>
</tr>
<tr>
<td style="text-align:left">CTRL-W</td>
<td style="text-align:left">删除前一个词</td>
</tr>
<tr>
<td style="text-align:left">CTRL-U</td>
<td style="text-align:left">删除从光标至行首的内容</td>
</tr>
<tr>
<td style="text-align:left">CTRL-K</td>
<td style="text-align:left">删除从光标至行尾的内容</td>
</tr>
<tr>
<td style="text-align:left">CTRL-Y</td>
<td style="text-align:left">粘贴已删除的文本</td>
</tr>
</tbody>
</table>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="安装配置文件"><a href="#安装配置文件" class="headerlink" title="安装配置文件"></a>安装配置文件</h2><p>kickstart<br>/root/anaconda-ks.cfg</p>
<h2 id="yum-代理"><a href="#yum-代理" class="headerlink" title="yum 代理"></a>yum 代理</h2><p><code>sudo vi /etc/yum.conf</code></p>
<p>加入<br>proxy=<a href="http://{host}:{port}" target="_blank" rel="noopener">http://{host}:{port}</a><br>proxy_username=abc<br>proxy_password=123</p>
<h2 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h2><ol>
<li><code>sudo vi /etc/profile</code></li>
<li>加上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://&#123;user&#125;:&#123;pwd&#125;@&#123;host&#125;:&#123;port&#125;</span><br><span class="line">export http_proxy</span><br></pre></td></tr></table></figure>
<h2 id="添加到-dock-栏"><a href="#添加到-dock-栏" class="headerlink" title="添加到 dock 栏"></a>添加到 dock 栏</h2><ol>
<li><p>创建 <code>.desktop</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env xdg-open</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line"># 若是脚本且想看到命令行则改为 true</span><br><span class="line">Terminal=false</span><br><span class="line"># 必须，填启动文件路径，后面可加启动参数</span><br><span class="line">Exec=command to run here</span><br><span class="line"># 必须，用于搜索和显示</span><br><span class="line">Name=visible name here</span><br><span class="line">Comment=comment here</span><br><span class="line">Icon=icon path here</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加到桌面。把上述文件移至桌面。</p>
</li>
<li>添加到 dock 栏和 app 搜索。把上述文件移至 <code>~/.local/share/applications/</code>。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="FATAL-Could-not-read-from-Boot-Medium-System-Halted"><a href="#FATAL-Could-not-read-from-Boot-Medium-System-Halted" class="headerlink" title="FATAL:Could not read from Boot Medium! System Halted."></a><code>FATAL:Could not read from Boot Medium! System Halted.</code></h2><p>解决：虚拟机设置-存储-删除多余的控制器</p>
<h2 id="参数风格"><a href="#参数风格" class="headerlink" title="参数风格"></a>参数风格</h2><ol>
<li>参数用一横的说明后面的参数是字符形式。</li>
<li>参数用两横的说明后面的参数是单词形式。</li>
<li>参数前有横的是 System V 风格。</li>
<li>参数前没有横的是 BSD 风格。</li>
</ol>
<h2 id="Failed-to-open-EFI-BOOT-grubx64-efi-Not-Found"><a href="#Failed-to-open-EFI-BOOT-grubx64-efi-Not-Found" class="headerlink" title="Failed to open \EFI\BOOT\grubx64.efi - Not Found"></a>Failed to open \EFI\BOOT\grubx64.efi - Not Found</h2><ol>
<li>挂载 centos 的 iso，进入 rescue 模式。</li>
<li><code>cd /mnt/sysimage/boot/efi/EFI</code></li>
<li><code>cp centos/grubx64.efi ../boot/</code></li>
<li><code>reboot</code></li>
</ol>
<h2 id="vdi-迁移"><a href="#vdi-迁移" class="headerlink" title="vdi 迁移"></a>vdi 迁移</h2><p><code>VBoxManage internalcommands sethduuid H:\virtualSys\ubuntu.vdi</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Design Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Design Pattern/" itemprop="url">Design Pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，而不是实现</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>类应该对扩展开放，对修改关闭</li>
<li>依赖抽象，不要依赖具体类</li>
<li>只和朋友交谈</li>
<li>别找我，我会找你</li>
<li>一个类应该只有一个引起变化的原因</li>
</ul>
<h1 id="最小知识原则"><a href="#最小知识原则" class="headerlink" title="最小知识原则"></a>最小知识原则</h1><p>对于任何一个对象，应设计成只跟<strong>尽量少</strong>的其他对象进行交互。</p>
<p>在一个对象的方法内，只应该调用属于以下范围的方法：</p>
<ul>
<li>该对象本身</li>
<li>被当作方法的参数而传递进来的对象</li>
<li>此方法创建的对象</li>
<li>该对象持有的组件</li>
</ul>
<p>不推荐的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public float getPrice() &#123;</span><br><span class="line">    Car car = shop.getCar(&quot;BMW&quot;);</span><br><span class="line">    return car.getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>推荐的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public float getPrice() &#123;</span><br><span class="line">    return shop.getPrice(&quot;BMW&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优点：减少对象之间的耦合，减少维护成本。<br>缺点：产生额外的包装类，增加开发时间，降低运行时性能。</p>
<h1 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h1><blockquote>
<p>别调用我们，我们会调用你。</p>
</blockquote>
<p>系统组件之间应形成高低关系，其中高层组件可以决定是否调用低层组件，而低层组件不能调用高层组件。<br>这样使得依赖关系形成单调的趋势，而不是循环依赖。</p>
<h1 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h1><blockquote>
<p>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<h1 id="观察者模式-Subject-amp-Observer"><a href="#观察者模式-Subject-amp-Observer" class="headerlink" title="观察者模式 Subject &amp; Observer"></a>观察者模式 Subject &amp; Observer</h1><blockquote>
<p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
</blockquote>
<h1 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式 Decorator"></a>装饰者模式 Decorator</h1><blockquote>
<p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
</blockquote>
<h1 id="工厂方法模式-Factory"><a href="#工厂方法模式-Factory" class="headerlink" title="工厂方法模式 Factory"></a>工厂方法模式 Factory</h1><p><strong>工厂方法</strong></p>
<blockquote>
<p>使用继承，把对象的创建委托给子类，父类提供抽象的创建方法。</p>
</blockquote>
<p><strong>抽象工厂方法</strong></p>
<blockquote>
<p>使用组合，向消费者提供一个工厂接口类型，该接口中含有抽象的创建方法。通过向消费者传入具体的工厂接口实现来得到不同的创建方法。这个工厂接口本身通常就使用了工厂方法的设计模式。</p>
</blockquote>
<h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h1><blockquote>
<p>确保一个类只有一个实例，并提供一个全局访问点。</p>
</blockquote>
<p>单线程中的简单做法，在多线程中会有并发问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private static MyClass myClassSingleton;</span><br><span class="line">    private MyClass() &#123;&#125;</span><br><span class="line">    public static MyClass getInstance() &#123;</span><br><span class="line">        if (myClassSingleton == null) &#123;</span><br><span class="line">            myClassSingleton = new MyClass();</span><br><span class="line">        &#125;</span><br><span class="line">        return myClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决并发问题的简单方法，但在频繁调用的情况下会严重影响性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private static MyClass myClassSingleton;</span><br><span class="line">    private MyClass() &#123;&#125;</span><br><span class="line">    public static synchronized MyClass getInstance() &#123;</span><br><span class="line">        if (myClassSingleton == null) &#123;</span><br><span class="line">            myClassSingleton = new MyClass();</span><br><span class="line">        &#125;</span><br><span class="line">        return myClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“饿汉”模式，在静态初始化器中创建单件，利用 JVM 自身的特性保证了线程安全，在 JVM 加载这个类时就创建了单件实例，从而保证在任何线程访问该实例前就已经创建完毕。<br>若有大量使用概率很低的单例类使用“饿汉”模式，会造成明显的内存浪费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private static MyClass myClassSingleton = new MyClass();//加载类时创建实例</span><br><span class="line">    private MyClass() &#123;&#125;</span><br><span class="line">    public static MyClass getInstance() &#123;</span><br><span class="line">        return myClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“饱汉”模式，只在第一次访问单例时创建单例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    //volatile 关键词确保 myClassSingleton 赋值时能立即对所有线程可见。在 Java 1.4 及之前的版本中 volatile 实现有问题。</span><br><span class="line">    private volatile static MyClass myClassSingleton；</span><br><span class="line">    private MyClass() &#123;&#125;</span><br><span class="line">    public static MyClass getInstance() &#123;</span><br><span class="line">        if ( myClassSingleton == null) &#123; //double check 解决多线程并发问题</span><br><span class="line">            synchronized (MyClass.class) &#123;</span><br><span class="line">                if (myClassSingleton == null) &#123;</span><br><span class="line">                    myClassSingleton = new MyClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return myClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若程序中使用了多个类加载器（Class Loader），会产生多个单例</strong></p>
<p><strong>在 Java 1.2 之前，GC 有个 bug，当单例对象只被自身的类所引用时，会被 GC 清理</strong></p>
<h1 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h1><blockquote>
<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>本质上是在调用者和接收者之间加了一层用于命令的整合、转换、映射，从而实现调用者和接收者之间的解耦。</p>
</blockquote>
<h1 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h1><blockquote>
<p>将一个类的接口，转换成客户期望的另一个接口，从而让原本不兼容的类之间可以兼容。</p>
</blockquote>
<h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h1><blockquote>
<p>外观模式提供了一个统一的接口，用来方法子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用</p>
</blockquote>
<p>外观模式和适配器模式类似，都是在不同接口方法之间建立映射关系。<br>其中适配器模式着重<strong>转换</strong>，而外观模式着重于<strong>简化</strong>。</p>
<h1 id="模板方法模式-Template"><a href="#模板方法模式-Template" class="headerlink" title="模板方法模式 Template"></a>模板方法模式 Template</h1><blockquote>
<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<h1 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h1><blockquote>
<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
</blockquote>
<p>外部迭代器：客户自己通过调用 next 方法进行游走，并在游走的过程中进行处理。<br>内部迭代器：游走过程由迭代器自行完成，客户无法干预，且必须将游走过程中需要处理的逻辑传给迭代器。</p>
<h1 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h1><blockquote>
<p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及组合对象。</p>
</blockquote>
<h1 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h1><blockquote>
<p>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
</blockquote>
<p>和策略模式一样，都是在一个接口下用不同的类封装不同的逻辑。区别在于策略模式一般由调用者直接或间接指定某个逻辑；而状态模式在内部进行策略转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/XML/XML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/XML/XML/" itemprop="url">XML</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>XML</p>
<blockquote>
<p>可扩展标记语言（eXtensible Markup Language）</p>
</blockquote>
<p>XML 元素</p>
<blockquote>
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。<br>一个元素可以包含：其他元素、文本、属性，或混合以上所有…</p>
</blockquote>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>声明部分 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</code> 可选，如果存在须放第一行；<ul>
<li><code>standalone=&quot;yes&quot;</code> 表示该 XML 文档独立，不能引用外部的 DTD 规范文件，反之则非独立，可以引用外部规范文件。</li>
</ul>
</li>
<li>XML 标签<ul>
<li>所有元素都必须有关闭标签；</li>
<li>XML 标签对大小写敏感；</li>
<li>所有标签都必须正确嵌套；</li>
</ul>
</li>
<li>XML 元素<ul>
<li>必须包含<strong>根元素</strong>，它是所有其他元素的父元素；</li>
<li>XML 元素中 <code>&lt;</code> 和 <code>&amp;</code> 是非法的，必须用实体引用来替代：<ul>
<li>预定义实体引用 - 对应符号 - 含义</li>
<li><code>&amp;lt;</code> - <code>&lt;</code> - less than</li>
<li><code>&amp;gt;</code> - <code>&gt;</code> - greater than</li>
<li><code>&amp;amp;</code> - <code>&amp;</code> - ampersand</li>
<li><code>&amp;apos;</code> - <code>&#39;</code> - apostrophe</li>
<li><code>&amp;quot;</code> - <code>&quot;</code> - quotation mark</li>
</ul>
</li>
<li>XML 元素必须遵循以下命名规则：<ul>
<li>名称可以包含字母、数字以及其他的字符；</li>
<li>名称不能以数字或者标点符号开始；</li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始；</li>
<li>名称不能包含空格；</li>
<li>可使用任何名称，没有保留的字词。</li>
</ul>
</li>
</ul>
</li>
<li>XML 属性<ul>
<li>属性值必须加引号，单双引号皆可。若属性值中本身就含有单引号或双引号，则包裹属性值的引号必须用另一种，或将属性值中的引号用实体引用 <code>&amp;apos;</code> 和 <code>&amp;quot;</code> 替代；</li>
<li>属性不能包含多个值（元素可以）；</li>
<li>属性不能包含树结构（元素可以）；</li>
<li>属性不容易扩展；</li>
</ul>
</li>
<li>元数据应当存储为属性，数据本身应当存储为元素</li>
<li>注释 <code>&lt;!-- This is a comment --&gt;</code>;</li>
<li>XML 会保留连续的多个空格，而不会裁剪为一个；</li>
<li>XML 以 <code>LF</code> 存储换行。</li>
</ul>
<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><ol>
<li>CSS <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第二行的声明把 XML 文件链接到 CSS 文件。</p>
<ol>
<li>XSLT //TODO<blockquote>
<p>eXtensible Stylesheet Language Transformations<br>XSLT 是首选的 XML 样式表语言，它在浏览器显示 XML 文件之前，先把它转换为 HTML。</p>
</blockquote>
</li>
</ol>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>命名空间是在元素的开始标签的 xmlns 属性中定义的。<br>命名空间声明的语法：<code>xmlns:前缀=&quot;URI&quot;</code>。<br>可以为元素定义默认的命名空间来省去在所有子元素中使用前缀的工作：<code>xmlns=&quot;URI</code>。</p>
<h1 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h1><ol>
<li>CDATA - （未解析）字符数据 character data<br>术语 CDATA 是不应该由 XML 解析器解析的文本数据。<br>像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。”&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始。<br>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。<br>CDATA 部分中的所有内容都会被解析器忽略，而不会去解析其中的标签和实体引用，从而被当作普通文本来处理。<br>CDATA 部分由 <code>&lt;![CDATA[</code> 开始，由 <code>]]&gt;</code> 结束。<br>CDATA 部分不能包含字符串 <code>]]&gt;</code>。也不允许嵌套的 CDATA 部分。<br>标记 CDATA 部分结尾的 <code>]]&gt;</code> 不能包含空格或换行。</li>
<li>PCDATA - 被解析的字符数据 parsed character data<br>XML 解析器通常会解析 XML 文档中所有的文本。PCDATA 是相对于 CDATA 而言的。</li>
</ol>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>在载入一个 XML 文档时可能得到两个不同的错误，表示编码问题：</p>
<ol>
<li>在文本内容中发现无效字符。<br>如果 XML 中包含非 ASCII 字符，且文件保存为没有指定编码的单字节 ANSI（或 ASCII），就会得到该错误。</li>
<li>将当前编码切换为不被支持的指定编码<br>如果 XML 文件保存为带有指定的单字节编码（WINDOWS-1252、ISO-8859-1、UTF-8）的双字节 Unicode（或 UTF-16），就会得到该错误。<br>如果 XML 文件保存为带有指定的双字节编码（UTF-16）的单字节 ANSI（或 ASCII），也会得到该错误。</li>
</ol>
<p>结论：</p>
<ul>
<li>始终使用编码属性</li>
<li>使用支持编码的编辑器</li>
<li>确保知道编辑器使用什么编码</li>
<li>在编码属性中使用相同的编码</li>
</ul>
<h1 id="XML相关技术"><a href="#XML相关技术" class="headerlink" title="XML相关技术"></a>XML相关技术</h1><p>XHTML (可扩展 HTML) </p>
<blockquote>
<p>更严格更纯净的基于 XML 的 HTML 版本。</p>
</blockquote>
<p>XML DOM (XML 文档对象模型)</p>
<blockquote>
<p>访问和操作 XML 的标准文档模型。</p>
</blockquote>
<p>XSL (可扩展样式表语言)，包含三个部分：</p>
<blockquote>
<ol>
<li>XSLT (XSL 转换) - 把 XML 转换为其他格式，比如 HTML</li>
<li>XSL-FO (XSL 格式化对象)- 用于格式化 XML 文档的语言</li>
<li>XPath - 用于导航 XML 文档的语言</li>
</ol>
</blockquote>
<p>XQuery (XML 查询语言)</p>
<blockquote>
<p>基于 XML 的用于查询 XML 数据的语言。</p>
</blockquote>
<p><a href="#DTD">DTD</a> (文档类型定义)</p>
<blockquote>
<p>用于定义 XML 文档中的合法元素的标准。</p>
</blockquote>
<p><a href="#XSD">XSD</a> (XML 架构)</p>
<blockquote>
<p>基于 XML 的 DTD 替代物。</p>
</blockquote>
<p>XLink (XML 链接语言)</p>
<blockquote>
<p>在 XML 文档中创建超级链接的语言。</p>
</blockquote>
<p>XPointer (XML 指针语言)</p>
<blockquote>
<p>允许 XLink 超级链接指向 XML 文档中更多具体的部分。</p>
</blockquote>
<p>SOAP (简单对象访问协议)</p>
<blockquote>
<p>允许应用程序在 HTTP 之上交换信息的基于 XML 的协议。</p>
</blockquote>
<p>WSDL (Web 服务描述语言)</p>
<blockquote>
<p>用于描述网络服务的基于 XML 的语言。</p>
</blockquote>
<p>RDF (资源描述框架)</p>
<blockquote>
<p>用于描述网络资源的基于 XML 的语言。</p>
</blockquote>
<p>RSS (真正简易聚合)</p>
<blockquote>
<p>聚合新闻以及类新闻站点内容的格式。</p>
</blockquote>
<p>SVG (可伸缩矢量图形) </p>
<blockquote>
<p>定义 XML 格式的图形</p>
</blockquote>
<h1 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h1><p><a href="#XML相关技术">back</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
</blockquote>
<p><strong>内部的 DOCTYPE 声明</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>!DOCTYPE note</code> (第二行)定义此文档是 note 类型的文档。</li>
<li><code>!ELEMENT note</code> (第三行)定义 note  元素有四个元素：”to、from、heading,、body”</li>
<li><code>!ELEMENT to</code> (第四行)定义 to 元素为 “#PCDATA” 类型</li>
<li><code>!ELEMENT from</code> (第五行)定义 from 元素为 “#PCDATA” 类型</li>
<li><code>!ELEMENT heading</code> (第六行)定义 heading 元素为 “#PCDATA” 类型</li>
<li><code>!ELEMENT body</code> (第七行)定义 body 元素为 “#PCDATA” 类型</li>
</ul>
<p><strong>外部文档声明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>
<p><strong>为什么使用 DTD</strong></p>
<ul>
<li>通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。</li>
<li>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</li>
<li>应用程序可使用某个标准的 DTD 来验证从外部接收到的数据。</li>
<li>可以使用 DTD 来验证自身的数据。</li>
</ul>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>在 DTD 中，XML 元素通过元素声明来进行声明：<br><code>&lt;!ELEMENT element-name category&gt;</code><br>或<br><code>&lt;!ELEMENT element-name (element-content)&gt;</code></p>
<ol>
<li>空元素<br>空元素通过类别关键词 <code>EMPTY</code> 来声明<br><code>&lt;!ELEMENT element-name EMPTY&gt;</code></li>
<li>只有 PCDATA 的元素<br>只有 PCDATA 的元素通过圆括号中的 <code>#PCDATA</code> 进行声明<br><code>&lt;!ELEMENT element-name (#PCDATA)&gt;</code></li>
<li>带有任何内容的元素<br>通过类别关键词 <code>ANY</code> 声明的元素，可包含任何可解析数据的组合<br><code>&lt;!ELEMENT element-name ANY&gt;</code></li>
<li>带有子元素（序列）的元素<br>带有一个或多个子元素的元素通过圆括号中的子元素名进行声明<br><code>&lt;!ELEMENT element-name (child1)&gt;</code><br>或<br><code>&lt;!ELEMENT element-name (child1,child2,...)&gt;</code><br>当子元素按照由逗号分隔开的序列进行声明时，这些子元素必须按照相同的顺序出现在文档中。在一个完整的声明中，子元素也必须被声明，同时子元素也可拥有子元素。</li>
<li>声明必须出现且只出现一次的元素<br><code>&lt;!ELEMENT element-name (child-name)&gt;</code></li>
<li>声明最少出现一次的元素<br><code>&lt;!ELEMENT element-name (child-name+)&gt;</code></li>
<li>声明出现零次或多次的元素<br><code>&lt;!ELEMENT element-name (child-name*)&gt;</code></li>
<li>声明出现零次或一次的元素<br><code>&lt;!ELEMENT element-name (child-name?)&gt;</code></li>
<li>声明”非…即…”类型的内容<br>实例: <code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code><br>上面的例子声明了：”note” 元素必须包含 “to” 元素、”from” 元素、”header” 元素，以及非 “message” 元素既 “body” 元素。</li>
<li>声明混合型的内容<br>实例: <code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code><br>上面的例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message”。</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在 DTD 中，属性通过 ATTLIST 声明来进行声明：<br><code>&lt;!ATTLIST {element-name} {attribute-name} attribute-type attribute-value&gt;</code><br>DTD 实例：<br><code>&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;</code><br>XML 实例：<br><code>&lt;payment type=&quot;check&quot; /&gt;</code></p>
<p>属性类型(attribute-type)的选项：</p>
<ul>
<li><code>CDATA</code>: 值为字符数据 (character data)</li>
<li><code>(en1|en2|..)</code>: 此值是枚举列表中的一个值</li>
<li><code>ID</code>: 值为唯一的 id</li>
<li><code>IDREF</code>: 值为另外一个元素的 id</li>
<li><code>IDREFS</code>: 值为其他 id 的列表</li>
<li><code>NMTOKEN</code>: 值为合法的 XML 名称</li>
<li><code>NMTOKENS</code>: 值为合法的 XML 名称的列表</li>
<li><code>ENTITY</code>: 值是一个实体</li>
<li><code>ENTITIES</code>: 值是一个实体列表</li>
<li><code>NOTATION</code>: 此值是符号的名称</li>
<li><code>xml:</code>: 值是一个预定义的 XML 值</li>
</ul>
<p>默认属性值可使用下列值 :</p>
<ul>
<li><code>#REQUIRED</code>: 属性值是必需的</li>
<li><code>#IMPLIED</code>: 属性不是必需的</li>
<li><code>#FIXED value</code>: 属性值是固定的</li>
</ul>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>
<ul>
<li>实体引用是对实体的引用。</li>
<li>实体可在内部或外部进行声明</li>
</ul>
<p>一个内部实体声明：<br><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code><br>DTD 实例:<br><code>&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</code><br><code>&lt;!ENTITY copyright &quot;Copyright W3CSchool.cc&quot;&gt;</code><br>XML 实例：<br><code>&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</code></p>
<p>一个外部实体声明：<br><code>&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</code><br>DTD 实例：<br><code>&lt;!ENTITY writer SYSTEM &quot;http://www.w3cschool.cc/entities.dtd&quot;&gt;</code><br><code>&lt;!ENTITY copyright SYSTEM &quot;http://www.w3cschool.cc/entities.dtd&quot;&gt;</code><br>XML 实例：<br><code>&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</code></p>
<h1 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h1><p><a href="#XML相关技术">back</a></p>
<blockquote>
<p>XML Schema 的作用是定义 XML 文档的合法构建模块，类似 DTD。</p>
<ul>
<li>定义可出现在文档中的元素</li>
<li>定义可出现在文档中的属性</li>
<li>定义哪个元素是子元素</li>
<li>定义子元素的次序</li>
<li>定义子元素的数目</li>
<li>定义元素是否为空，或者是否可包含文本</li>
<li>定义元素和属性的数据类型</li>
<li>定义元素和属性的默认值以及固定值</li>
</ul>
</blockquote>
<h2 id="schema-元素"><a href="#schema-元素" class="headerlink" title="schema 元素"></a>schema 元素</h2><p><strong><code>&lt;schema&gt;</code> 元素是每一个 XML Schema 的根元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">targetNamespace=&quot;http://www.runoob.com&quot;</span><br><span class="line">xmlns=&quot;http://www.runoob.com&quot;</span><br><span class="line">elementFormDefault=&quot;qualified&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</code><br>显示 schema 中用到的元素和数据类型来自命名空间 “<a href="http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间</a> “<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 的元素和数据类型应该使用前缀 xs</li>
<li><code>targetNamespace=&quot;http://www.runoob.com&quot;</code><br>显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li>
<li><code>xmlns=&quot;http://www.runoob.com&quot;</code><br>指出默认的命名空间是 “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li>
<li><code>elementFormDefault=&quot;qualified&quot;</code><br>指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定</li>
</ul>
<p><strong>在 XML 文档中引用 Schema</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;note xmlns=&quot;http://www.runoob.com&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.runoob.com note.xsd&quot;&gt;</span><br><span class="line">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>xmlns=&quot;http://www.runoob.com&quot;</code><br>规定了默认命名空间的声明。此声明会告知 schema 验证器，在此 XML 文档中使用的所有元素都被声明于 “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ 这个命名空间。</li>
<li>一旦拥有了可用的 XML Schema 实例命名空间：<br><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code><br>就可以使用 schemaLocation 属性了。此属性有两个值。第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置：<br><code>xsi:schemaLocation=&quot;http://www.runoob.com note.xsd&quot;</code></li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>字符串数据类型</strong></p>
<ul>
<li>字符串 String Data Type</li>
</ul>
<blockquote>
<p>字符串数据类型可包含字符、换行、回车以及制表符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;customer&quot; type=&quot;xs:string&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>规格化字符串 NormalizedString Data Type</li>
</ul>
<blockquote>
<p>规格化字符串数据类型同样可包含字符，但是 XML 处理器会移除折行，回车以及制表符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;customer&quot; type=&quot;xs:normalizedString&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Token 数据类型 Token Data Type</li>
</ul>
<blockquote>
<p>Token 数据类型同样可包含字符，但是 XML 处理器会移除换行符、回车、制表符、开头和结尾的空格以及（连续的）空格。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;customer&quot; type=&quot;xs:token&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串数据类型及衍生类型<br>|名称|描述|<br>|:–|:–|<br>|ENTITIES|<br>|ENTITY|<br>|ID|在 XML 中提交 ID 属性的字符串（仅与 schema 属性一同使用）|<br>|IDREF|在 XML 中提交 IDREF 属性的字符串（仅与 schema 属性一同使用）|<br>|IDREFS language|包含合法的语言 id 的字符串|<br>|Name|包含合法 XML 名称的字符串|<br>|NCName|<br>|NMTOKEN|在 XML 中提交 NMTOKEN 属性的字符串（仅与 schema 属性一同使用）|<br>|NMTOKENS|<br>|normalizedString|不包含换行符、回车或制表符的字符串|<br>|QName|<br>|string|字符串|<br>|token|不包含换行符、回车或制表符、开头或结尾空格或者多个连续空格的字符串|</li>
</ul>
<ul>
<li>对字符串数据类型的限定（Restriction）<br>可与字符串数据类型一同使用的限定：<ul>
<li>enumeration</li>
<li>length</li>
<li>maxLength</li>
<li>minLength</li>
<li>pattern (NMTOKENS、IDREFS 以及 ENTITIES 无法使用此约束)</li>
<li>whiteSpace</li>
</ul>
</li>
</ul>
<p><strong>日期和时间数据类型</strong></p>
<ul>
<li>日期 Date Data Type：”YYYY-MM-DD”<br><code>&lt;xs:element name=&quot;start&quot; type=&quot;xs:date&quot;/&gt;</code><ul>
<li>时区<ul>
<li>在日期后加一个 “Z” 的方式，使用世界调整时间（UTC time）来输入一个日期<br><code>&lt;start&gt;2002-09-24Z&lt;/start&gt;</code></li>
<li>在日期后添加一个正的或负时间的方法，来规定以世界调整时间为准的偏移量<br><code>&lt;start&gt;2002-09-24-06:00&lt;/start&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>时间 Time Data Type：”hh:mm:ss”<br><code>&lt;xs:element name=&quot;start&quot; type=&quot;xs:time&quot;/&gt;</code><ul>
<li>时区：同上</li>
</ul>
</li>
<li>日期时间 DateTime Data Type：”YYYY-MM-DDThh:mm:ss”，其中 T 表示必需的时间部分的起始<br><code>&lt;xs:element name=&quot;startdate&quot; type=&quot;xs:dateTime&quot;/&gt;</code><ul>
<li>时区：同上</li>
</ul>
</li>
<li>持续时间 Duration Data Type：”PnYnMnDTnHnMnS”，其中<ul>
<li>P 表示周期(必需)</li>
<li>nY 表示年数</li>
<li>nM 表示月数</li>
<li>nD 表示天数</li>
<li>T 表示时间部分的起始 -     （如果打算规定小时、分钟和秒，则此选项为必需）</li>
<li>nH 表示小时数</li>
<li>nM 表示分钟数</li>
<li>nS 表示秒数<br><code>&lt;xs:element name=&quot;period&quot; type=&quot;xs:duration&quot;/&gt;</code><br>例：<code>&lt;period&gt;P5Y2M10DT15H&lt;/period&gt;</code></li>
</ul>
</li>
<li>负的持续时间：在 P 前加减号</li>
<li>日期和时间数据类型<br>|名称|描述|<br>|:–|:–|<br>|date|定义一个日期值|<br>|dateTime|定义一个日期和时间值|<br>|duration|定义一个时间间隔|<br>|gDay|定义日期的一个部分 - 天 (DD)|<br>|gMonth|定义日期的一个部分 - 月 (MM)|<br>|gMonthDay|定义日期的一个部分 - 月和天 (MM-DD)|<br>|gYear|定义日期的一个部分 - 年 (YYYY)|<br>|gYearMonth|定义日期的一个部分 - 年和月 (YYYY-MM)|<br>|time|定义一个时间值|</li>
</ul>
<ul>
<li>对日期数据类型的限定（Restriction）<br>可与日期数据类型一同使用的限定：<ul>
<li>enumeration</li>
<li>maxExclusive</li>
<li>maxInclusive</li>
<li>minExclusive</li>
<li>minInclusive</li>
<li>pattern</li>
<li>whiteSpace</li>
</ul>
</li>
</ul>
<p><strong>数值数据类型</strong></p>
<ul>
<li>十进制：最大位数是 18 位<br><code>&lt;xs:element name=&quot;prize&quot; type=&quot;xs:decimal&quot;/&gt;</code></li>
<li>整数<br><code>&lt;xs:element name=&quot;prize&quot; type=&quot;xs:integer&quot;/&gt;</code></li>
<li>数值数据类型<br>|名字|秒数|<br>|:–|:–|<br>|byte|有正负的 8 位整数|<br>|decimal|十进制数|<br>|int|有正负的 32 位整数|<br>|integer|整数值|<br>|long|有正负的 64 位整数|<br>|negativeInteger|仅包含负值的整数 ( .., -2, -1.)|<br>|nonNegativeInteger|仅包含非负值的整数 (0, 1, 2, ..)|<br>|nonPositiveInteger|仅包含非正值的整数 (.., -2, -1, 0)|<br>|positiveInteger|仅包含正值的整数 (1, 2, ..)|<br>|short|有正负的 16 位整数|<br>|unsignedLong|无正负的 64 位整数|<br>|unsignedInt|无正负的 32 位整数|<br>|unsignedShort|无正负的 16 位整数|<br>|unsignedByte|无正负的 8 位整数|</li>
</ul>
<ul>
<li>对数值数据类型的限定（Restriction）<br>可与数值数据类型一同使用的限定：<ul>
<li>enumeration</li>
<li>fractionDigits</li>
<li>maxExclusive</li>
<li>maxInclusive</li>
<li>minExclusive</li>
<li>minInclusive</li>
<li>pattern</li>
<li>totalDigits</li>
<li>whiteSpace</li>
</ul>
</li>
</ul>
<p><strong>杂项数据类型</strong></p>
<blockquote>
<p>其他杂项数据类型包括布尔、base64Binary、十六进制、浮点、双精度、anyURI、anyURI 以及 NOTATION。</p>
</blockquote>
<ul>
<li>布尔 Boolean Data Type： 合法的布尔值是 true、false、1（表示 true） 以及 0（表示 false）<br><code>&lt;xs:attribute name=&quot;disabled&quot; type=&quot;xs:boolean&quot;/&gt;</code></li>
<li>二进制 Binary Data Types：<br><code>&lt;xs:element name=&quot;blobsrc&quot; type=&quot;xs:hexBinary&quot;/&gt;</code><ul>
<li>可使用两种二进制数据类型：<ul>
<li>base64Binary (Base64 编码的二进制数据)</li>
<li>hexBinary (十六进制编码的二进制数据)</li>
</ul>
</li>
</ul>
</li>
<li>AnyURI 数据类型 AnyURI Data Type：用于规定 URI；如果某个 URI 含有空格，请用 %20 替换它们<br><code>&lt;xs:attribute name=&quot;src&quot; type=&quot;xs:anyURI&quot;/&gt;</code></li>
<li>杂项数据类型<br>|名称|描述|<br>|:–|:–|<br>|anyURI|<br>|base64Binary|<br>|boolean|<br>|double|<br>|float|<br>|hexBinary|<br>|NOTATION|<br>|QName|</li>
</ul>
<ul>
<li>对杂项数据类型的限定（Restriction）<br>可与杂项数据类型一同使用的限定：<ul>
<li>enumeration (布尔数据类型无法使用此约束)</li>
<li>length (布尔数据类型无法使用此约束)</li>
<li>maxLength (布尔数据类型无法使用此约束)</li>
<li>minLength (布尔数据类型无法使用此约束)</li>
<li>pattern</li>
<li>whiteSpace</li>
</ul>
</li>
</ul>
<h2 id="简易元素"><a href="#简易元素" class="headerlink" title="简易元素"></a>简易元素</h2><blockquote>
<p>简易元素指那些仅包含文本的元素。它不会包含任何其他的元素或属性。<br>不过，“仅包含文本”这个限定却很容易造成误解。文本有很多类型。它可以是 XML Schema 定义中包括的类型中的一种（布尔、字符串、数据等等），或者它也可以是自行定义的定制类型。<br>也可向数据类型添加限定（即 facets），以此来限制它的内容，或者可以要求数据匹配某种特定的模式。</p>
</blockquote>
<p><strong>定义简易元素</strong><br><code>&lt;xs:element name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt;</code><br>最常用的类型是：</p>
<ul>
<li>xs:string</li>
<li>xs:decimal</li>
<li>xs:integer</li>
<li>xs:boolean</li>
<li>xs:date</li>
<li>xs:time</li>
</ul>
<p><strong>简易元素的默认值和固定值</strong><br>简易元素可拥有指定的默认值或固定值。<br>当没有其他的值被规定时，默认值就会自动分配给元素：<br><code>&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; default=&quot;red&quot;/&gt;</code><br>固定值同样会自动分配给元素，并且无法规定另外一个值：<br><code>&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; fixed=&quot;red&quot;/&gt;</code></p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><blockquote>
<p>所有的属性均作为简易类型来声明。简易元素无法拥有属性。假如某个元素拥有属性，它就会被当作某种复合类型。但是属性本身总是作为简易类型被声明的。</p>
</blockquote>
<p><strong>定义属性</strong><br><code>&lt;xs:attribute name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt;</code><br>最常用的类型是：</p>
<ul>
<li>xs:string</li>
<li>xs:decimal</li>
<li>xs:integer</li>
<li>xs:boolean</li>
<li>xs:date</li>
<li>xs:time</li>
</ul>
<p><strong>属性的默认值和固定值</strong><br>属性可拥有指定的默认值或固定值。<br>当没有其他的值被规定时，默认值就会自动分配给元素：<br><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; default=&quot;EN&quot;/&gt;</code><br>固定值同样会自动分配给元素，并且无法规定另外的值：<br><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; fixed=&quot;EN&quot;/&gt;</code></p>
<p><strong>可选的和必需的属性</strong><br>在缺省的情况下，属性是可选的。如需规定属性为必选，须使用 “use” 属性：<br><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</code></p>
<h2 id="限定-Facets"><a href="#限定-Facets" class="headerlink" title="限定 / Facets"></a>限定 / Facets</h2><blockquote>
<p>限定（restriction）用于为 XML 元素或者属性定义可接受的值。对 XML 元素的限定被称为 facet。</p>
</blockquote>
<p><strong>对值的限定</strong></p>
<p>下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;age&quot;&gt;</span><br><span class="line">  &lt;xs:simpleType&gt;</span><br><span class="line">    &lt;xs:restriction base=&quot;xs:integer&quot;&gt;</span><br><span class="line">      &lt;xs:minInclusive value=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;xs:maxInclusive value=&quot;120&quot;/&gt;</span><br><span class="line">    &lt;/xs:restriction&gt;</span><br><span class="line">  &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p><strong>对一组值的限定</strong></p>
<p>如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;car&quot;&gt;</span><br><span class="line">  &lt;xs:simpleType&gt;</span><br><span class="line">    &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">      &lt;xs:enumeration value=&quot;Audi&quot;/&gt;</span><br><span class="line">      &lt;xs:enumeration value=&quot;Golf&quot;/&gt;</span><br><span class="line">      &lt;xs:enumeration value=&quot;BMW&quot;/&gt;</span><br><span class="line">    &lt;/xs:restriction&gt;</span><br><span class="line">  &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子也可以被写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;car&quot; type=&quot;carType&quot;/&gt;</span><br><span class="line">&lt;xs:simpleType name=&quot;carType&quot;&gt;</span><br><span class="line">  &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Audi&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;Golf&quot;/&gt;</span><br><span class="line">    &lt;xs:enumeration value=&quot;BMW&quot;/&gt;</span><br><span class="line">  &lt;/xs:restriction&gt;</span><br><span class="line">&lt;/xs:simpleType&gt;</span><br></pre></td></tr></table></figure>
<p>注意： 在这种情况下，类型 “carType” 可被其他元素使用，因为它不是 “car” 元素的组成部分。</p>
<p><strong>对一系列值的限定</strong></p>
<p>如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot;&gt;</span><br><span class="line">    &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">            &lt;!-- 实际应用中取下列任一元素 --&gt;</span><br><span class="line">            &lt;!-- 只接受小写字母 a - z 其中的一个 --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;[a-z]&quot;/&gt;</span><br><span class="line">            &lt;!-- 只接受大写字母 A - Z 其中的三个 --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;[A-Z][A-Z][A-Z]&quot;/&gt;</span><br><span class="line">            &lt;!-- 只接受 a - z 中零个或多个字母 --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;([a-z])*&quot;/&gt;</span><br><span class="line">            &lt;!-- 只接受一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成 --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;([a-z][A-Z])+&quot;/&gt;</span><br><span class="line">            &lt;!-- 只接受 male 或者 female --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;male|female&quot;/&gt;</span><br><span class="line">            &lt;!-- 只接受由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9 --&gt;</span><br><span class="line">            &lt;xs:pattern value=&quot;[a-zA-Z0-9]&#123;8&#125;&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p><strong>对空白字符的限定</strong></p>
<p>如需规定对空白字符（whitespace characters）的处理方式，需要使用 whiteSpace 限定。<br>下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;address&quot;&gt;</span><br><span class="line">    &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">            &lt;!-- 实际应用中取下列任一元素 --&gt;</span><br><span class="line">            &lt;!-- 不会移除任何空白字符 --&gt;</span><br><span class="line">            &lt;xs:whiteSpace value=&quot;preserve&quot;/&gt;</span><br><span class="line">            &lt;!-- 将移除所有空白字符（换行、回车、空格以及制表符） --&gt;</span><br><span class="line">            &lt;xs:whiteSpace value=&quot;replace&quot;/&gt;</span><br><span class="line">            &lt;!-- 将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格） --&gt;</span><br><span class="line">            &lt;xs:whiteSpace value=&quot;collapse&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p><strong>对长度的限定</strong></p>
<p>如需限制元素中值的长度，需要使用 length、maxLength 以及 minLength 限定。<br>本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;password&quot;&gt;</span><br><span class="line">    &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">            &lt;!-- 值必须精确到 8 个字符 --&gt;</span><br><span class="line">            &lt;xs:length value=&quot;8&quot;/&gt;</span><br><span class="line">            &lt;!-- 值最小为 5 个字符，最大为 8 个字符 --&gt;</span><br><span class="line">            &lt;xs:minLength value=&quot;5&quot;/&gt;</span><br><span class="line">            &lt;xs:maxLength value=&quot;8&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:simpleType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p><strong>数据类型的限定</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">限定</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">enumeration</td>
<td style="text-align:left">定义可接受值的一个列表</td>
</tr>
<tr>
<td style="text-align:left">fractionDigits</td>
<td style="text-align:left">定义所允许的最大的小数位数。必须大于等于0。</td>
</tr>
<tr>
<td style="text-align:left">length</td>
<td style="text-align:left">定义所允许的字符或者列表项目的精确数目。必须大于或等于0。</td>
</tr>
<tr>
<td style="text-align:left">maxExclusive</td>
<td style="text-align:left">定义数值的上限。所允许的值必须小于此值。</td>
</tr>
<tr>
<td style="text-align:left">maxInclusive</td>
<td style="text-align:left">定义数值的上限。所允许的值必须小于或等于此值。</td>
</tr>
<tr>
<td style="text-align:left">maxLength</td>
<td style="text-align:left">定义所允许的字符或者列表项目的最大数目。必须大于或等于0。</td>
</tr>
<tr>
<td style="text-align:left">minExclusive</td>
<td style="text-align:left">定义数值的下限。所允许的值必需大于此值。</td>
</tr>
<tr>
<td style="text-align:left">minInclusive</td>
<td style="text-align:left">定义数值的下限。所允许的值必需大于或等于此值。</td>
</tr>
<tr>
<td style="text-align:left">minLength</td>
<td style="text-align:left">定义所允许的字符或者列表项目的最小数目。必须大于或等于0。</td>
</tr>
<tr>
<td style="text-align:left">pattern</td>
<td style="text-align:left">定义可接受的字符的精确序列。</td>
</tr>
<tr>
<td style="text-align:left">totalDigits</td>
<td style="text-align:left">定义所允许的阿拉伯数字的精确位数。必须大于0。</td>
</tr>
<tr>
<td style="text-align:left">whiteSpace</td>
<td style="text-align:left">定义空白字符（换行、回车、空格以及制表符）的处理方式。</td>
</tr>
</tbody>
</table>
<h2 id="复合元素"><a href="#复合元素" class="headerlink" title="复合元素"></a>复合元素</h2><blockquote>
<p>复合元素指包含其他元素及/或属性的 XML 元素。</p>
<ul>
<li>空元素</li>
<li>包含其他元素的元素</li>
<li>仅包含文本的元素</li>
<li>包含元素和文本的元素</li>
</ul>
<p>上述元素均可包含属性。</p>
</blockquote>
<p><strong>定义复合元素</strong></p>
<p>这个复合 XML 元素，”employee”，仅包含其他元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;employee&gt;</span><br><span class="line">    &lt;firstname&gt;John&lt;/firstname&gt;</span><br><span class="line">    &lt;lastname&gt;Smith&lt;/lastname&gt;</span><br><span class="line">&lt;/employee&gt;</span><br></pre></td></tr></table></figure>
<p>在 XML Schema 中，有两种方式来定义复合元素：</p>
<ol>
<li>通过命名此元素，可直接对 “employee” 元素进行声明：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;employee&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>假如使用上面所描述的方法，那么仅有 “employee” 可使用所规定的复合类型。请注意其子元素，”firstname” 以及 “lastname”，被包围在指示器 <code>&lt;sequence&gt;</code> 中。这意味着子元素必须以它们被声明的次序出现。</p>
<ol>
<li>“employee” 元素可以使用 type 属性，这个属性的作用是引用要使用的复合类型的名称：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;employee&quot; type=&quot;personinfo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;personinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<p>如果使用了上面所描述的方法，那么若干元素均可以使用相同的复合类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;employee&quot; type=&quot;personinfo&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;student&quot; type=&quot;personinfo&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;member&quot; type=&quot;personinfo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;personinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<p>也可以在已有的复合元素之上以某个复合元素为基础，然后添加一些元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;employee&quot; type=&quot;fullpersoninfo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;personinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;fullpersoninfo&quot;&gt;</span><br><span class="line">  &lt;xs:complexContent&gt;</span><br><span class="line">    &lt;xs:extension base=&quot;personinfo&quot;&gt;</span><br><span class="line">      &lt;xs:sequence&gt;</span><br><span class="line">        &lt;xs:element name=&quot;address&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">        &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">        &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;/xs:extension&gt;</span><br><span class="line">  &lt;/xs:complexContent&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型-空元素"><a href="#复合类型-空元素" class="headerlink" title="复合类型-空元素"></a><strong>复合类型-空元素</strong></h3><blockquote>
<p>空的复合元素不能包含内容，只能含有属性。</p>
</blockquote>
<p>一个空的 XML 元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;product prodid=&quot;1345&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>上面的 “product” 元素根本没有内容。为了定义无内容的类型，就必须声明一个在其内容中只能包含元素的类型，但是实际上并不会声明任何元素，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;product&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">        &lt;xs:complexContent&gt;</span><br><span class="line">            &lt;xs:restriction base=&quot;xs:integer&quot;&gt;</span><br><span class="line">                &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;</span><br><span class="line">            &lt;/xs:restriction&gt;</span><br><span class="line">        &lt;/xs:complexContent&gt;</span><br><span class="line">    &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，定义了一个带有复合内容的复合类型。complexContent 元素给出的信号是，打算限定或者拓展某个复合类型的内容模型，而 integer 限定则声明了一个属性但不会引入任何的元素内容。<br>但是，也可以更加紧凑地声明此 “product” 元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;product&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>或者可以为一个 complexType 元素起一个名字，然后为 “product” 元素设置一个 type 属性并引用这个 complexType 名称（通过使用此方法，若干个元素均可引用相同的复合类型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;product&quot; type=&quot;prodtype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;prodtype&quot;&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型-仅含元素"><a href="#复合类型-仅含元素" class="headerlink" title="复合类型-仅含元素"></a><strong>复合类型-仅含元素</strong></h3><blockquote>
<p>“仅含元素”的复合类型元素是只能包含其他元素的元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">    &lt;firstname&gt;John&lt;/firstname&gt;</span><br><span class="line">    &lt;lastname&gt;Smith&lt;/lastname&gt;</span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure>
<p>可在 schema 中这样定义 “person” 元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>注意，它意味着被定义的元素必须按上面的次序出现在 “person” 元素中。<br>或者可以为 complexType 元素设定一个名称，并让 “person” 元素的 type 属性来引用此名称（如使用此方法，若干元素均可引用相同的复合类型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot; type=&quot;persontype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;persontype&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型-仅含文本"><a href="#复合类型-仅含文本" class="headerlink" title="复合类型-仅含文本"></a><strong>复合类型-仅含文本</strong></h3><blockquote>
<p>含文本的复合元素可包含文本和属性。</p>
</blockquote>
<p>此类型仅包含简易的内容（文本和属性），因此要向此内容添加 simpleContent 元素。当使用简易内容时，我们就必须在 simpleContent 元素内定义扩展或限定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;somename&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:simpleContent&gt;</span><br><span class="line">      &lt;xs:extension base=&quot;basetype&quot;&gt;</span><br><span class="line">        ....</span><br><span class="line">        ....</span><br><span class="line">      &lt;/xs:extension&gt;</span><br><span class="line">    &lt;/xs:simpleContent&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;somename&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:simpleContent&gt;</span><br><span class="line">      &lt;xs:restriction base=&quot;basetype&quot;&gt;</span><br><span class="line">        ....</span><br><span class="line">        ....</span><br><span class="line">      &lt;/xs:restriction&gt;</span><br><span class="line">    &lt;/xs:simpleContent&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>提示： 请使用 extension 或 restriction 元素来扩展或限制元素的基本简易类型。 这里有一个 XML 元素的例子，”shoesize”，其中仅包含文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;shoesize country=&quot;france&quot;&gt;35&lt;/shoesize&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个例子声明了一个复合类型，其内容被定义为整数值，并且 “shoesize” 元素含有名为 “country” 的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;shoesize&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:simpleContent&gt;</span><br><span class="line">      &lt;xs:extension base=&quot;xs:integer&quot;&gt;</span><br><span class="line">        &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt;</span><br><span class="line">      &lt;/xs:extension&gt;</span><br><span class="line">    &lt;/xs:simpleContent&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>也可为 complexType 元素设定一个名称，并让 “shoesize” 元素的 type 属性来引用此名称（通过使用此方法，若干元素均可引用相同的复合类型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;shoesize&quot; type=&quot;shoetype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;shoetype&quot;&gt;</span><br><span class="line">  &lt;xs:simpleContent&gt;</span><br><span class="line">    &lt;xs:extension base=&quot;xs:integer&quot;&gt;</span><br><span class="line">      &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt;</span><br><span class="line">    &lt;/xs:extension&gt;</span><br><span class="line">  &lt;/xs:simpleContent&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型-混合内容"><a href="#复合类型-混合内容" class="headerlink" title="复合类型-混合内容"></a><strong>复合类型-混合内容</strong></h3><blockquote>
<p>混合的复合类型可包含属性、元素以及文本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;letter&gt;</span><br><span class="line">    Dear Mr.&lt;name&gt;John Smith&lt;/name&gt;.</span><br><span class="line">    Your order &lt;orderid&gt;1032&lt;/orderid&gt;</span><br><span class="line">    will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.</span><br><span class="line">&lt;/letter&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个 schema 声明了这个 “letter” 元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot;&gt;</span><br><span class="line">  &lt;xs:complexType mixed=&quot;true&quot;&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>注意： 为了使字符数据可以出现在 “letter” 的子元素之间，mixed 属性必须被设置为 “true”。<code>&lt;xs:sequence&gt;</code> 标签 (name、orderid 以及 shipdate ) 意味着被定义的元素必须依次出现在 “letter” 元素内部。<br>也可以为 complexType 元素起一个名字，并让 “letter” 元素的 type 属性引用 complexType 的这个名称（通过这个方法，若干元素均可引用同一个复合类型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;letter&quot; type=&quot;lettertype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;lettertype&quot; mixed=&quot;true&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<h2 id="指示器"><a href="#指示器" class="headerlink" title="指示器"></a>指示器</h2><blockquote>
<p>通过指示器，可以控制在文档中使用元素的方式。</p>
<ul>
<li>Order 指示器：<ul>
<li>All</li>
<li>Choice</li>
<li>Sequence</li>
</ul>
</li>
<li>Occurrence 指示器：<ul>
<li>maxOccurs</li>
<li>minOccurs</li>
</ul>
</li>
<li>Group 指示器：<ul>
<li>Group name</li>
<li>attributeGroup name</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>Order 指示器</strong></p>
<blockquote>
<p>Order 指示器用于定义元素的顺序。</p>
</blockquote>
<ul>
<li>All 指示器<br>规定子元素可以按照任意顺序出现，且每个子元素必须只出现一次：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:all&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;/xs:all&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>注意： 当使用 all 指示器时，可以把 <code>&lt;minOccurs&gt;</code> 设置为 0 或者 1，而只能把 <code>&lt;maxOccurs&gt;</code> 指示器设置为 1。</p>
<ul>
<li>Choice 指示器<br>规定可出现某个子元素或者可出现另外一个子元素（非此即彼）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:choice&gt;</span><br><span class="line">      &lt;xs:element name=&quot;employee&quot; type=&quot;employee&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;member&quot; type=&quot;member&quot;/&gt;</span><br><span class="line">    &lt;/xs:choice&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Sequence 指示器<br>规定子元素必须按照特定的顺序出现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">   &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Occurrence 指示器</strong></p>
<blockquote>
<p>用于定义某个元素出现的频率。</p>
</blockquote>
<p>注意： 对于所有的 “Order” 和 “Group” 指示器（any、all、choice、sequence、group name 以及 group reference），其中的 maxOccurs 以及 minOccurs 的默认值均为 1。</p>
<ul>
<li>maxOccurs 指示器<br>可规定某个元素可出现的最大次数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot; maxOccurs=&quot;10&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子表明，子元素 “child_name” 可在 “person” 元素中最少出现一次（其中 minOccurs 的默认值是 1），最多出现 10 次。</p>
<ul>
<li>minOccurs 指示器<br>可规定某个元素能够出现的最小次数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot;</span><br><span class="line">      maxOccurs=&quot;10&quot; minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子表明，子元素 “child_name” 可在 “person” 元素中出现最少 0 次，最多出现 10 次。<br>如需使某个元素的出现次数不受限制，请使用 maxOccurs=”unbounded” 这个声明：<br>一个实际的例子：</p>
<p><strong>Group 指示器</strong></p>
<blockquote>
<p>用于定义相关的数批元素。</p>
</blockquote>
<ul>
<li>元素组<br>通过 group 声明进行定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:group name=&quot;groupname&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/xs:group&gt;</span><br></pre></td></tr></table></figure>
<p>必须在 group 声明内部定义一个 all、choice 或者 sequence 元素。下面这个例子定义了名为 “persongroup” 的 group，它定义了必须按照精确的顺序出现的一组元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:group name=&quot;persongroup&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br></pre></td></tr></table></figure>
<p>在把 group 定义完毕以后，就可以在另一个定义中引用它了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:group name=&quot;persongroup&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:group&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;person&quot; type=&quot;personinfo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;personinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:group ref=&quot;persongroup&quot;/&gt;</span><br><span class="line">    &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性组<br>通过 attributeGroup 声明来进行定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:attributeGroup name=&quot;groupname&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/xs:attributeGroup&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个例子定义了名为 “personattrgroup” 的一个属性组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">&lt;/xs:attributeGroup&gt;</span><br></pre></td></tr></table></figure>
<p>在已定义完毕属性组之后，就可以在另一个定义中引用它了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">  &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;</span><br><span class="line">&lt;/xs:attributeGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:attributeGroup ref=&quot;personattrgroup&quot;/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<h2 id="any-元素"><a href="#any-元素" class="headerlink" title="any 元素"></a>any 元素</h2><blockquote>
<p>any 元素使我们有能力通过未被 schema 规定的元素来拓展 XML 文档。</p>
</blockquote>
<p>下面这个例子是从名为 “family.xsd” 的 XML schema 中引用的片段。它展示了一个针对 “person” 元素的声明。通过使用 any 元素，我们可以通过任何元素（在 <code>&lt;lastname&gt;</code> 之后）扩展 “person” 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:any minOccurs=&quot;0&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>现在，我们希望使用 “children” 元素来扩展 “person” 元素。这此种情况下就可以这么做，即使以上这个 schema 的作者没有声明任何 “children” 元素。<br>请看这个 schema 文件，名为 “children.xsd”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">targetNamespace=&quot;http://www.w3schools.com&quot;</span><br><span class="line">xmlns=&quot;http://www.w3schools.com&quot;</span><br><span class="line">elementFormDefault=&quot;qualified&quot;&gt;</span><br><span class="line">    &lt;xs:element name=&quot;children&quot;&gt;</span><br><span class="line">      &lt;xs:complexType&gt;</span><br><span class="line">        &lt;xs:sequence&gt;</span><br><span class="line">          &lt;xs:element name=&quot;childname&quot; type=&quot;xs:string&quot;</span><br><span class="line">          maxOccurs=&quot;unbounded&quot;/&gt;</span><br><span class="line">        &lt;/xs:sequence&gt;</span><br><span class="line">      &lt;/xs:complexType&gt;</span><br><span class="line">    &lt;/xs:element&gt;</span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个 XML 文件（名为 “Myfamily.xml”），使用了来自两个不同的 schema 中的成分，”family.xsd” 和 “children.xsd”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;persons xmlns=&quot;http://www.microsoft.com&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.microsoft.com family.xsd</span><br><span class="line">http://www.w3schools.com children.xsd&quot;&gt;</span><br><span class="line">    &lt;person&gt;</span><br><span class="line">      &lt;firstname&gt;Hege&lt;/firstname&gt;</span><br><span class="line">      &lt;lastname&gt;Refsnes&lt;/lastname&gt;</span><br><span class="line">      &lt;children&gt;</span><br><span class="line">        &lt;childname&gt;Cecilie&lt;/childname&gt;</span><br><span class="line">      &lt;/children&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">    &lt;person&gt;</span><br><span class="line">      &lt;firstname&gt;Stale&lt;/firstname&gt;</span><br><span class="line">      &lt;lastname&gt;Refsnes&lt;/lastname&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个 XML 文件是有效的，这是由于 schema “family.xsd” 允许我们通过在 “lastname” 元素后的可选元素来扩展 “person” 元素。</p>
<h2 id="anyAttribute"><a href="#anyAttribute" class="headerlink" title="anyAttribute"></a>anyAttribute</h2><blockquote>
<p>anyAttribute 元素使我们有能力通过未被 schema 规定的属性来扩展 XML 文档。</p>
</blockquote>
<p>下面的例子是来自名为 “family.xsd” 的 XML schema 的一个片段。它为我们展示了针对 “person” 元素的一个声明。通过使用 <code>&lt;anyAttribute&gt;</code> 元素，我们就可以向 “person” 元素添加任意数量的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;person&quot;&gt;</span><br><span class="line">  &lt;xs:complexType&gt;</span><br><span class="line">    &lt;xs:sequence&gt;</span><br><span class="line">      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">    &lt;/xs:sequence&gt;</span><br><span class="line">    &lt;xs:anyAttribute/&gt;</span><br><span class="line">  &lt;/xs:complexType&gt;</span><br><span class="line">&lt;/xs:element&gt;</span><br></pre></td></tr></table></figure>
<p>现在，我们希望通过 “gender” 属性来扩展 “person” 元素。在这种情况下我们就可以这样做，即使这个 schema 的作者从未声明过任何 “gender” 属性。<br>请看这个 schema 文件，名为 “attribute.xsd”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">targetNamespace=&quot;http://www.w3schools.com&quot;</span><br><span class="line">xmlns=&quot;http://www.w3schools.com&quot;</span><br><span class="line">elementFormDefault=&quot;qualified&quot;&gt;</span><br><span class="line">    &lt;xs:attribute name=&quot;gender&quot;&gt;</span><br><span class="line">      &lt;xs:simpleType&gt;</span><br><span class="line">        &lt;xs:restriction base=&quot;xs:string&quot;&gt;</span><br><span class="line">          &lt;xs:pattern value=&quot;male|female&quot;/&gt;</span><br><span class="line">        &lt;/xs:restriction&gt;</span><br><span class="line">      &lt;/xs:simpleType&gt;</span><br><span class="line">    &lt;/xs:attribute&gt;</span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个 XML（名为 “Myfamily.xml”），使用了来自不同 schema 的成分，”family.xsd” 和 “attribute.xsd”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;persons xmlns=&quot;http://www.microsoft.com&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:SchemaLocation=&quot;http://www.microsoft.com family.xsd</span><br><span class="line">http://www.w3schools.com attribute.xsd&quot;&gt;</span><br><span class="line">    &lt;person gender=&quot;female&quot;&gt;</span><br><span class="line">      &lt;firstname&gt;Hege&lt;/firstname&gt;</span><br><span class="line">      &lt;lastname&gt;Refsnes&lt;/lastname&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">    &lt;person gender=&quot;male&quot;&gt;</span><br><span class="line">      &lt;firstname&gt;Stale&lt;/firstname&gt;</span><br><span class="line">      &lt;lastname&gt;Refsnes&lt;/lastname&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/persons&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个 XML 文件是有效的，这是因为 schema “family.xsd” 允许我们向 “person” 元素添加属性。</p>
<h2 id="元素替换"><a href="#元素替换" class="headerlink" title="元素替换"></a>元素替换</h2><blockquote>
<p>通过元素替换 (Element Substitution)，一个元素可对另一个元素进行替换。</p>
</blockquote>
<p><strong>元素替换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;navn&quot; substitutionGroup=&quot;name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;custinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;name&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;customer&quot; type=&quot;custinfo&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;kunde&quot; substitutionGroup=&quot;customer&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>有效的 XML 文档类似这样（根据上面的 schema）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;customer&gt;</span><br><span class="line">  &lt;name&gt;John Smith&lt;/name&gt;</span><br><span class="line">&lt;/customer&gt;</span><br></pre></td></tr></table></figure>
<p>或类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;kunde&gt;</span><br><span class="line">  &lt;navn&gt;John Smith&lt;/navn&gt;</span><br><span class="line">&lt;/kunde&gt;</span><br></pre></td></tr></table></figure>
<p><strong>阻止元素替换</strong></p>
<p>为防止其他的元素替换某个指定的元素，须使用 block 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot; block=&quot;substitution&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>某个 XML schema 的片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot; block=&quot;substitution&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;navn&quot; substitutionGroup=&quot;name&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:complexType name=&quot;custinfo&quot;&gt;</span><br><span class="line">  &lt;xs:sequence&gt;</span><br><span class="line">    &lt;xs:element ref=&quot;name&quot;/&gt;</span><br><span class="line">  &lt;/xs:sequence&gt;</span><br><span class="line">&lt;/xs:complexType&gt;</span><br><span class="line"></span><br><span class="line">&lt;xs:element name=&quot;customer&quot; type=&quot;custinfo&quot; block=&quot;substitution&quot;/&gt;</span><br><span class="line">&lt;xs:element name=&quot;kunde&quot; substitutionGroup=&quot;customer&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>合法的 XML 文档应该类似这样（根据上面的 schema）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;customer&gt;</span><br><span class="line">  &lt;name&gt;John Smith&lt;/name&gt;</span><br><span class="line">&lt;/customer&gt;</span><br></pre></td></tr></table></figure>
<p>但是下面的文档不再合法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;kunde&gt;</span><br><span class="line">  &lt;navn&gt;John Smith&lt;/navn&gt;</span><br><span class="line">&lt;/kunde&gt;</span><br></pre></td></tr></table></figure>
<p><strong>使用 substitutionGroup</strong><br>可替换元素的类型必须和主元素相同，或者从主元素衍生而来。假如可替换元素的类型与主元素的类型相同，那么就不必规定可替换元素的类型了。<br>注意，substitutionGroup 中的所有元素（主元素和可替换元素）必须被声明为<strong>全局元素</strong>，否则就无法工作！</p>
<p><strong>什么是全局元素（Global Elements）</strong><br>全局元素指 “schema” 元素的直接子元素！本地元素（Local elements）指嵌套在其他元素中的元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/工具/Vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/工具/Vim/" itemprop="url">Vim</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul>
<li><code>u</code> 撤销从上次进入插入模式到退出插入模式之间的操作。在插入模式中使用光标键会视为产生一个新的撤销块。</li>
<li><code>U</code> 撤销对整行的修改</li>
<li><code>&lt;c-r&gt;</code> 重做被撤销的操作</li>
</ul>
<h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><ul>
<li><code>[n]&lt;C-a&gt;</code> 将光标所在数字（或本行内光标后最近一个数字）加 n（缺省为 1）</li>
<li><code>[n]&lt;C-x&gt;</code> 将光标所在数字（或本行内光标后最近一个数字）减 n（缺省为 1）</li>
</ul>
<p>Vim 缺省会将以 0 开头的数字解释为八进制。在 vimrc 中加入 <code>set nrformats=</code> 来把所有数字解释为十进制。</p>
<h2 id="插入模式下的删除操作符"><a href="#插入模式下的删除操作符" class="headerlink" title="插入模式下的删除操作符"></a>插入模式下的删除操作符</h2><table>
<thead>
<tr>
<th style="text-align:left">按键操作</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;C-h&gt;</code></td>
<td style="text-align:left">删除前一个字符（同退格键）</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;C-w&gt;</code></td>
<td style="text-align:left">删除前一个单词</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;C-u&gt;</code></td>
<td style="text-align:left">删至行首</td>
</tr>
</tbody>
</table>
<p>这些命令在 Vim 的命令行模式以及在 bash shell 中同样有效。</p>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><ul>
<li><code>&lt;c-g&gt;</code> 显示光标所在行位置及文件状态信息</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li><code>/{string}</code> 正向查找指定字符串</li>
<li><code>?{string}</code> 反向查找指定字符串</li>
<li><code>n</code> 以相同方向再次查找该字符串</li>
<li><code>N</code> 以相反方向再次查找该字符串</li>
<li><code>&lt;c-o&gt;</code> 返回之前位置</li>
<li><code>&lt;c-i&gt;</code> 跳至较新位置</li>
<li><code>*</code> 查找光标下单词</li>
</ul>
<h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><p><code>/expr</code> magic 搜索模式。<br><code>/\vexpr</code> very magic 搜索模式。除下划线、字母和数字以外的所有字符都当作具有特殊含义的字符。“#”依然会按其原义匹配，原因是“任何还未具有特殊含义的字符都被保留以备将来扩展时使用”。<br><code>/\Vexpr</code> very nomagic 搜索模式。只有“\”具有特殊含义。<br><em>具体的字符含义见 <code>:h pattern-overview</code></em></p>
<p><code>/\(expr1\)\@&gt;expr2</code> 固化分组。详见另一篇《正则表达式》。<br><code>/expr1\(expr2\)\@=</code> 正向前查找。匹配所有满足后置表达式为 expr2 的 expr1。<br><code>/expr1\(expr2\)\@!</code> 负向前查找。匹配所有满足后置表达式<strong>不</strong>为 expr2 的 expr1。<br><code>/expr1\@&lt;=expr2</code> 正向后查找。匹配所有满足前置表达式为 expr1 的 expr2。<br><code>/expr1\@&lt;!expr2</code> 负向后查找。匹配所有满足前置表达式<strong>不</strong>为 expr1 的 expr2。<br><em>若用 very magic 模式则不需要转义</em></p>
<p><code>*</code> 贪婪匹配<br><code>{-}</code> <code>{-m,n}</code> 非贪婪匹配</p>
<h3 id="配对括号的查找"><a href="#配对括号的查找" class="headerlink" title="配对括号的查找"></a>配对括号的查找</h3><p><code>%</code> 若光标置于括号处（{、[、(、)、]、}），则会跳至与该括号相配对的另一括号处。若光标置于非括号处，则会跳至与“当前位置之后第一个括号”相配对的另一括号处（仅在本行查找）。</p>
<h2 id="在-VIM-内执行外部命令"><a href="#在-VIM-内执行外部命令" class="headerlink" title="在 VIM 内执行外部命令"></a>在 VIM 内执行外部命令</h2><p><code>:![command]</code> 所有的外部命令都可以用这种方式执行，包括带命令行参数的命令。</p>
<h2 id="具有选择性的保存命令"><a href="#具有选择性的保存命令" class="headerlink" title="具有选择性的保存命令"></a>具有选择性的保存命令</h2><ol>
<li>按 <code>v</code> 进入可视模式</li>
<li>移动光标来选取文本</li>
<li>按 <code>:</code> 会看到窗口底部出现 <code>:&#39;&lt;,&#39;&gt;</code></li>
<li>输入 <code>w [FILENAME]</code> 并回车，就把所选文本保存到相应的文件中了。</li>
</ol>
<h2 id="提取和合并文件"><a href="#提取和合并文件" class="headerlink" title="提取和合并文件"></a>提取和合并文件</h2><p><code>:r [FILENAME]</code> 插入指定文件的内容，从光标所在位置的后一行开始<br><code>:r ![command]</code> 插入指定外部命令的输出内容</p>
<h2 id="设置类选项"><a href="#设置类选项" class="headerlink" title="设置类选项"></a>设置类选项</h2><ul>
<li><code>:set ic</code> 查找替换忽略大小写 <em>Ignore Case</em></li>
<li><code>:set noic</code> 禁用忽略大小写</li>
<li><code>:set hls</code> 搜索高亮 <em>hlsearch</em></li>
<li><code>:set nohls</code> <code>:nohls</code> <code>:nohlsearch</code> 禁用搜索高亮</li>
<li><code>:set is</code> 增量搜索 <em>incsearch</em></li>
<li><code>:set nois</code> 禁用增量搜索</li>
<li><code>/[string]\c</code> 仅在本次查找忽略大小写</li>
</ul>
<h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><p><code>&lt;help&gt;</code> 若键盘上有的话<br><code>&lt;F1&gt;</code> 若键盘上有的话<br><code>:help [parameter]</code> 获取帮助信息，参数为可选项</p>
<h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><ul>
<li><code>$myvimrc</code>: vimrc 文件全路径。（关于 vimrc 详见 <code>:h vimrc-intro</code>）</li>
<li><code>$vim</code>: vim 程序根目录。</li>
<li><code>$vimruntime</code>: 其下包含各种 vim 的支持文件。以 vim8.1 为例，默认是 <code>$vim/vim81/</code>。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>gv</code> 重选上次的选区<br><code>o</code> 切换选区的活动端</p>
<h1 id="mswin-vim"><a href="#mswin-vim" class="headerlink" title="mswin.vim"></a>mswin.vim</h1><p><code>{mode} {if_recursive} {map}</code></p>
<ul>
<li><code>mode</code> 表示该映射生效的模式（<em><code>:h vim-modes</code></em>）。取值如下：<ul>
<li>空: normal, visual, select, operator-pending</li>
<li>n: normal only</li>
<li>v: visual and select</li>
<li>o: operator-pending(<em><code>:h Operator-pending-mode</code></em>)</li>
<li>x: visual only(<em><code>:h visual-mode</code></em>)</li>
<li>s: select only(<em><code>:h select-mode</code></em>)</li>
<li>i: insert</li>
<li>c: command-line</li>
<li>l: insert, command-line, regexp-search (and others. Collectively called “Lang-Arg” pseudo-mode)</li>
</ul>
</li>
<li><code>if_recursive</code> 表示该命令是否会递归生效<ul>
<li><code></code> 空缺，表示递归生效</li>
<li><code>nore</code> 表示非递归生效</li>
</ul>
</li>
<li><code>map</code> 固定值，表示映射</li>
</ul>
<h1 id="可重复的操作及如何回退"><a href="#可重复的操作及如何回退" class="headerlink" title="可重复的操作及如何回退"></a>可重复的操作及如何回退</h1><table>
<thead>
<tr>
<th style="text-align:left">目的</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">重复</th>
<th style="text-align:left">回退</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">做出一个修改</td>
<td style="text-align:left">{edit}</td>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">执行替换</td>
<td style="text-align:left">:s/{tar}/{sub}</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">执行一系列修改</td>
<td style="text-align:left"><code>qx{changes}q</code></td>
<td style="text-align:left"><code>@x</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">重复任意 Ex 命令</td>
<td style="text-align:left"><code>:{Ex}</code></td>
<td style="text-align:left"><code>@:</code></td>
<td style="text-align:left"><code>u</code></td>
</tr>
<tr>
<td style="text-align:left">在行内查找下一指定字符</td>
<td style="text-align:left"><code>f{char}</code>/<code>t{char}</code></td>
<td style="text-align:left"><code>;</code></td>
<td style="text-align:left"><code>,</code></td>
</tr>
<tr>
<td style="text-align:left">在行内查找上一指定字符</td>
<td style="text-align:left"><code>F{char}</code>/<code>T{char}</code></td>
<td style="text-align:left"><code>;</code></td>
<td style="text-align:left"><code>,</code></td>
</tr>
<tr>
<td style="text-align:left">在文档中查找下一处匹配项</td>
<td style="text-align:left">/pattern<code>{CR}</code></td>
<td style="text-align:left"><code>n</code></td>
<td style="text-align:left"><code>N</code></td>
</tr>
<tr>
<td style="text-align:left">在文档中查找上一处匹配项</td>
<td style="text-align:left">?pattern<code>{CR}</code></td>
<td style="text-align:left"><code>n</code></td>
<td style="text-align:left"><code>N</code></td>
</tr>
</tbody>
</table>
<h1 id="操作符-operator"><a href="#操作符-operator" class="headerlink" title="操作符 operator"></a>操作符 operator</h1><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>c</code></td>
<td style="text-align:left">修改</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code></td>
<td style="text-align:left">光标下单字符修改</td>
</tr>
<tr>
<td style="text-align:left"><code>d</code></td>
<td style="text-align:left">删除</td>
</tr>
<tr>
<td style="text-align:left"><code>y</code></td>
<td style="text-align:left">复制到寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>g~</code></td>
<td style="text-align:left">反转大小写</td>
</tr>
<tr>
<td style="text-align:left"><code>gu</code></td>
<td style="text-align:left">转换为小写</td>
</tr>
<tr>
<td style="text-align:left"><code>gU</code></td>
<td style="text-align:left">转为大写</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">增加缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">减小缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">自动缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">使用外部程序过滤 {motion} 所跨越的行</td>
</tr>
</tbody>
</table>
<p><em>自定义操作符<code>:h map-operator</code></em></p>
<h1 id="Ex-命令"><a href="#Ex-命令" class="headerlink" title="Ex 命令"></a>Ex 命令</h1><ul>
<li><code>:[{range}]d[elete] {reg}</code> 删除指定范围内的到寄存器 {reg} 中</li>
<li><code>:[{range}]y[ank] {reg}</code> 复制指定范围内行[到寄存器 {reg} 中</li>
<li><code>:[{line}]pu[t] {reg}</code> 在指定行后粘贴寄存器 {reg} 中的内容</li>
<li><code>:[{range}]co[py] {to}</code> <code>:t</code> 把指定范围内的行复制到 {to} 所指定的行之下</li>
<li><code>:[{range}]m[ove] {to}</code> 把指定范围内的行移动到 {to} 所指定的行之下</li>
<li><code>:[{range}]j[oin][!]</code> 连接指定范围内的行。<code>!</code> 表示不插入或删除任何空格。</li>
<li><code>:[{range}]norm[al][!] {commands}</code> 对指定范围内的每一行执行普通模式命令</li>
<li><code>:[{range}]s[ubstitute]/{pattern}/{string}/[flags]</code> 把指定范围内出现 {pattern} 的地方替换为 {string}</li>
<li><code>:[{range}]g[lobal]/{pattern}/[cmd]</code> 对指定范围内匹配 {pattern} 的所有行，在其上执行 Ex 命令 {cmd}</li>
</ul>
<h2 id="补全功能"><a href="#补全功能" class="headerlink" title="补全功能"></a>补全功能</h2><ol>
<li>确保 Vim 不是在以兼容模式运行 <code>:set nocp</code></li>
<li><code>&lt;C-d&gt;</code> 列出候选列表</li>
<li><code>&lt;TAB&gt;</code> 在候选列表中切换选项</li>
</ol>
<h2 id="用来构建-Ex-命令的地址和范围的符号"><a href="#用来构建-Ex-命令的地址和范围的符号" class="headerlink" title="用来构建 Ex 命令的地址和范围的符号"></a>用来构建 Ex 命令的地址和范围的符号</h2><table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>{number}</code></td>
<td style="text-align:left">行号</td>
</tr>
<tr>
<td style="text-align:left"><code>1</code></td>
<td style="text-align:left">文件的首行</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">文件的末行</td>
</tr>
<tr>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">虚拟行，位于文件首行上方</td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">光标所在行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;m</code></td>
<td style="text-align:left">包含位置标记 m 的行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;&lt;</code></td>
<td style="text-align:left">最近一次高亮选区的首行</td>
</tr>
<tr>
<td style="text-align:left"><code>&#39;&gt;</code></td>
<td style="text-align:left">最近一次高亮选区的末行</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">整个文件（<code>:1,$</code> 的简写形式)</td>
</tr>
</tbody>
</table>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code> 将光标下单词插入命令行中</li>
<li><code>&lt;C-r&gt;&lt;C-a&gt;</code> 将光标下字串插入命令行中</li>
<li><code>q/</code> 打开查找命令历史的命令行窗口</li>
<li><code>q:</code> 打开 Ex 命令历史的命令行窗口</li>
<li><code>&lt;C-f&gt;</code> 从命令行模式切换到命令行窗口</li>
<li><code>&lt;up&gt;</code> <code>&lt;down&gt;</code> 向前/向后遍历历史命令。若已输入部分内容，则只遍历已输入内容开头的命令。</li>
<li><code>&lt;C-p&gt;</code> <code>&lt;C-n&gt;</code> 向前/向后遍历历史命令。不会根据已输入内容进行过滤。</li>
</ul>
<h1 id="插入特殊字符"><a href="#插入特殊字符" class="headerlink" title="插入特殊字符"></a>插入特殊字符</h1><p>在插入模式中输入 <code>&lt;C-v&gt;{code}</code>。Vim 接受的字符编码共包含 3 位数字，不满 3 位的在开头补 0，超过 3 位的用 <code>&lt;C-v&gt;u{code}</code> 来输入，其中 {code} 为十六进制编码。</p>
<p><code>ga</code> 命令查看光标所在字符的编码。</p>
<p>如果 <code>&lt;C-v&gt;</code> 后面跟一个非数字键，则会插入这个按键本身所代表的字符。比如若开启了’expandtab’选项，则 {Tab} 键会插入空格，而 <code>&lt;C-v&gt;{Tab}</code> 会插入制表符。</p>
<ul>
<li><code>&lt;C-v&gt;{123}</code> 以十进制字符编码插入字符</li>
<li><code>&lt;C-v&gt;u{1234}</code> 以十六进制字符编码插入字符</li>
<li><code>&lt;C-v&gt;{nodigit}</code> 按原义插入非数字字符</li>
<li><p><code>&lt;C-k&gt;{char1}{char2}</code> 插入以二合字母表示的字符</p>
</li>
<li><p><code>:h digraphs-default</code> 缺省的二合字母集依从的惯例</p>
</li>
<li><code>:h digraph-table</code> 二合字母列表</li>
</ul>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p><strong>新建窗口</strong></p>
<ul>
<li><code>&lt;C-w&gt;s</code>：水平切分当前窗口，新窗口仍显示当前缓冲区</li>
<li><code>&lt;C-w&gt;v</code>：垂直切分当前窗口，新窗口仍显示当前缓冲区</li>
<li><code>:sp[lit] {file}</code>：水平切分当前窗口，并在新窗口中载入{file}</li>
<li><code>:vsp[lit] {file}</code>：垂直切分当前窗口，并在新窗口中载入{file}</li>
</ul>
<p><strong>在窗口间切换，详见 <code>:h window-move-curse</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;w</code> <code>&lt;C-w&gt;&lt;C-w&gt;</code> 在窗口间循环切换</li>
<li><code>&lt;C-w&gt;h</code> 切换到左边的窗口</li>
<li><code>&lt;C-w&gt;j</code> 切换到下边的窗口</li>
<li><code>&lt;C-w&gt;k</code> 切换到上边的窗口</li>
<li><code>&lt;C-w&gt;l</code> 切换到右边的窗口</li>
</ul>
<p><strong>关闭窗口</strong></p>
<ul>
<li><code>:clo[se]</code> <code>&lt;C-w&gt;c</code>：关闭活动窗口</li>
<li><code>:on[ly]</code> <code>&lt;C-w&gt;o</code>：只保留活动窗口，关闭其他所有窗口</li>
</ul>
<p><strong>改变窗口大小及重新排列窗口，详见 <code>:h window-resize</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;=</code>：使所有窗口等宽、等高</li>
<li><code>&lt;C-w&gt;_</code>：最大化活动窗口的高度</li>
<li><code>&lt;C-w&gt;\|</code>：最大化活动窗口的宽度</li>
<li><code>[N]&lt;C-w&gt;_</code>：把活动窗口的高度设为[N]行</li>
<li><code>[N]&lt;C-w&gt;\|</code>：把活动窗口的宽度设为[N]列</li>
</ul>
<p><strong>重排窗口，详见 <code>:h window-moving</code></strong></p>
<ul>
<li><code>&lt;C-w&gt;r</code> <code>&lt;C-w&gt;&lt;C-r&gt;</code>：将所有窗口下移/右移，只影响当前窗口所在列/行</li>
<li><code>&lt;C-w&gt;R</code>：将所有窗口上移/左移，只影响当前窗口所在列/行</li>
<li><code>[N]&lt;C-w&gt;x</code> <code>[N]&lt;C-w&gt;&lt;C-x&gt;</code>：将当前窗口与下一个窗口交换，若无下个窗口，则与上一个窗口交换，光标会切换到目标窗口。通过指定[N]来将当前窗口与第[N]个窗口交换（第一个窗口为1），只影响当前窗口所在行/列<br><code>&lt;C-w&gt;K</code>：将当前窗口移到最上方，并独占最大宽度<br><code>&lt;C-w&gt;J</code>：将当前窗口移到最下方，并独占最大宽度<br><code>&lt;C-w&gt;H</code>：将当前窗口移到最左方，并独占最大高度<br><code>&lt;C-w&gt;L</code>：将当前窗口移到最右方，并独占最大高度<br><code>[N]&lt;C-w&gt;T</code>：将当前窗口移到新标签页。若指定[N]则新标签页会置于第N个标签页之前，否则置于当前标签页之后。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>:lcd {path}</code>：设置当前窗口的本地工作目录</li>
<li><code>:windo lcd {path}</code>：设置当前标签页中所有窗口的本地工作目录</li>
</ul>
<h1 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h1><p><strong>打开及关闭标签页</strong><br><code>:tabe[dit] {filename}</code>：在新标签页中打开{filename}。若省略{filename}，则新标签页会包含空缓冲区<br><code>:tabc[lose]</code>：关闭当前标签页及其中所有窗口<br><code>:tabo[nly]</code>：只保留活动标签页，关闭所有其他标签页<br><code>&lt;C-w&gt;T</code>：若当前标签页不止一个窗口，则把当前窗口移到一个新标签页中</p>
<p><strong>在标签页间切换</strong><br><code>:tabn[ext] {N}</code> <code>{N}gt</code>：跳到标签页{N}，标签页编号从1开始。省略{N}则跳到下一个标签页<br><code>:tabp[revious]</code> <code>{N}gT</code>：同上，方向相反</p>
<p><strong>重排标签页</strong><br><code>:tabmove {N}</code>：当N为0时，当前标签页会被移到开头；若省略了N，则移到末尾；也可鼠标拖动</p>
<h1 id="quickfix"><a href="#quickfix" class="headerlink" title="quickfix"></a>quickfix</h1><ul>
<li><code>:cope[n] [n]</code> 打开 quickfix 窗口，可指定高度。</li>
<li><code>:ccl[ose]</code> 关闭 quickfix 窗口。</li>
<li><code>:cl[ist] [{args}]</code> 列出所有项目。<ul>
<li><code>{from} [, {to}]</code> 指定范围。</li>
<li><code>+{count}</code> 列出当前项目和后面 <code>{count}</code> 个项目。</li>
</ul>
</li>
<li><code>:cc [N]</code> 跳转到第 N 项。</li>
<li><code>:cp[revious]</code> 上一项。</li>
<li><code>:cn[ext]</code> 下一项。</li>
<li><code>:cr[ewind]|cfir[st] [n]</code> 跳转到第 n 项，若省略 n 则跳转到第一项。</li>
<li><code>:cla[st] [n]</code> 跳转到第 n 项，若省略 n 则跳转到最后一项。</li>
<li><code>:cold[er]</code> 切到前一个列表。</li>
<li><code>:cnew</code> 切到后一个列表。</li>
</ul>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p><code>:pwd</code>：打印工作目录</p>
<p><strong>相对于当前工作目录打开一个文件</strong><br><code>:e[dit] {file}</code>：{file} 可以是相对于工作目录的文件路径，也可以是绝对路径<br><code>:e[dit] %:h/{file}</code>：<code>%:h</code>表示当前活动文件的目录路径，也可使用 <code>:e %:h&lt;Tab&gt;</code> 显示出路径后再继续输入文件名<br>在 _vimrc 文件中加入 <code>cnoremap &lt;expr&gt; %% getcmdtype()==&#39;:&#39; ? expand(&#39;%:h&#39;).&#39;/&#39; : &#39;%%&#39;</code></p>
<p><strong>通过文件名查找文件 详见 <code>:h file-searching</code></strong><br><code>set path+={root}/**</code>：首先要设置path变量。{root}为某个目录路径，**通配符表示其下所有子目录<br><code>:find {file}</code>：在 path 中查找文件</p>
<p><strong>打开文件管理器 使用 netrw <a href="http://vimcdoc.sourceforge.net/doc/pi_netrw.html" target="_blank" rel="noopener">API</a></strong><br><code>:e[dit] {path}</code>：打开文件管理器，{path}是目录名而不是文件名<br><code>:e[dit].</code>：打开工作目录<br><code>:e[dit] %:h</code>：打开当前活动缓冲区所在目录<br><code>:E[xplore]</code>：打开当前活动缓冲区所在目录或指定目录<br><code>:Se[xplore]</code>：在一个水平切分窗口里打开当前活动缓冲区所在目录或指定目录<br><code>:Ve[xplore]</code>：在一个垂直切分窗口里打开当前活动缓冲区所在目录或指定目录<br><code>:Te[xplore]</code>：在一个新标签页中打开当前目录或指定目录<br><code>&lt;C-^&gt;</code>：在文件管理器中切换到上一个打开的文件/上一个进入的目录<br><code>%</code>：创建一个新文件<br><code>d</code>：创建一个新目录<br><code>D</code>：删除文件/目录<br><code>-</code>：进入上一层目录，不能返回根目录<br><code>a</code>：在三种方式间切换：正常显示、隐藏（不显示匹配）、显示（只显示匹配）<br><code>c</code>：使浏览中的目录成为当前目录<br><code>i</code>：切换列表方式<br><code>&lt;C-l&gt;</code>：刷新目录列表<br><code>o</code>：打开新浏览窗口，进入光标所在目录，使用水平分割<br><code>v</code>：打开新浏览窗口，进入光标所在目录，使用垂直分割<br><code>p</code>：预览文件<br><code>P</code>：在前次使用的窗口里浏览<br><code>r</code>：反转排序<br><code>R</code>：重命名<br><code>s</code>：选择排序方式：按名字、时间或文件大小<br><code>S</code>：指定按名字排序的后缀优先<br><code>t</code>：在新标签页里打开光标所在的文件/目录<br><code>mf</code>：标记文件/目录，用于后续批量操作<br><code>x</code>：指定某个程序来打开文件</p>
<p><strong>把文件保存到不存在的目录中</strong><br><code>:!mkdir -p %:h</code>：创建任何不存在的中间目录，然后<code>:w</code></p>
<h1 id="缓冲区列表"><a href="#缓冲区列表" class="headerlink" title="缓冲区列表"></a>缓冲区列表</h1><ul>
<li>查看<ul>
<li><code>:ls[!]</code> <code>:buffers[!]</code>: 查看缓冲区列表，加上 <code>!</code> 将同时显示列表外缓冲区。</li>
</ul>
</li>
<li>切换<ul>
<li><code>&lt;C-6&gt;</code>               : 在当前文件和轮换文件间切换。</li>
<li><code>:bp[rev]</code> <code>:bn[ext]</code> : 反向/正向切换一个缓冲区。</li>
<li><code>:bfirst</code> <code>:blast</code>    : 跳到缓冲区列表的开头/结尾。</li>
<li><code>:b[uffer] {num/name}</code>: 打开指定编号/名字的缓冲区。</li>
</ul>
</li>
<li>删除<ul>
<li><code>:bd[elete] {n1} {n2}</code>: 删除指定编号的若干个缓冲区，即置为“列表外缓冲区”。</li>
<li><code>{n},{m} bd[elete]</code>   : 删除编号从 n 到 m 的所有缓冲区，即置为“列表外缓冲区”。</li>
<li><code>:bw[ipeout]</code>         : 彻底删除缓冲区，用法同 <code>:bd[elete]</code>。</li>
</ul>
</li>
<li>执行<ul>
<li><code>:bufdo</code>              : 对所有缓冲区执行命令。</li>
</ul>
</li>
</ul>
<p><strong>隐藏缓冲区</strong></p>
<p>切换缓冲区时（包括执行 <code>:bufdo</code> <code>:argdo</code> 时），若缓冲区尚未保存，则必须在命令后加上 <code>!</code>。可通过 <code>hidden</code> 选项来让被切换走的缓冲区变为隐藏缓冲区。</p>
<ul>
<li><code>set [no]hid[den]</code> 针对全局</li>
<li><code>set bufhidden|bh</code> 针对缓冲区</li>
<li><code>:hide {cmd}</code> 针对命令</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">列表外缓冲区 unlisted-buffer</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">当前缓冲区</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">轮换缓冲区</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">激活缓冲区，缓冲区被加载且显示</td>
</tr>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">隐藏缓冲区，缓冲区被加载但不显示</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">只读缓冲区</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">不可改缓冲区，’modifiable’ 选项不置位</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">已修改缓冲区</td>
</tr>
</tbody>
</table>
<h1 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h1><ul>
<li>查看<ul>
<li><code>:ar[gs]</code>：显示当前参数列表内容</li>
</ul>
</li>
<li>编辑<ul>
<li><code>:ar[gs] {argList}</code>：设置参数列表内容，其中 {argsList} 可以包括文件名、通配符 [^wildcard] 和 shell 命令输出结果（<code>:ar {cmd}</code>）</li>
<li><code>:arge[dit] [{name}]</code>：将 {name} 添加到参数列表并编辑该文件，缺省为当前缓冲区的文件名</li>
<li><code>:arga[dd] [{name}]</code>：将 {name} 添加到参数列表，缺省为当前缓冲区的文件名</li>
<li><code>:argd {pattern}</code> <code>:[range]argd</code>：按照模式删除参数；按照范围删除参数，参数列表从 1 开始计数，<code>$</code> 表示末尾，<code>%</code> 表示全部，<code>.</code> 或不指定表示当前</li>
</ul>
</li>
<li>切换<ul>
<li><code>:[count]n[ext]</code>：编辑当前之后第 count 个文件</li>
<li><code>:[count]N[ext]</code> <code>:[count]prev[ious]</code>：编辑当前之前第 count 个文件</li>
<li><code>:rew[ind]</code> <code>:fir[st]</code>：编辑第一个文件</li>
<li><code>:la[st]</code>：编辑最后一个文件</li>
</ul>
</li>
<li>执行<ul>
<li><code>:[range]argdo {cmd}</code>：对参数列表中的文件批量执行命令；要先设置 <code>hidden</code> 选项。</li>
</ul>
</li>
</ul>
<p>[^wildcard]: <code>*</code> 匹配 0 个或多个字符，范围仅限指定的目录，不含其子目录（如：<code>*.js</code>）；<code>**</code> 也匹配 0 个或多个字符，范围包括指定目录及其子目录（如：<code>**/*.js</code>）。</p>
<h1 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a>在文件中移动</h1><p>动作命令详见 <code>:h motion.txt</code></p>
<h2 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h2><ul>
<li><code>&lt;C-u&gt;</code> 向上滚动半屏</li>
<li><code>&lt;C-d&gt;</code> 向下滚动半屏</li>
<li><code>&lt;C-b&gt;</code> 向上滚动一屏</li>
<li><code>&lt;C-f&gt;</code> 向下滚动一屏</li>
<li><code>[{n}]&lt;C-y&gt;</code> 向上滚动 {n} 行，缺省 1 行</li>
<li><code>[{n}]&lt;C-e&gt;</code> 向下滚动 {n} 行，缺省 1 行</li>
</ul>
<h2 id="在实际行和屏幕行间移动"><a href="#在实际行和屏幕行间移动" class="headerlink" title="在实际行和屏幕行间移动"></a>在实际行和屏幕行间移动</h2><ul>
<li><code>j</code>  向下移动一个实际行</li>
<li><code>gj</code> 向下移动一个屏幕行</li>
<li><code>k</code>  向上移动一个实际行</li>
<li><code>gk</code> 向上移动一个屏幕行</li>
<li><code>0</code>  移动到实际行的行首</li>
<li><code>g0</code> 移动到屏幕行的行首</li>
<li><code>^</code>  移动到实际行的第一个非空白字符</li>
<li><code>g^</code> 移动到屏幕行的第一个非空白字符</li>
<li><code>$</code>  移动到实际行的行尾</li>
<li><code>g$</code> 移动到屏幕行的行尾</li>
</ul>
<h2 id="基于单词、字串、句子、段落移动"><a href="#基于单词、字串、句子、段落移动" class="headerlink" title="基于单词、字串、句子、段落移动"></a>基于单词、字串、句子、段落移动</h2><p><strong>基于单词移动</strong></p>
<p><code>w</code>  移动到下一个词头<br><code>b</code>  移动到上一个词头<br><code>e</code>  移动到下一个词尾<br><code>ge</code> 移动到上一个词尾</p>
<p><strong>基于字串移动</strong></p>
<p>只需将上述4个命令中的<code>w</code> <code>b</code> <code>e</code>换成大写</p>
<p>单词由字母、数字、下划线组成，或由连续的其他符号组成；字串由非空白符组成，由空白符分隔。</p>
<p><strong>基于句子移动</strong></p>
<p><code>(</code> <code>)</code> 跳转到上一句/下一句开头</p>
<p><strong>基于段落移动</strong></p>
<p><code>{</code> <code>}</code> 跳转到上一段/下一段开头</p>
<h2 id="行内查找"><a href="#行内查找" class="headerlink" title="行内查找"></a>行内查找</h2><ul>
<li><code>f{char}</code> 正向移动到下一个{char}所在之处</li>
<li><code>F{char}</code> 反向移动到上一个{char}所在之处</li>
<li><code>t{char}</code> 正向移动到下一个{char}所在之处的前一个字符上</li>
<li><code>T{char}</code> 反向移动到上一个{char}所在之处的后一个字符上</li>
<li><code>;</code> 正向重复上一次字符查找命令</li>
<li><code>,</code> 反向重复上一次字符查找命令</li>
</ul>
<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p><code>i</code> 表示分隔符内的文本，<code>a</code> 表示包含分隔符本身及其内部文本。用 surround 插件可以方便地操作分隔符。</p>
<ul>
<li><code>i)</code> <code>ib</code> 圆括号(parentheses)；<code>i)</code>与<code>i(</code>一样，下同</li>
<li><code>i}</code> <code>iB</code> 花括号(braces)</li>
<li><code>i]</code> 方括号(brackets)</li>
<li><code>i&gt;</code> 尖括号(angle brackets)</li>
<li><code>i&#39;</code> 单引号(single quotes)</li>
<li><code>i&quot;</code> 双引号(double quotes)</li>
<li><code>i`</code> 反引号(backticks)</li>
<li><p><code>it</code> XML标签(tags)</p>
</li>
<li><p><code>iw</code> <code>aw</code> 当前单词；当前单词及一个空格</p>
</li>
<li><code>iW</code> <code>aW</code> 当前字串；当前字串及一个空格</li>
<li><code>is</code> <code>as</code> 当前句子；当前句子及一个空格</li>
<li><code>ip</code> <code>ap</code> 当前段落；当前段落及一个空行</li>
</ul>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><ul>
<li><code>m{a-zA-Z}</code> 设置标记。小写只在该缓冲区内可见，大写全局可见</li>
<li><code>`{mark}</code> 跳转到标记处的行和列</li>
<li><code>&#39;{mark}</code> 跳转到标记处的行首</li>
<li><code>:marks</code> 获取所有标记的列表</li>
<li><code>:delmarks {mark1} {mark2}</code> 删除指定标记；同时删除的多个标记之间用空格分隔</li>
</ul>
<p><strong>自动位置标记</strong></p>
<ul>
<li><code>`</code> 当前文件中上次跳转动作之前的位置</li>
<li><code>`.</code> 上次修改的地方</li>
<li><code>`^</code> 上次插入的地方</li>
<li><code>`[</code> 上次修改或复制的起始位置</li>
<li><code>`]</code> 上次修改或复制的结束位置</li>
<li><code>`&lt;</code> 上次高亮选区的起始位置</li>
<li><code>`&gt;</code> 上次高亮选区的结束位置</li>
<li><code>%</code> 在一组开、闭括号间跳转，vim 会在跳转发生的地方设置一个标记</li>
</ul>
<h1 id="在文件间跳转"><a href="#在文件间跳转" class="headerlink" title="在文件间跳转"></a>在文件间跳转</h1><p>哪些动作算<strong>跳转</strong>？</p>
<ul>
<li>简单来说，大范围的动作命令可能被当作跳转，小范围的动作命令只能算作移动；</li>
<li>面向句子、段落，甚至文件之间的移动（如 <code>:edit</code>）都算跳转；</li>
</ul>
<p>以下是部分跳转命令</p>
<ul>
<li><code>[count]G</code> 跳转到指定的行号</li>
<li><code>/pattern&lt;CR&gt;</code> <code>?pattern&lt;CR&gt;</code> <code>n</code> <code>N</code> 跳转到模式匹配处</li>
<li><code>%</code> 跳转到括号匹配处</li>
<li><code>(</code> <code>)</code> 跳转到上一句/下一句开头</li>
<li><code>{</code> <code>}</code> 跳转到上一段/下一段开头</li>
<li><code>H</code> <code>M</code> <code>L</code> 跳转到屏幕最上方/正中间/最下方</li>
<li><code>gf</code> 跳转到光标下的文件名</li>
<li><code>&lt;C-]&gt;</code> 跳转到光标下关键字的定义处</li>
<li><code>&#39;{mark}</code> <code>`{mark}</code> 跳转到一个位置标记</li>
</ul>
<h2 id="Vim-为每个窗口维护了一份独立的跳转列表"><a href="#Vim-为每个窗口维护了一份独立的跳转列表" class="headerlink" title="Vim 为每个窗口维护了一份独立的跳转列表"></a>Vim 为每个窗口维护了一份独立的跳转列表</h2><ul>
<li><code>:ju[mps]</code> 查看跳转列表</li>
<li><code>:cle[arjumps]</code> 清除跳转列表</li>
<li><code>&lt;C-o&gt;</code>/<code>&lt;C-i&gt;</code> 反向/正向遍历跳转列表</li>
</ul>
<h2 id="Vim-为每个缓冲区维护了一份独立的改变列表"><a href="#Vim-为每个缓冲区维护了一份独立的改变列表" class="headerlink" title="Vim 为每个缓冲区维护了一份独立的改变列表"></a>Vim 为每个缓冲区维护了一份独立的改变列表</h2><ul>
<li><code>:changes</code> 查看变列表</li>
<li><code>g;</code>/<code>g,</code> 反向/正向遍历改变列表；不会被记录进跳转列表</li>
<li><code>u&lt;C-r&gt;</code> 返回上次修改处。这是一种取巧的做法，通过“撤销-&gt;重做”来移动光标</li>
</ul>
<h2 id="Vim-会自动创建一些位置标记"><a href="#Vim-会自动创建一些位置标记" class="headerlink" title="Vim 会自动创建一些位置标记"></a>Vim 会自动创建一些位置标记</h2><p><code>gi</code> 返回上次退出 insert 模式的位置，并进入 insert 模式</p>
<h2 id="Vim-会把文档中的文件名当成一个超链接"><a href="#Vim-会把文档中的文件名当成一个超链接" class="headerlink" title="Vim 会把文档中的文件名当成一个超链接"></a>Vim 会把文档中的文件名当成一个超链接</h2><ul>
<li><code>gf</code> 打开光标下的文件名，此动作会在跳转列表中增加一条记录</li>
<li><code>:set suffixesadd+=.suffix</code> 指定一个或多个文件扩展名，当 Vim 用 <code>gf</code> 搜索文件名时，会尝试用这些扩展名</li>
<li><code>:set path+={path}</code>  <code>gf</code> 除了会在工作目录的相对目录中搜索外，也会在 <code>path</code> 中的路径下搜索</li>
</ul>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul>
<li>无名寄存器<ul>
<li><code>&quot;&quot;</code>：缓存最后一次操作内容</li>
</ul>
</li>
<li>具名寄存器<ul>
<li><code>&quot;a</code>~<code>&quot;z</code>：通过指定名称来使用。同一字母大小写是同一个寄存器，小写会覆盖寄存器内原有内容，大写会续接原有内容。</li>
</ul>
</li>
<li>数字寄存器<ul>
<li><code>&quot;0</code>：复制专用寄存器，只受 <code>y{motion}</code> 影响</li>
<li><code>&quot;1</code>~<code>&quot;9</code>：缓存最近 9 次删除内容</li>
</ul>
</li>
<li>行内删除寄存器<ul>
<li><code>&quot;-</code>：行内删除寄存器</li>
</ul>
</li>
<li>只读寄存器<ul>
<li><code>&quot;%</code>：当前文件名</li>
<li><code>&quot;#</code>：轮换文件名（当前交替文件名）</li>
<li><code>&quot;.</code>：上次插入的文本</li>
<li><code>&quot;:</code>：上次执行的 Ex 命令</li>
</ul>
</li>
<li>模式寄存器<ul>
<li><code>&quot;/</code>：上次查找的模式</li>
</ul>
</li>
<li>表达式寄存器<ul>
<li><code>&quot;=</code>：只读，用于执行表达式命令</li>
</ul>
</li>
<li>黑洞寄存器<ul>
<li><code>&quot;_</code>：不缓存内容，用于彻底删除</li>
</ul>
</li>
<li>系统剪贴板<ul>
<li><code>&quot;+</code>：系统剪贴板</li>
<li><code>&quot;*</code>：选择专用寄存器。在X11视窗系统中代表主剪贴板（primary），在其余系统中同系统剪贴板</li>
<li><code>&quot;~</code>：拖放操作寄存器</li>
</ul>
</li>
</ul>
<p><strong>引用一个寄存器</strong></p>
<ul>
<li>insert mode：<code>&lt;C-r&gt;{reg without &quot;}</code>。无需输入寄存器名称中的 <code>&quot;</code>。</li>
<li>normal mode：<code>x</code>、<code>s</code>、<code>d{motion}</code>、<code>c{motion}</code>、<code>y{motion}</code> 以及它们对应的大写命令，在命令前加 <code>{reg}</code> 前缀指定引用某个寄存器。</li>
<li>visual mode：选中高亮内容后同 normal mode。</li>
<li>Ex mode：<code>:delete {reg}</code>、<code>:yank {reg}</code>、<code>:put {reg}</code>。</li>
<li>脚本：<code>@{reg without &quot;}</code></li>
</ul>
<p>缺省引用的是无名寄存器 <code>&quot;&quot;</code>。</p>
<p><strong>查看寄存器内容</strong></p>
<p><code>:reg[s] [{reg}]</code> <code>:di[splay] [{reg}]</code>：查看寄存器，若不指定寄存器名字，则查看全部。</p>
<p><strong>粘贴</strong></p>
<ul>
<li><code>p</code>：粘贴至光标后</li>
<li><code>P</code>：粘贴至光标前</li>
<li><code>gp</code>：粘贴至当前行之前，光标落于被粘贴行末尾</li>
<li><code>gP</code>：粘贴至当前行之后，光标落于被粘贴行开头</li>
</ul>
<p>在终端中使用系统剪贴板进行粘贴时可能会遇到一些问题，详见《Vim实用技巧》之《技巧63》。</p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><strong>录制宏</strong></p>
<ol>
<li><code>q{reg}</code>：开始录制，宏存放于 {reg} 指定的寄存器中，若 {reg} 为大写的具名寄存器，则会将新宏续接在原宏后面</li>
<li><code>q</code>：结束录制</li>
</ol>
<p><strong>执行宏</strong></p>
<ul>
<li><code>[n]@{reg}</code>：执行 {reg} 中保存的宏，可指定运行次数</li>
<li><code>@@</code>：重复上次调用的宏</li>
</ul>
<p><em>以上对寄存器的引用无需使用 <code>&quot;</code></em></p>
<p><strong>编辑宏</strong></p>
<p>以下以寄存器 a 为例。</p>
<ol>
<li>粘贴宏内容：<code>:put a</code> 粘贴至当前行下方，或者 <code>&quot;ap</code> 粘贴至光标之后。</li>
<li>编辑宏内容。</li>
<li>保存新内容至寄存器：<code>0</code>，<code>&quot;ay$</code>。</li>
</ol>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><h2 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h2><p><code>:h perl-patterns</code></p>
<p><strong>全局设置大小写敏感性</strong></p>
<ul>
<li><code>set ignorecase|ic</code> <code>set noignorecase|noic</code>: 大小写敏感关/开（会影响自动补全）。</li>
<li><code>set smartcase|scs</code> <code>set nosmartcase|noscs</code>: 智能模式，只有在设置了 <code>ignorecase</code> 时才生效。</li>
</ul>
<p><strong>临时设置大小写敏感性</strong></p>
<ul>
<li><code>\c</code> <code>\C</code>:忽略/区分大小写，可出现在模式的任意位置</li>
</ul>
<p><strong>4种语法模式</strong></p>
<ul>
<li><code>\v</code>:very magic 模式，除了 <code>_</code>、大小写字母、数字外，都具有特殊含义，<code>#</code> 暂时无特殊含义，但是 Vim 保留扩展其特殊含义的可能</li>
<li><code>\V</code>:very nomagic 模式，除了 <code>\</code>、<code>/</code>、<code>?</code> 外都无特殊含义（后 2 个为查找域结束符）</li>
<li><code>\m</code>:magic 模式，缺省模式，除了 <code>*</code>、<code>^</code>、<code>$</code>、<code>.</code>、<code>~</code>、<code>[</code>、<code>]</code> 外都无特殊含义</li>
<li><code>\M</code>:nomagic 模式，除 了 <code>^</code>、<code>$</code> 外都无特殊含义</li>
</ul>
<p><strong>模式项 详见<code>:h pattern-overview</code></strong></p>
<ul>
<li><code>/(expr1)@&gt;expr2</code>:固化分组。详见另一片正则表达式的博文。</li>
<li><code>/expr1(expr2)@=</code>:肯定型顺序环视。匹配所有满足后置表达式为expr2的expr1。</li>
<li><code>/expr1(expr2)@!</code>:否定型顺序环视。匹配所有满足后置表达式<strong>不</strong>为expr2的expr1。</li>
<li><code>/(expr1)@&lt;=expr2</code>:肯定型逆序环视。匹配所有满足前置表达式为expr1的expr2。</li>
<li><code>/(expr1)@&lt;!expr2</code>:否定型逆序环视。匹配所有满足前置表达式<strong>不</strong>为expr1的expr2。</li>
<li><code>\zs</code>:肯定型逆序环视</li>
<li><code>\ze</code>:肯定型顺序环视</li>
</ul>
<p><strong>不捕获分组内容</strong></p>
<ul>
<li><code>%(pattern)</code>：不捕获分组内容</li>
</ul>
<p><strong>限制符</strong></p>
<ul>
<li><code>{n,m}</code>:  尽可能多地匹配 n ~ m 个元素。</li>
<li><code>{n}</code>:    尽可能多地匹配 n 个元素。</li>
<li><code>{n,}</code>:   尽可能多地匹配 n 及更多个元素。</li>
<li><code>{,m}</code>:   尽可能多地匹配 0 ~ m 个元素。</li>
<li><code>{}</code>:     尽可能多地匹配 0 及更多个元素。</li>
<li><code>{-n,m}</code>: 尽可能少地匹配 n ~ m 个元素。</li>
<li><code>{-n}</code>:   尽可能少地匹配 n 个元素。</li>
<li><code>{-n,}</code>:  尽可能少地匹配 n 及更多个元素。</li>
<li><code>{-,m}</code>:  尽可能少地匹配 0 ~ m 个元素。</li>
<li><code>{-}</code>:    尽可能少地匹配 0 及更多个元素。</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><code>set wrapscan|ws</code>/<code>set nowrapscan|nows</code> 打开/关闭循环查找</li>
<li><code>set hlsearch|hls</code>/<code>set nohlsearch|nohls|hls!</code> 打开/关闭匹配高亮</li>
<li><code>:noh</code> 关闭高亮，直到下一次查找</li>
<li><code>set incsearch|is</code>/<code>set noincsearch|nois</code> 打开/关闭增量查找</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code> 用当前预览的匹配结果对查找域进行自动补全</li>
<li><code>:%s/{pattern}//gn</code> 统计匹配数量。{pattern} 可省略，即使用当前查找模式；<code>n</code> 表示抑制替换</li>
<li><code>q/</code> 调出查找历史命令行窗口</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>完整的substitute语法：<br><code>:[range]s[ubstitute]/{pattern}/{string}/[flags]</code></p>
<p>标志位 <em><code>:h s_flags</code></em>：</p>
<ul>
<li><code>g</code>：在全局范围内执行，即修改一行内所有匹配。</li>
<li><code>c</code>：让用户确认或拒绝每一处修改。<em><code>:h :s_c</code></em><br>  选项：<ul>
<li><code>y</code>：替换此处匹配。</li>
<li><code>n</code>：忽略此处匹配。</li>
<li><code>q</code>：退出替换过程。</li>
<li><code>l</code>：“last”——替换此处匹配后退出。</li>
<li><code>a</code>：“all”——替换此处与之后所有的匹配。</li>
<li><code>&lt;C-e&gt;</code>：向下滚动屏幕，即文本向上移动。</li>
<li><code>&lt;C-y&gt;</code>：向上滚动屏幕，即文本向下移动。</li>
</ul>
</li>
<li><code>n</code>：抑制替换行为，转而报告匹配个数。</li>
<li><code>e</code>：屏蔽错误信息。</li>
<li><code>&amp;</code>：重用上一次 <code>substitute</code> 命令所用的标志位，必须写在 flags 的第一位。</li>
<li><code>i</code>：忽略查找域的大小写。</li>
<li><code>I</code>：不忽略查找域的大小写。</li>
<li><code>p</code>：显示最后一处替换所在行。</li>
<li><code>#</code>：同 <code>p</code>，并加上行号。</li>
<li><code>l</code>：同 <code>p</code>，但显示效果同 <code>:list</code>，即用 <code>^</code> 显示无法打印的字符，并在行尾添加 <code>$</code>。</li>
<li><code>r</code>：只对不带参数的 <code>:&amp;</code> 和 <code>:s</code> 有效，作用同 <code>:~</code>：用最近一次的查找或替换命令中的模式来作为查找域，若最近一次的是替换命令且它的查找域为空，则继续在历史记录中向前查找。</li>
</ul>
<p>替换域中的特殊字符（部分）<br>详见<em><code>:h sub-replace-special</code></em><br>|符号|描述|<br>|:–|:–|<br>|<code>\r</code>|换行符|<br>|<code>\t</code>|制表符|<br>|<code>\\</code>|反斜杠|<br>|<code>\n</code>|第n个子匹配|<br>|<code>\0</code>|匹配模式的所有内容|<br>|<code>&amp;</code>|匹配模式的所有内容|<br>|<code>~</code>|使用上一次调用 <code>:substitute</code> 时的替换域|<br>|<code>\={Vim Script}</code>|执行{Vim Script}表达式，并将结果作为替换域|</p>
<p>替换相关命令<br>|命令|用途|<br>|:–|:–|<br>|<code>:[range]s[ubstitute] [flags] [count]</code> <code>:[range]&amp; [flags] [count]</code>|重复上一次替换操作，但忽略上次的flags，可手动添加flags|<br>|<code>:[range]&amp;&amp; [count]</code>|重复上一次替换操作，并带有上次的flags|<br>|<code>:[range]~[&amp;][flags] [count]</code>|同 <code>:&amp;r</code>|<br>|<code>&amp;</code>|同 <code>:s</code>|<br>|<code>g&amp;</code>|同 <code>:%s//~/&amp;</code>，其中查找域的内容用的是最近一次查找或替换命令所用的查找域<em>global substitute</em>|<br>|<code>:[range]sno[magic]</code>|同<code>:substitute</code>，但使用nomagic模式|<br>|<code>:[range]sm[agic]</code>|同<code>:substitute</code>，但使用magic模式|</p>
<p>global命令</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>:[range]g[lobal]/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">在range（缺省为整个文件<code>%</code>）范围内，对{pattern}匹配处执行cmd命令（缺省为<code>:p[rint]</code>），可以指定cmd的执行范围，<code>.</code>表示{pattern}匹配行，{finish}可通过偏移或匹配命令<code>/{pattern}/</code>指定</td>
</tr>
<tr>
<td style="text-align:left"><code>:[range]g[lobal]!/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">在range（缺省为整个文件<code>%</code>）范围内，对{pattern}不匹配处执行cmd命令（缺省为<code>:p[rint]</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>:[range]v[global]/{pattern}/[.,{finish}] [cmd]</code></td>
<td style="text-align:left">同上</td>
</tr>
</tbody>
</table>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="vim-surroud"><a href="#vim-surroud" class="headerlink" title="vim-surroud"></a>vim-surroud</h2><p><code>ds</code> 和 <code>cs</code> 命令接受一个 target 作为第一个参数。目前所有的 target 都是单字符的。</p>
<ul>
<li><code>(</code> <code>)</code> <code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>&lt;</code> <code>&gt;</code> 代表它们自身以及与其对应的另一个字符。</li>
<li><code>b</code> <code>B</code> <code>r</code> <code>a</code> 分别是 <code>)</code> <code>}</code> <code>]</code> <code>&gt;</code> 的别名，其中前两个沿用 Vim 的设定。</li>
<li><p><code>&#39;</code> <code>&quot;</code> <figure class="highlight plain"><figcaption><span>代表它们自身（成对地），它们仅会在当前行被搜索。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">- `t` 代表一对 HTML/XML 标签。</span><br><span class="line">- `w` `W` `s` `p` 分别代表一个单词、字串、句子、段落。</span><br><span class="line"></span><br><span class="line">`cs` `ys` `vS` 需要一个单字符的 replacement 参数</span><br><span class="line"></span><br><span class="line">- 若使用 `)` `]` `&#125;` `&gt;`，则会正确匹配另一半符号。</span><br><span class="line">- 若使用 `(` `[` `&#123;`（`&lt;` 除外），则会正确匹配另一半符号，并在中间填充额外的空格。</span><br><span class="line">- `b` `B` `r` `a` 分别是 `)` `&#125;` `]` `&gt;` 的别名。</span><br><span class="line">- `&lt;C-]&gt;` 代表了 C 语言风格的 `&#123;&#125;`。</span><br><span class="line">- 若使用 `t` `&lt;`，则 Vim 会要求继续输入标签的属性。可以输入 `&lt;CR&gt;` 或 `&gt;` 来表示完成输入。Vim 会自动匹配闭标签。若使用 `&lt;C-t&gt;`，则生成的标签会自动换行。</span><br><span class="line">- 若使用 `s` ，则 Vim 会自动在开头加个空格，这样可以有效地删除 `()`。</span><br><span class="line">- surround 默认将字母 `l` 作为 Latex 的分隔符。</span><br><span class="line"></span><br><span class="line">除了上述的字符外，其余单字符会与其自身匹配成一对。</span><br><span class="line"></span><br><span class="line">**normal mode**</span><br><span class="line"></span><br><span class="line">- `ds&lt;s&gt;`：删除分隔符 `&lt;s&gt;`</span><br><span class="line">- `cs&lt;s&gt;&lt;t&gt;`：将 `&lt;s&gt;` 替换为 `&lt;t&gt;`</span><br><span class="line">- `cS&lt;s&gt;&lt;t&gt;`：将 `&lt;s&gt;` 替换为 `&lt;t&gt;`，并添加换行和缩进</span><br><span class="line">- `ys&#123;motion&#125;&lt;s&gt;` `ys&#123;文本对象&#125;&lt;s&gt;`：在指定文本外添加分隔符</span><br><span class="line">- `yS&#123;motion&#125;&lt;s&gt;` `yS&#123;文本对象&#125;&lt;s&gt;`：在指定文本外添加分隔符，并添加换行和缩进</span><br><span class="line">- `yss&lt;s&gt;`：在当前行外添加分隔符</span><br><span class="line">- `ySs&lt;s&gt;` `ySS&lt;s&gt;`：在当前行外添加分隔符，并添加换行和缩进</span><br><span class="line"></span><br><span class="line">**visual mode**</span><br><span class="line"></span><br><span class="line">- `S&lt;s&gt;`：在高亮选区外添加分隔符</span><br><span class="line"></span><br><span class="line">**insert mode**</span><br><span class="line"></span><br><span class="line">- `&lt;C-g&gt;s&lt;s&gt;` `&lt;C-S&gt;&lt;s&gt;`：插入分隔符并将光标置入分隔符中间；后者在终端中会使终端冻结</span><br><span class="line"></span><br><span class="line">**个性化**</span><br><span class="line"></span><br><span class="line">*`:h surround-customizing`*</span><br><span class="line"></span><br><span class="line">1. 在特定类型文件中启用自定义的分隔符。</span><br><span class="line">  `autocmd FileType php let b:surround_45 = &quot;&lt;?php \r ?&gt;&quot;`</span><br><span class="line">  其中，</span><br><span class="line">  - `php` 是指定的文件类型；</span><br><span class="line">  - `b` 表示后面的变量作用域为当前缓冲区；</span><br><span class="line">  - `surround_` 为变量名中的固定部分；</span><br><span class="line">  - `45` 为字符 `-` 的 ASCII 码（字符和 ASCII 码之间的转换可用 `char2nr()` 和 `nr2char()` 函数）；</span><br><span class="line">  - 回车符 `\r` 会被原始文本（即被分隔符包围的原文）替换。</span><br><span class="line">2. 动态输入分隔符标签中的内容。</span><br><span class="line">  `let g:surround_108 = &quot;\\begin&#123;\1environment: \1&#125;\r\\end&#123;\1\1&#125;&quot;`</span><br><span class="line">  - `\1` 表示输入参数，最高支持到 `\7`；</span><br><span class="line">  - 两个 `\1` 之间的内容会作为提示在用户输入时弹出，并最终会被输入的内容替换；</span><br><span class="line">  - 回车符 `\r` 会被原始文本（即被分隔符包围的原文）替换。</span><br><span class="line">3. 使用正则表达式完成额外的功能。</span><br><span class="line">    `let g:surround_108 = &quot;\\begin&#123;\1environment: \1&#125;\r\\end&#123;\1\r&#125;.*\r\1&#125;&quot;`</span><br><span class="line">    - 在第二组 `\1` 中，第一个 `\r` 后面跟的是替换操作所用的 pattern，第二个 `\r` 后面跟的是替换操作所用的 replacement。最终的效果是：第一组 `\1` 之间的内容会被输入内容替换；第二组 `\1` 之间的内容先被输入内容替换，然后用 pattern 进行匹配，匹配到的内容会被 replacement 替换，至此确定最终结果。</span><br><span class="line">    `let g:surround_&#123;char2nr(&quot;d&quot;)&#125; = &quot;&lt;div\1id: \r..*\r id=\&quot;&amp;\&quot;\1&gt;\r&lt;/div&gt;&quot;`</span><br><span class="line">    - 其中 `&amp;` 表示在第一组 `\r` 中匹配到的内容（`:h s/\&amp;`）</span><br><span class="line">4. 为分隔符自动添加后缀</span><br><span class="line">    `let g:surround_insert_tail = &quot;&lt;++&gt;&quot;`</span><br><span class="line">    - 在 insert 模式下使用 `&lt;C-g&gt;s&lt;s&gt;` 插入分隔符时会自动给分隔符添加后缀；</span><br><span class="line">    - 该变量的名称固定，且作用域必须是全局 `g:`；</span><br><span class="line">    - `&lt;++&gt;` 为自定义的后缀；</span><br><span class="line">    - 只能在 insert 模式下生效。</span><br><span class="line"></span><br><span class="line">## Vim 内部的 Grep</span><br><span class="line"></span><br><span class="line">`:vim[grep][!] /&#123;pattern&#125;/[g][j] &#123;file&#125;...`</span><br><span class="line">- `g`：缺省只为每个出现匹配的行创建一条记录。此参数的作用：若同一行中有多处匹配，则为每一处匹配创建一条记录。</span><br><span class="line">- `j`：缺省 Vim 会跳转到第一处匹配。此参数的作用：只更新 quickfix 列表，但不跳到第一处匹配。</span><br><span class="line">- `file`：可接受的参数同`:args`。</span><br><span class="line"></span><br><span class="line">## ctrlp</span><br><span class="line"></span><br><span class="line">### 快捷键</span><br><span class="line"></span><br><span class="line">`:h ctrlp-commands`</span><br><span class="line"></span><br><span class="line">- `&lt;C-p&gt;` `:CtrlP [starting-dir]` 启动文件查找模式，可指定目录。</span><br><span class="line">- 在输入框中</span><br><span class="line">  - `&lt;C-d&gt;` 在全路径搜索(`&gt;&gt;&gt;`)和文件名搜索(`&gt;d&gt;`)之间切换。</span><br><span class="line">  - `&lt;C-r&gt;` 在字符串匹配(`&gt;&gt;&gt;`)和正则匹配(`r&gt;&gt;`)之间切换。</span><br><span class="line">  - `&lt;C-f&gt;` `&lt;C-up&gt;` `&lt;C-b&gt;` `&lt;C-down&gt;` 循环切换搜索模式：普通（文件查找）、缓冲区查找、最近历史查找（MRU）。</span><br><span class="line">  - `&lt;tab&gt;` 自动补全目录名。</span><br><span class="line">  - `&lt;S-tab&gt;` 在匹配窗口和输入框之间切换。</span><br><span class="line">    - 在匹配窗口按下任意字符来选中首字符匹配的项目。多次按同一字符会在多个首字符匹配的项目间循环。</span><br><span class="line">- 移动</span><br><span class="line">  - `&lt;C-k&gt;` `&lt;up&gt;` `&lt;C-j&gt;` `&lt;down&gt;` 向上、向下。</span><br><span class="line">  - `&lt;C-a&gt;` `&lt;C-e&gt;` 移至输入框开头/末尾。</span><br><span class="line">  - `&lt;C-h&gt;` `&lt;left&gt;` `&lt;C-^&gt;` `&lt;C-l&gt;` `&lt;right&gt;` 左移、右移。</span><br><span class="line">- 编辑</span><br><span class="line">  - `&lt;C-]&gt;` `&lt;bs&gt;` `&lt;del&gt;` 左删、右删一个字符。</span><br><span class="line">  - `&lt;C-w&gt;` 左删一个词。</span><br><span class="line">  - `&lt;C-u&gt;` 清空。</span><br><span class="line">- 浏览输入记录</span><br><span class="line">  - `&lt;C-n&gt;` `&lt;C-p&gt;` 上翻、下翻。</span><br><span class="line">- 打开/创建文件</span><br><span class="line">  - `&lt;CR&gt;` 在当前窗口打开。</span><br><span class="line">  - `&lt;C-t&gt;` 在新 tab 打开。</span><br><span class="line">  - `&lt;C-v&gt;` 在新水平分割窗口打开。</span><br><span class="line">  - `&lt;C-x&gt;` `&lt;C-x&gt;` `&lt;C-CR&gt;` `&lt;C-s&gt;` 在新垂直分割窗口打开。</span><br><span class="line">  - `&lt;C-y&gt;` 创建新文件。</span><br><span class="line">- 打开多个文件</span><br><span class="line">  - `&lt;C-z&gt;` 标记/取消标记一个待打开的文件；标记/取消标记一个文件，它所在的目录会作为创建新文件的目录 `&lt;C-y&gt;`。</span><br><span class="line">  - `&lt;C-o&gt;` 打开所有被标记的文件。若没有标记文件的话就根据以下选项打开一个控制台对话框：</span><br><span class="line">    - `t` 在 tab 中。</span><br><span class="line">    - `v` 在垂直分割窗口中。</span><br><span class="line">    - `h` 在水平分割窗口中。</span><br><span class="line">    - `r` 在当前窗口。</span><br><span class="line">    - `i` 作为隐藏缓冲区。</span><br><span class="line">    - `x` （可选）使用 `g:ctrlp_open_func` 定义的函数。</span><br><span class="line">    - `a` 标记匹配窗口中的所有文件。</span><br><span class="line">    - `d` 将 ctrlp 的工作目录切换到所选文件的目录。</span><br><span class="line">- 函数快捷键</span><br><span class="line">  - `&lt;F5&gt;` 全量刷新匹配窗口和最近历史记录（MRU）。</span><br><span class="line">  - `&lt;F7&gt;` 清空 MRU 或删除 MRU 中被标记的项目。</span><br><span class="line">- 粘贴</span><br><span class="line">  - `&lt;Insert&gt;` `&lt;MiddleMouse&gt;` 将剪贴板粘贴至输入框。</span><br><span class="line">  - `&lt;C-\&gt;` 弹出一个对话框来选择粘贴的内容：光标下的词、光标下的文件名、搜索寄存器内容、最近的框选内容、系统剪贴板、指定寄存器。</span><br><span class="line"></span><br><span class="line">### 输入格式</span><br><span class="line"></span><br><span class="line">- 简单字符串：&apos;abc&apos; 相当于 `a[^a]\&#123;-&#125;b[^b]\&#123;-&#125;c`。</span><br><span class="line">- 正则表达式：按照 vim 的正则规则。</span><br><span class="line">- 字符串后紧跟 `:&#123;cmd&#125;`：指定打开文件后执行的命令。</span><br><span class="line">- 切换目录</span><br><span class="line">  - `..`：往上一级。后续每多一个点表示再往上一级。</span><br><span class="line">  - `@cd &#123;path&#125;` 切换目录。</span><br><span class="line">  - `@cd %:h` 切换到当前文件的目录。</span><br><span class="line">  - `/` `\` 切换到项目根目录。</span><br><span class="line">- `?` 帮助文件。</span><br><span class="line"></span><br><span class="line">### 自定义</span><br><span class="line"></span><br><span class="line">`:h ctrlp-customization` `:h ctrlp-options`</span><br><span class="line"></span><br><span class="line">- 更改启动命令</span><br><span class="line">  - `let g:ctrlp_map = &apos;&lt;C-p&gt;&apos;`</span><br><span class="line">  - `let g:ctrlp_cmd = &apos;CtrlP&apos;`</span><br><span class="line">- 不带指定目录启动时</span><br><span class="line">  - `let g:ctrlp_working_path_mode = &apos;ra&apos;`</span><br><span class="line">    - `c` 当前文件所在目录。</span><br><span class="line">    - `a` 当前文件所在目录，除非它是 `cwd` 的子目录。</span><br><span class="line">    - `r` 父目录中最近一个包含版本控制信息的目录：`.git`、`.hg`、`.svn`、`.bzr`、`_darcs`。</span><br><span class="line">      - `let g:ctrlp_root_marks = [&apos;pom.xml&apos;, &apos;.p4ignore&apos;]` 自定义父目录的标识。</span><br><span class="line">    - `w` 作为 `r` 的修饰符，从 `cwd` 开始搜索，而不是当前文件所在目录。</span><br><span class="line">    - `0` `&apos;&apos;` 禁用此特性。</span><br><span class="line">- 排除文件和目录</span><br></pre></td></tr></table></figure></p>
<p>“ vim 自带的排除方式<br>set wildignore+=<em>/tmp/</em>,<em>.so,</em>.swp,<em>.zip     “ MacOSX/Linux<br>set wildignore+=</em>\tmp\<em>,</em>.swp,<em>.zip,</em>.exe  “ Windows</p>
<p>“ ctrlp 的排除方式<br>let g:ctrlp_custom_ignore = ‘\v[\/].(git|hg|svn)$’<br>let g:ctrlp_custom_ignore = {<br>  \ ‘dir’:  ‘\v[\/].(git|hg|svn)$’,<br>  \ ‘file’: ‘\v.(exe|so|dll)$’,<br>  \ ‘link’: ‘some_bad_symbolic_links’,<br>  \ }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 排除 `.gitignore` 中的文件和目录</span><br></pre></td></tr></table></figure>
<p>let g:ctrlp_user_command = [‘.git’, ‘cd %s &amp;&amp; git ls-files -co –exclude-standard’]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自定义的搜索规则</span><br></pre></td></tr></table></figure>
<p>let g:ctrlp_user_command = ‘find %s -type f’        “ MacOSX/Linux<br>let g:ctrlp_user_command = ‘dir %s /-n /b /s /a-d’  “ Windows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## fugitive</span><br><span class="line"></span><br><span class="line">### 对象 fugitive-objects</span><br><span class="line"></span><br><span class="line">- `:` 同 `:Gstatus`</span><br><span class="line">- `.git/config` 仓库的配置文件</span><br><span class="line">- `HEAD` .git/HEAD</span><br><span class="line">- `refs/heads/x` .git/refs/heads/x</span><br><span class="line">- 当前文件</span><br><span class="line">  - `:%` 当前文件在暂存区中的对应文件</span><br><span class="line">  - `@~2:%` 当前文件在 HEAD 的祖父提交中的对应文件</span><br><span class="line">  - `:1:%` 冲突状态中，当前文件在共同祖先中的对应文件</span><br><span class="line">  - `:2:#` 冲突状态中，当前文件在目标分支中的对应文件</span><br><span class="line">- 指定文件名的文件</span><br><span class="line">  - `./master` 工作目录下名为 master 的文件</span><br><span class="line">  - `Makefile` 工作区中名为 Makefile 的文件</span><br><span class="line">  - `@^:Makefile` HEAD 的父提交中名为 Makefile 的文件</span><br><span class="line">  - `:Makefile` 暂存区中的 Makefile 文件</span><br><span class="line">  - `!:Makefile` 包含当前文件的提交中的名为 Makefile 的文件</span><br><span class="line">- 提交</span><br><span class="line">  - `@` HEAD 指向的提交</span><br><span class="line">  - `master^` master 的父提交</span><br><span class="line">  - `master:` master 指向的 tree 对象</span><br><span class="line">  - `!` 包含当前文件的提交</span><br><span class="line">- 指定缓冲区中的文件</span><br><span class="line">  - `:3:#5` 冲突状态中，缓冲区 #5 中文件在被合并分支中对应的文件</span><br><span class="line">  - `!3^2` 包含缓冲区 #3 中文件的提交的第二父提交</span><br><span class="line"></span><br><span class="line">### 命令</span><br><span class="line"></span><br><span class="line">**通用**</span><br><span class="line"></span><br><span class="line">- `Git &#123;args&#125;` 执行 Git 命令，相当于 `:!git &#123;args&#125;`。</span><br><span class="line">- `Git! &#123;args&#125;` 执行 Git 命令，将结果输出到临时文件。</span><br><span class="line">- `Gcd|Glcd [&#123;dir&#125;]` cd/lcd 到项目根目录。</span><br><span class="line"></span><br><span class="line">**本地仓库**</span><br><span class="line"></span><br><span class="line">- `G[status]` 在新窗口中查看 git status。</span><br><span class="line">  - `g?` 查看 fugitive-mappings。</span><br><span class="line">  - `-` add/reset 某个文件的修改。</span><br><span class="line">  - `=` 展开各个差异块。</span><br><span class="line">- `Gdiff` 查看当前文件工作区到暂存区的差异。</span><br><span class="line">  - `Gsdiff` 横向分割窗口</span><br><span class="line">  - `Gvdiff` 纵向分割窗口</span><br><span class="line">- `Gcommit &#123;args&#125;` 提交当前文件，在新窗口中编辑提交信息。</span><br><span class="line">- `Gmerge &#123;args&#125;` 合并分支，在 quickfix 窗口中列出冲突文件。</span><br><span class="line">- `Grebase`</span><br><span class="line">- `Gmove` git mv 同时会重命名缓冲区。</span><br><span class="line">- `Gdelete` git rm 同时会删除缓冲区。</span><br><span class="line">- `Gread` git checkout -- filename</span><br><span class="line">- `Gwrite` 将缓冲区写到工作区和暂存区。</span><br><span class="line">- `Ge` `Gsp` `Gvsp` `Gtabe` 查看指定的对象、树、提交或标签。</span><br><span class="line"></span><br><span class="line">**远程仓库**</span><br><span class="line"></span><br><span class="line">- `Gfetch &#123;args&#125;` `Gpull &#123;args&#125;` `Gpush &#123;args&#125;`</span><br><span class="line"></span><br><span class="line">**历史日志**</span><br><span class="line"></span><br><span class="line">- `Gblame [flags]` flags 会被传递给 git-blame。</span><br><span class="line">  在 blame 窗口可以使用以下热键：</span><br><span class="line">  - `g?` 帮助</span><br><span class="line">  - `A` 重置尺寸至作者列</span><br><span class="line">  - `C` 重置尺寸至提交列</span><br><span class="line">  - `D` 重置尺寸至日期列</span><br><span class="line">  - `q` 退出 blame</span><br><span class="line">  - `gq` 退出 blame 并 `:Gedit` 工作区中的版本（不懂跟 `q` 有什么区别）</span><br><span class="line">  - `&lt;CR&gt;` 打开光标下的提交</span><br><span class="line">  - `o` 在水平分割窗口打开提交</span><br><span class="line">  - `O` 在新标签页打开提交</span><br><span class="line">  - `p` 在预览窗口打开提交</span><br><span class="line">  - `-` 在光标下的提交上再做 blame</span><br><span class="line">  - `~` 在第 [count] 个第一父提交上再做 blame</span><br><span class="line">  - `P` 在第 [count] 父提交上再做 blame（相当于 HEAD^[count]）</span><br><span class="line">- `0Glog` 通过 quickfix 窗口遍历当前文件历史。</span><br><span class="line">- `Glog &#123;args&#125;` 通过 quickfix 窗口浏览提交历史。</span><br><span class="line">  - `--` 查看所有提交，否则查看涉及当前文件的提交。</span><br><span class="line">- `Gllog &#123;args&#125;` 类似 `Glog`，不过是用 location list。</span><br><span class="line"></span><br><span class="line">### 热键</span><br><span class="line"></span><br><span class="line">这些热键大多数都能在 `:Gstatus` 窗口和 fugitive 对象窗口使用。</span><br><span class="line"></span><br><span class="line">**暂存和撤销**</span><br><span class="line"></span><br><span class="line">- `s` stage 光标下的文件或块。</span><br><span class="line">- `u` unstange 光标下的文件或块。</span><br><span class="line">- `-` stage/unstage 光标下的文件或块。</span><br><span class="line">- `&lt;C-N&gt;` 跳到下个文件或块。</span><br><span class="line">- `&lt;C-P&gt;` 跳到上个文件或块。</span><br><span class="line">- `X` 放弃光标下的改动，即 checkout 或 clean。</span><br><span class="line">- `=` 在光标处切换内联差异比较。</span><br><span class="line">- `&lt;` 在光标处插入内联差异比较。</span><br><span class="line">- `&gt;` 在光标处移除内联差异比较。</span><br><span class="line">- `i` 对于未跟踪文件，执行 `git add --intent-to-add`。否则移至下个块并展开内联差异比较</span><br><span class="line">- `dd` 对光标下的文件执行 `:Gdiff`。</span><br><span class="line">- `ds` 对光标下的文件执行 `:Gsdiff`。</span><br><span class="line">- `dv` 对光标下的文件执行 `:Gvdiff`。</span><br><span class="line">- `P` 对光标下的文件执行 `:Git add --patch` 或 `:Git reset --patch`。</span><br><span class="line"></span><br><span class="line">**导航**</span><br><span class="line"></span><br><span class="line">- `&lt;CR&gt;` 打开光标下的文件或对象。</span><br><span class="line">- `o` `gO` 在新窗口中打开光标下的文件或对象。</span><br><span class="line">- `O` 在新标签页中打开光标下的文件或对象。</span><br><span class="line">- `~` 相当于 Git 的 `~`。</span><br><span class="line">- `P` 相当于 Git 的 `^`。</span><br><span class="line">- `C` 打开包含当前文件的提交。</span><br><span class="line">- `&lt;C-W&gt;C` 在新窗口中打开包含当前文件的提交。</span><br><span class="line"></span><br><span class="line">**提交**</span><br><span class="line"></span><br><span class="line">- `cc` 创建提交。</span><br><span class="line">- `ca` commit --amend 并编辑提交信息。</span><br><span class="line">- `ce` commit --amend 且不编辑提交信息。</span><br><span class="line">- `cw` 编辑最近一次提交。</span><br><span class="line">- `cvc` 带 `-v` 提交。</span><br><span class="line">- `cva` 带 `-v` amend。</span><br><span class="line">- `cf` 为光标下的提交创建一个 fixup 提交。</span><br><span class="line">- `cs` 为光标下的提交创建一个 squash 提交。</span><br><span class="line">- `cA` 为光标下的提交创建一个 squash 提交并编辑信息。</span><br><span class="line"></span><br><span class="line">**Rebase**</span><br><span class="line"></span><br><span class="line">- `ri` 执行交互式 rebase，以光标下提交的父提交作为基准。</span><br><span class="line">- `rf` 执行自动压缩 rebase，以光标下提交的父提交作为基准。</span><br><span class="line">- `ru` 以 upstream 分支为基准执行交互式 rebase。</span><br><span class="line">- `rp` 以 push 分支为基准执行交互式 rebase。</span><br><span class="line"></span><br><span class="line">### 其他</span><br><span class="line"></span><br><span class="line">`set statusline=%&#123;FugitiveStatusline()&#125;` 在状态栏添加分支信息</span><br><span class="line"></span><br><span class="line">## gitgutter</span><br><span class="line"></span><br><span class="line">更新频率取决于 vim 的 `updatetime` 选项，默认 4000 ms。</span><br><span class="line"></span><br><span class="line">同一文件改动超过 500 处时，会隐藏标记。可设置 `let g:gitgutter_max_signs = 500`</span><br><span class="line"></span><br><span class="line">### 快捷键</span><br><span class="line"></span><br><span class="line">- `[c` `]c` 在改动块间跳转。</span><br><span class="line">- `&lt;leader&gt;hp` 预览改动块。</span><br><span class="line">- `&lt;leader&gt;hs` 暂存改动块。</span><br><span class="line">- `&lt;leader&gt;hu` 回退改动块。（不是 unstage）</span><br><span class="line">- 整体开关</span><br><span class="line">  - `:GitGutterDisable`</span><br><span class="line">  - `:GitGutterEnable`</span><br><span class="line">  - `:GitGutterToggle`</span><br><span class="line">- 缓冲区独立开关</span><br><span class="line">  - `:GitGutterBufferDisable`</span><br><span class="line">  - `:GitGutterBufferEnable`</span><br><span class="line">  - `:GitGutterBufferToggle`</span><br><span class="line">- 标记开关</span><br><span class="line">  - `:GitGutterSignsDisable`</span><br><span class="line">  - `:GitGutterSignsEnable`</span><br><span class="line">  - `:GitGutterSignsToggle`</span><br><span class="line">- 行高亮</span><br><span class="line">  - `:GitGutterLineHighlightsDisable`</span><br><span class="line">  - `:GitGutterLineHighlightsEnable`</span><br><span class="line">  - `:GitGutterLineHighlightsToggle`</span><br><span class="line"></span><br><span class="line">### 文本对象</span><br><span class="line"></span><br><span class="line">- `ic` 改动块中的所有行。</span><br><span class="line">- `ac` 改动块中的所有行以及后面紧跟的所有空行。</span><br><span class="line"></span><br><span class="line">### 折叠</span><br><span class="line"></span><br><span class="line">- `:GitGutterFold` 折叠/展开所有未改动的行。</span><br><span class="line">- `zr` 展开改动块前后 3 行。</span><br><span class="line"></span><br><span class="line"># 折叠</span><br><span class="line"></span><br><span class="line">## 折叠相关的 Vim 变量</span><br><span class="line"></span><br><span class="line">|变量          |含义                                    |</span><br><span class="line">|:-------------|:---------------------------------------|</span><br><span class="line">|`v:foldstart` |折叠首行的行号                          |</span><br><span class="line">|`v:foldend`   |折叠末行的行号                          |</span><br><span class="line">|`v:folddashes`|一个含有连字符的字符串，用来表示折叠级别|</span><br><span class="line">|`v:foldlevel` |折叠级别                                |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 折叠选项</span><br><span class="line"></span><br><span class="line">- **颜色 COLORS**</span><br><span class="line">关闭的折叠的颜色由 Folded 高亮组（*hl-Folded*）设定。折叠栏的颜色由 FoldColumn 组（*hl-FoldColumn*）设定。</span><br><span class="line">`:highlight Folded guibg=grey guifg=blue`</span><br><span class="line">`:highlight FoldColumn guibg=darkgrey guifg=white`</span><br><span class="line">- **折叠级别 FOLDLEVEL**</span><br><span class="line">包含行数小于等于 `foldlevel` 的折叠始终以展开的形式来显示。</span><br><span class="line">`foldlevel` 被改变后立即生效。</span><br><span class="line">- **折叠文本 FOLDTEXT**</span><br><span class="line">`foldtext` 是一个字符串表达式，定义了关闭折叠时所显示的文字。如：</span><br><span class="line">` :set foldtext=v:folddashes.substitute(getline(v:foldstart),&apos;/\\*\\\|\\*/\\\|&#123;&#123;&#123;\\d\\=&apos;,&apos;&apos;,&apos;g&apos;)`</span><br><span class="line">在折叠时显示被折叠文本的首行的内容，并删除了其中的&quot;/*&quot;、&quot;*/&quot;、&quot;&#123;&#123;&#123;&quot;。</span><br><span class="line">以上功能也可通过一段函数来实现：</span><br></pre></td></tr></table></figure>
<p>  set foldtext=MyFoldText()<br>  function MyFoldText()</p>
<pre><code>let line = getline(v:foldstart)
let sub = substitute(line, &apos;/\*\|\*/\|{{{\d\=', '', 'g')
      return v:folddashes . sub
    endfunction
    ```
- **折叠栏 FOLDCOLUMN**
折叠栏显示在窗口左侧，展示了所有折叠的结构。可以通过点击折叠栏中的“+”号来展开该折叠，通过点击任何其他非空字符来关闭该行所在折叠。
通过设定 `foldcolumn` 的值（0~12）来改变折叠栏的宽度。
- **其他选项**
`foldenable` `fen`：复位时打开所有折叠。
`foldexpr` `fde`：用于 `expr` 折叠模式的表达式。
`foldignore` `fdi`：用于 `indent` 折叠模式的字符。
`foldmarker` `fmr`：用于 `marker` 折叠模式的标志。
`foldmethod` `fdm`：当前折叠模式。
`foldminlines` `fml`：关闭折叠时的最小显示行数。
`foldnestmax` `fdn`：用于 `indent` 和 `syntax` 折叠模式的最大嵌套层数。
`foldopen` `fdo`：哪些命令可以打开已关闭的折叠。
`foldclose` `fcl`：非光标所在折叠是否关闭。缺省为""。若设置为“all”则所有高于 `foldlevel` 且非光标所在折叠都会自动关闭。

## 折叠方式

`set foldmethod = {method}` or `set fdm = {method}`

其中 {method} 有6个选项，各方式之间不兼容：

|命令  |含义                    |
|:-----|:-----------------------|
|manual|手工定义折叠            |
|indent|同等的缩进表示同级的折叠|
|expr  |用表达式来定义折叠      |
|syntax|用语法高亮来定义折叠    |
|diff  |对没有更改的文本进行折叠|
|marker|用特定标志标识折叠      |

当从 `manual` 模式切换到其他模式时，所有已存在的折叠会被删除并创建新折叠。而反过来则不会删除已存在的折叠。所以通常先选择 `manual` 之外的某种模式，得到自动生成的折叠，然后切换到 `manual` 模式。

- **manual**
  使用命令来创建折叠。折叠级别由嵌套层级决定。可以通过对某些行反复定义折叠来增加折叠级别。
  当退出编辑时，手工折叠会丢失。使用 `:mkview` 来保存折叠，使用 `:loadview` 来载入折叠。
- **indent**
  折叠级别由缩进除以 `shiftwidth` 并向下取整得到。嵌套的层数受 `foldnestmax` 限制。
  某些行会被忽略并得到相邻行的折叠级别（取较小值），这类行包括空行和以 `foldignore` 中某个字符开始的行。
- **expr**
  折叠级别通过对每行计算 `foldexpr` 的值来定义。该模式比较复杂，不常用。详见 `:h fold-expr`。
- **syntax**
  折叠由带有“fold”参数的语法项来定义（`:h syn-fold`）。折叠级别由折叠的嵌套层数决定。嵌套的折叠数量受 `foldnestmax` 限制。详见 `:h fold-syntax`。
- **diff**
  对未改动的文本或靠近改动的文本自动定义折叠。仅对当前窗口已设定 `diff` 选项来显示不同之处时有效，不然，整个缓冲区就是一个大折叠。详见 `:h fold-diff`。
- **marker**
  折叠根据 `foldmarker` 的值来定义，缺省值为“{{{,}}}”，建议不要修改。
</code></pre><p>折叠行所显示的文本取决于 <code>foldtext</code> 选项，缺省为 foldtext() 的返回值，即折叠标志之前的文本。<br>“3x{” 标志一个折叠的开始。可以用 “3x}” 标志一个折叠的结束（也可以不用，假如所有折叠都处于一个大嵌套中的话）。“3x{” 和 “3x}” 后都可以紧跟一个数字（0除外），表示该折叠的级别，数字越大，折叠所在的嵌套越深。<br>带数字的标志和不带数字的标志可以混合使用。</p>
</li>
</ul>
<h2 id="创建和删除折叠"><a href="#创建和删除折叠" class="headerlink" title="创建和删除折叠"></a>创建和删除折叠</h2><ul>
<li><code>zf{motion}</code> <code>{visual}zf</code> <code>{count}zF</code> <code>:{range}fo[ld]</code><br>创建折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zd</code> <code>{visual}zd</code><br>删除光标所在行的折叠，该折叠内的折叠将自动上移一级，或删除选中区域的所有折叠，且不可撤销。只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zD</code> <code>{visual}zD</code><br>删除光标所在行及其内的所有折叠，或删除选中区域及其内的所有折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
<li><code>zE</code><br>删除（eliminate）当前窗口内的所有折叠，只在 <code>manual</code> 和 <code>marker</code> 模式下有效</li>
</ul>
<h2 id="展开和关闭折叠"><a href="#展开和关闭折叠" class="headerlink" title="展开和关闭折叠"></a>展开和关闭折叠</h2><p>包含行数小于 <code>foldminlines</code> / <code>fdm</code> 的折叠将始终以展开的形式显示。<code>foldminlines</code>缺省为 1。</p>
<ul>
<li><code>[count]zo</code>：打开光标下的折叠。当给定计数时，打开相应深度的折叠。在可视模式下，所选区域所有折叠都打开一级。</li>
<li><code>zO</code>：打开光标所在行及其内的所有折叠。在可视模式下，打开所选区域内的所有折叠。</li>
<li><code>[count]zc</code>：关闭光标下的折叠。当给定计数时，关闭从光标所在折叠开始的相应级数的折叠。在可视模式下，所选区域内的折叠被关闭一级。</li>
<li><code>zC</code>：关闭光标所在行及其内的所有折叠。在可视模式下，关闭所选区域内的所有折叠。</li>
<li><code>[count]za</code>：打开/关闭光标所在折叠。当给定计数时，打开/关闭相应数量的折叠。</li>
<li><code>zA</code>：打开/关闭光标所在折叠及其内的所有折叠。</li>
<li><code>zv</code>：查看（view）折叠，打开光标所在折叠及其上级的所有折叠。</li>
<li><code>zx</code>：更新折叠。撤销被手动打开和关闭的折叠：再次应用 <code>foldlevel</code>。然后使用 <code>zv</code>。同时强制重新计算折叠。使用 <code>foldexpr</code> 并且缓冲区发生改变但折叠不能正确地更新时，这会有用。</li>
<li><code>zX</code>：类似 <code>zx</code>。</li>
<li><code>zm</code>：折叠更多（more）：<code>foldlevel</code> 减1。</li>
<li><code>zM</code>：关闭所有折叠，将 <code>foldlevel</code> 设为0。</li>
<li><code>zr</code>：折叠减少（reduce）：<code>foldlevel</code> 加1。</li>
<li><code>zR</code>：打开所有折叠，将 <code>foldlevel</code> 设为最高级别。</li>
<li><code>:{range}foldo[pen][!]</code>：在 {range} 内打开一级折叠，若加上 <code>!</code> 则打开 {range} 内的所有折叠。</li>
<li><code>:{range}foldc[lose][!]</code>：在 {range} 内关闭一级折叠，若加上 <code>!</code> 则关闭 {range} 内的所有折叠。</li>
<li><code>zn</code>：不折叠（none）：重置 <code>foldenable</code>。所有折叠被打开。</li>
<li><code>zN</code>：正常折叠（normal）：设定 <code>foldenable</code>。所有折叠都表现为之前的样子。</li>
<li><code>zi</code>：反转 <code>foldenable</code> 的值。</li>
</ul>
<h2 id="在折叠间移动"><a href="#在折叠间移动" class="headerlink" title="在折叠间移动"></a>在折叠间移动</h2><p><code>[count][z</code>：移动到当前打开折叠的开始。若已经在当前打开折叠的开始，则移动到上级折叠的开始。当给定计数时，重复[count]次<code>[z</code>命令。<br><code>[count]]z</code>：移动到当前打开折叠的末尾。若已经在当前打开折叠的末尾，则移动到上级折叠的末尾。当给定计数时，重复[count]次<code>]z</code>命令。<br><code>[count]zj</code>：移动到下一个折叠的开始，包括关闭的折叠。当给定计数时，重复[count]次<code>zj</code>命令。此命令可接在一个操作符（operator）后面。<br><code>[count]zk</code>：移动到上一个折叠的末尾，包括关闭的折叠。当给定计数时，重复[count]次<code>zk</code>命令。此命令可接在一个操作符（operator）后面。</p>
<h2 id="对折叠执行命令"><a href="#对折叠执行命令" class="headerlink" title="对折叠执行命令"></a>对折叠执行命令</h2><p><code>:[range]foldd[oopen] {cmd}</code>：对所有 [range] 范围内的、处于关闭折叠之外的行执行 {cmd}。执行过程类似 <code>:global</code> 命令：先标记所有需执行命令的行，然后执行命令。所以即使 {cmd} 会对折叠产生影响也不会改变 {cmd} 的执行范围。<br><code>:[range]folddoc[losed] {cmd}</code>：对所有 [range] 范围内的、处于关闭折叠之内的行执行 {cmd}。类似上一个命令。</p>
<h2 id="折叠行为"><a href="#折叠行为" class="headerlink" title="折叠行为"></a>折叠行为</h2><p>详见<code>:h fold-behavior</code>。</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><ul>
<li>encoding（enc）：encoding 是 Vim 的内部使用编码，encoding 的设置会影响 Vim 内部的 Buffer、消息文字等。若载入的文件与 encoding 不同，则 Vim 会先转换成 encoding，然后在写入时再转回去。在 Unix 环境下，encoding 的默认设置等于 locale；Windows 环境下会和当前代码页相同。在中文 Windows 环境下 encoding 的默认设置是 cp936（GBK）。</li>
<li>fileencodings（fencs）：Vim 在打开文件时会根据 fileencodings 选项来识别文件编码，fileencodings 可以同时设置多个编码，Vim 会根据设置的顺序来猜测所打开文件的编码。</li>
<li>fileencoding（fenc）：Vim 在保存新建文件时会根据 fileencoding 的设置编码来保存。如果是打开已有文件，Vim 会根据打开文件时所识别的编码来保存，除非在保存时重新设置 fileencoding。</li>
<li>termencodings（tenc）：在终端环境下使用 Vim 时，通过 termencoding 项来告诉 Vim 终端所使用的编码。</li>
</ul>
<p>保存文件时使用 <code>:set fileencoding=utf-8</code> 来使用指定的编码进行保存。</p>
<h1 id="自动配置选项"><a href="#自动配置选项" class="headerlink" title="自动配置选项"></a>自动配置选项</h1><p><em>:h auto-setting</em></p>
<h2 id="modeline"><a href="#modeline" class="headerlink" title="modeline"></a>modeline</h2><p>有两种形式的 modeline：</p>
<ul>
<li><code>[text]{white}{vi:|vim:|ex:}[white]{options}</code><ul>
<li><code>text</code>：任意文本。</li>
<li><code>white</code>：空格或 tab。</li>
<li><code>options</code>：若干选项，用空格或“:”分隔，每个选项都被作为 <code>:set</code> 的命令。</li>
</ul>
</li>
<li><code>[text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]</code><ul>
<li><code>se[t]</code>：当使用“Vim”时必须用 <code>set</code>。</li>
</ul>
</li>
</ul>
<p><code>ex:</code> 和 <code>Vim:</code> 前的空格是必需的，<code>vi:</code> 和 <code>vim:</code> 前的空格可选（为了兼容 3.0 版本）。</p>
<h1 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h1><p>用户自定义命令必须首字母大写，来避免与内建命令冲突，除了 <code>:Next</code>、<code>:X</code>，它们不能用于自定义命令。<code>:Print</code> 也是内建命令，但因为已废弃所以可以覆盖。</p>
<p>调用命令时可以用缩写，若根据缩写找到的命令不唯一则会报错。内建命令总是优先。</p>
<ul>
<li><code>:[verbose] com[mand] [{cmd}]</code> 列出所有用户定义的命令。展示结果前两列的符号：<ul>
<li><code>!</code> 该命令带有 <code>-bang</code> 属性。</li>
<li><code>&quot;</code> 该命令带有 <code>-register</code> 属性。</li>
<li><code>b</code> 该命令仅在当前缓冲区有效。</li>
<li><code>verbose</code> 额外显示命令的定义处。</li>
<li><code>{cmd}</code> 仅展示以 <code>{cmd}</code> 开头的命令。</li>
<li><code>:filter {subStr} command</code> 仅展示包含 <code>{subStr}</code> 的命令。</li>
</ul>
</li>
<li><code>:com[mand][!] [{attr}...] {cmd} {rep}</code> 定义一个命令。名称为 <code>{cmd}</code>，命令内容为 <code>{rep}</code>（其中可能包含代替换的文本），属性为 <code>{attr}</code>。若命令已存在会报错。使用 <code>!</code> 强制覆盖已有命令。<br>-</li>
<li><code>:delc[ommand] {cmd}</code> 删除命令。</li>
<li><code>comc[lear]</code> 删除所有用户定义命令。</li>
</ul>
<h2 id="替换文本"><a href="#替换文本" class="headerlink" title="替换文本"></a>替换文本</h2><p>命令执行前会自动替换命令内容中的 <code>&lt;...&gt;</code> 占位符。若要避免被替换，需用 <code>&lt;lt&gt;</code> 代替 <code>&lt;</code>。</p>
<ul>
<li><code>&lt;line1&gt;</code> 命令处理范围的开始行。</li>
<li><code>&lt;line2&gt;</code> 命令处理范围的结束行。</li>
<li><code>&lt;range&gt;</code> 命令范围这个参数本身的参数个数：0，1，2。</li>
<li><code>&lt;count&gt;</code> 传入的计数值。</li>
<li><code>&lt;bang&gt;</code> 若命令执行时带有 <code>!</code> 则会展开为 <code>!</code>，否则不展开。</li>
<li><code>&lt;mods&gt;</code> 命令修饰符，若执行时没带则不展开。<code>:aboveleft</code>, <code>:belowright</code>, <code>:botright</code>, <code>:browse</code>, <code>:confirm</code>, <code>:hide</code>, <code>:keepalt</code>, <code>:keepjumps</code>, <code>:keepmarks</code>, <code>:keeppatterns</code>, <code>:leftabove</code>, <code>:lockmarks</code>, <code>:noswapfile</code>, <code>:rightbelow</code>, <code>:silent</code>, <code>:tab</code>, <code>:topleft</code>, <code>:verbose</code>, <code>:vertical</code></li>
<li><code>&lt;reg&gt;</code> <code>&lt;register&gt;</code> 寄存器，若执行时没带则不展开。</li>
<li><code>&lt;args&gt;</code> 命令参数，但不包含计数和寄存器参数。</li>
<li><code>&lt;lt&gt;</code> 代表 <code>&lt;</code>，用来保留 <code>&lt;...&gt;</code> 类文本避免被替换。</li>
<li><code>&lt;q-{abc}&gt;</code> 若某个转义序列以“q-”开始，则它整体会被引号包裹起来，作为一个字符串。</li>
<li><code>&lt;f-args&gt;</code> 将命令入参根据空格分割成列表然后作为函数入参。<code>:h &lt;f-args&gt;</code></li>
</ul>
<h2 id="命令属性"><a href="#命令属性" class="headerlink" title="命令属性"></a>命令属性</h2><h3 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h3><ul>
<li>不显式声明参数。认为是不带参数，若调用时带参数会报错。</li>
<li><code>-nargs=0</code> 不带参数，同上。</li>
<li><code>-nargs=1</code> 有且仅有一个参数，包括空格。</li>
<li><code>-nargs=*</code> &gt;= 0 个参数，空格分隔。</li>
<li><code>-nargs=?</code> 0 或 1 个参数。</li>
<li><code>-nargs=+</code> &gt;= 1 个参数。</li>
</ul>
<p>若仅有一个参数，则空格会作为参数的一部分；若有多个参数，空格和 tab 会作为参数间的分隔符。</p>
<p>参数会作为文本传入命令然后解析，而不是作为表达式先解析再传入命令。也就是说若将变量作为实参，那么会在命令定义的作用域内查找该变量，而不是在命令的调用处的作用域内。</p>
<h3 id="补全行为"><a href="#补全行为" class="headerlink" title="补全行为"></a>补全行为</h3><p>命令的参数默认不会被补全，除非声明下列一个或多个参数。</p>
<ul>
<li><code>-complete=arglist</code> 参数列表中的文件名</li>
<li><code>-complete=augroup</code> 自动命名组</li>
<li><code>-complete=buffer</code> 缓冲区名称</li>
<li><code>-complete=behave</code> :behave 子选项</li>
<li><code>-complete=color</code> 颜色方案</li>
<li><code>-complete=command</code> Ex 命令及其参数</li>
<li><code>-complete=compiler</code> 编译器</li>
<li><code>-complete=cscope</code> :cscope 子选项</li>
<li><code>-complete=dir</code> 目录名</li>
<li><code>-complete=environment</code> 环境变量名</li>
<li><code>-complete=event</code> 自动命令事件</li>
<li><code>-complete=expression</code> Vim 表达式</li>
<li><code>-complete=file</code> 文件名和目录名</li>
<li><code>-complete=file_in_path</code> “path”中的文件名和目录名</li>
<li><code>-complete=filetype</code> 文件类型名</li>
<li><code>-complete=function</code> 函数名</li>
<li><code>-complete=help</code> 帮助主题</li>
<li><code>-complete=highlight</code> 高亮组</li>
<li><code>-complete=history</code> :history 子选项</li>
<li><code>-complete=locale</code> locale 名 (和 <code>locale -a</code> 给出的相同)</li>
<li><code>-complete=mapclear</code> 缓冲区参数</li>
<li><code>-complete=mapping</code> 映射名</li>
<li><code>-complete=menu</code> 菜单</li>
<li><code>-complete=messages</code> :messages 子选项</li>
<li><code>-complete=option</code> 选项</li>
<li><code>-complete=packadd</code> 可选包名</li>
<li><code>-complete=shellcmd</code> Shell 命令</li>
<li><code>-complete=sign</code> :sign 子选项</li>
<li><code>-complete=syntax</code> 语法文件名</li>
<li><code>-complete=syntime</code> :syntime 子选项</li>
<li><code>-complete=tag</code> 标签</li>
<li><code>-complete=tag_listfiles</code> 标签，但敲入 <code>&lt;C-d&gt;</code> 时显示文件名</li>
<li><code>-complete=user</code> 用户名</li>
<li><code>-complete=var</code> 用户变量</li>
<li><code>-complete=custom,{func}</code> 用户自定义补全，通过 <code>{func}</code> 定义。</li>
<li><code>-complete=customlist,{func}</code> 用户自定义补全，通过 <code>{func}</code> 定义。</li>
</ul>
<h3 id="范围处理"><a href="#范围处理" class="headerlink" title="范围处理"></a>范围处理</h3><ul>
<li><code>-range</code> 允许范围，默认当前行</li>
<li><code>-range=%</code> 允许范围，默认全文</li>
<li><code>-range={n}</code> 计数（默认 n），用法类似 <code>:3{cmd}</code></li>
<li><code>-count=[{n}]</code> 计数（默认 n，若不声明则默认 0），用法类似 <code>:3{cmd}</code> 或 <code>:{cmd} 3</code></li>
<li><code>-addr=lines</code> 将范围应用于行（默认）</li>
<li><code>-addr=arguments</code> 将范围应用于参数</li>
<li><code>-addr=buffers</code> 将范围应用于缓冲区，包括未加载的</li>
<li><code>-addr=loaded_buffers</code> 将范围应用于已加载的缓冲区</li>
<li><code>-addr=windows</code>    将范围应用于窗口</li>
<li><code>-addr=tabs</code> 将范围应用于标签页</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><ul>
<li><code>-bang</code> 命令接受强制执行 <code>!</code></li>
<li><code>-bar</code> 命令接受管道符 <code>|</code> 和后续命令。此时命令参数中不允许出现 <code>|</code>。同时会检查 <code>&quot;</code> 作为注释的开始。</li>
<li><code>-register</code> 命令的第一个参数可以是一个可选的寄存器名（类似 <code>:del</code>）</li>
<li><code>-buffer</code> 命令仅在当前缓冲区可用</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/网络/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/网络/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>整理自谢希仁著《计算机网络》。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>所有的因特网标准都是以 RFC（Request For Comments）的形式在因特网上发表。</p>
<p>制订因特网的正式标准要经过四个阶段 [RFC 2026]：</p>
<ul>
<li>因特网草案（Internet Draft）——还不是 RFC 文档</li>
<li>建议标准（Proposed Standard）——开始成为 RFC 文档</li>
<li>草案标准（Draft Standard）</li>
<li>因特网标准（Internet Standard）</li>
</ul>
<p><strong>通信方式大致分为两大类</strong></p>
<ul>
<li>C/S（Client/Server）<ul>
<li>B/S（Browser/Server）：C/S 的一种特例，特指客户端为浏览器的情况</li>
</ul>
</li>
<li>P2P（Peer-to-Peer）</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/网络/计算机网络/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Javascript/JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Javascript/JavaScript/" itemprop="url">JavaScript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ul>
<li>区分大小写。</li>
<li>转义序列表示任一 Unicode 内码：<code>\u01AB</code>，其中后 4 位是可变 16 进制数。注释中的转义序列不会被解释为 Unicode 内码。</li>
</ul>
<h2 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h2><ul>
<li>标识符必须以<strong>字符</strong>、<strong>下划线</strong>或<strong>美元符号（$）</strong>开始，后续可以是字母、数字、下划线或美元符。</li>
<li>出于可移植性和可读性的考虑，通常只用 ASCII 字母和数字来书写标识符。但从技术上来讲，JavaScript 允许标识符中出现 Unicode 字符全集中的字母和数字。ECMAScript 标准也允许在标识符首字符后面出现 Unicode 字符集中的 Mn 类、Mc 类和 Pc 类[^1]。</li>
</ul>
<p><strong>JavaScript 保留关键字</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abstract</td>
<td style="text-align:left">arguments</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">break</td>
<td style="text-align:left">byte</td>
<td style="text-align:left">case</td>
<td style="text-align:left">catch</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">class#</td>
<td style="text-align:left">const</td>
<td style="text-align:left">continue</td>
<td style="text-align:left">debugger</td>
<td style="text-align:left">default</td>
<td style="text-align:left">delete</td>
</tr>
<tr>
<td style="text-align:left">do</td>
<td style="text-align:left">double</td>
<td style="text-align:left">else</td>
<td style="text-align:left">enum#</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">export#</td>
<td style="text-align:left">extends#</td>
</tr>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">final</td>
<td style="text-align:left">finally</td>
<td style="text-align:left">float</td>
<td style="text-align:left">for</td>
<td style="text-align:left">function</td>
<td style="text-align:left">goto</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left">implements</td>
<td style="text-align:left">import#</td>
<td style="text-align:left">in</td>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">int</td>
<td style="text-align:left">interface</td>
</tr>
<tr>
<td style="text-align:left">let</td>
<td style="text-align:left">long</td>
<td style="text-align:left">native</td>
<td style="text-align:left">new</td>
<td style="text-align:left">null</td>
<td style="text-align:left">package</td>
<td style="text-align:left">private</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">public</td>
<td style="text-align:left">return</td>
<td style="text-align:left">short</td>
<td style="text-align:left">static</td>
<td style="text-align:left">super#</td>
<td style="text-align:left">switch</td>
</tr>
<tr>
<td style="text-align:left">synchronized</td>
<td style="text-align:left">this</td>
<td style="text-align:left">throw</td>
<td style="text-align:left">throws</td>
<td style="text-align:left">transient</td>
<td style="text-align:left">true</td>
<td style="text-align:left">try</td>
</tr>
<tr>
<td style="text-align:left">typeof</td>
<td style="text-align:left">var</td>
<td style="text-align:left">void</td>
<td style="text-align:left">volatile</td>
<td style="text-align:left">while</td>
<td style="text-align:left">with</td>
<td style="text-align:left">yield</td>
</tr>
</tbody>
</table>
<p><em><code>#</code> 标记的关键字是 ECMAScript5 中新添加的。</em></p>
<p><strong>JavaScript 对象、属性和方法</strong></p>
<p>应该避免使用 JavaScript 内置的对象、属性和方法的名称作为 Javascript 的变量或函数名</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">Date</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">function</td>
<td style="text-align:left">hasOwnProperty</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">isFinite</td>
<td style="text-align:left">isNaN</td>
<td style="text-align:left">isPrototypeOf</td>
<td style="text-align:left">length</td>
</tr>
<tr>
<td style="text-align:left">Math</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">name</td>
<td style="text-align:left">Number</td>
<td style="text-align:left">Object</td>
</tr>
<tr>
<td style="text-align:left">prototype</td>
<td style="text-align:left">String</td>
<td style="text-align:left">toString</td>
<td style="text-align:left">undefined</td>
<td style="text-align:left">valueOf</td>
</tr>
</tbody>
</table>
<p><strong>Java 保留关键字</strong></p>
<p>JavaScript 经常与 Java 一起使用，应该避免使用一些 Java 对象和属性作为 JavaScript 标识符</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getClass</td>
<td style="text-align:left">java</td>
<td style="text-align:left">JavaArray</td>
<td style="text-align:left">javaClass</td>
<td style="text-align:left">JavaObject</td>
<td style="text-align:left">JavaPackage</td>
</tr>
</tbody>
</table>
<p><strong>Windows 保留关键字</strong></p>
<p>JavaScript 可以在 HTML 外部使用。它可在许多其他应用程序中作为编程语言使用。<br>在 HTML 中，必须（为了可移植性，也应该这么做）避免使用 HTML 和 Windows 对象和属性的名称作为 Javascript 的变量及函数名</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">alert</td>
<td style="text-align:left">all</td>
<td style="text-align:left">anchor</td>
<td style="text-align:left">anchors</td>
<td style="text-align:left">area</td>
</tr>
<tr>
<td style="text-align:left">assign</td>
<td style="text-align:left">blur</td>
<td style="text-align:left">button</td>
<td style="text-align:left">checkbox</td>
<td style="text-align:left">clearInterval</td>
</tr>
<tr>
<td style="text-align:left">clearTimeout</td>
<td style="text-align:left">clientInformation</td>
<td style="text-align:left">close</td>
<td style="text-align:left">closed</td>
<td style="text-align:left">confirm</td>
</tr>
<tr>
<td style="text-align:left">constructor</td>
<td style="text-align:left">crypto</td>
<td style="text-align:left">decodeURI</td>
<td style="text-align:left">decodeURIComponent</td>
<td style="text-align:left">defaultStatus</td>
</tr>
<tr>
<td style="text-align:left">document</td>
<td style="text-align:left">element</td>
<td style="text-align:left">elements</td>
<td style="text-align:left">embed</td>
<td style="text-align:left">embeds</td>
</tr>
<tr>
<td style="text-align:left">encodeURI</td>
<td style="text-align:left">encodeURIComponent</td>
<td style="text-align:left">escape</td>
<td style="text-align:left">event</td>
<td style="text-align:left">fileUpload</td>
</tr>
<tr>
<td style="text-align:left">focus</td>
<td style="text-align:left">form</td>
<td style="text-align:left">forms</td>
<td style="text-align:left">frame</td>
<td style="text-align:left">innerHeight</td>
</tr>
<tr>
<td style="text-align:left">innerWidth</td>
<td style="text-align:left">layer</td>
<td style="text-align:left">layers</td>
<td style="text-align:left">link</td>
<td style="text-align:left">location</td>
</tr>
<tr>
<td style="text-align:left">mimeTypes</td>
<td style="text-align:left">navigate</td>
<td style="text-align:left">navigator</td>
<td style="text-align:left">frames</td>
<td style="text-align:left">frameRate</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">history</td>
<td style="text-align:left">image</td>
<td style="text-align:left">images</td>
<td style="text-align:left">offscreenBuffering</td>
</tr>
<tr>
<td style="text-align:left">open</td>
<td style="text-align:left">opener</td>
<td style="text-align:left">option</td>
<td style="text-align:left">outerHeight</td>
<td style="text-align:left">outerWidth</td>
</tr>
<tr>
<td style="text-align:left">packages</td>
<td style="text-align:left">pageXOffset</td>
<td style="text-align:left">pageYOffset</td>
<td style="text-align:left">parent</td>
<td style="text-align:left">parseFloat</td>
</tr>
<tr>
<td style="text-align:left">parseInt</td>
<td style="text-align:left">password</td>
<td style="text-align:left">pkcs11</td>
<td style="text-align:left">plugin</td>
<td style="text-align:left">prompt</td>
</tr>
<tr>
<td style="text-align:left">propertyIsEnum</td>
<td style="text-align:left">radio</td>
<td style="text-align:left">reset</td>
<td style="text-align:left">screenX</td>
<td style="text-align:left">screenY</td>
</tr>
<tr>
<td style="text-align:left">scroll</td>
<td style="text-align:left">secure</td>
<td style="text-align:left">select</td>
<td style="text-align:left">self</td>
<td style="text-align:left">setInterval</td>
</tr>
<tr>
<td style="text-align:left">setTimeout</td>
<td style="text-align:left">status</td>
<td style="text-align:left">submit</td>
<td style="text-align:left">taint</td>
<td style="text-align:left">text</td>
</tr>
<tr>
<td style="text-align:left">textarea</td>
<td style="text-align:left">top</td>
<td style="text-align:left">unescape</td>
<td style="text-align:left">untaint</td>
<td style="text-align:left">window</td>
</tr>
</tbody>
</table>
<p><strong>HTML 事件句柄</strong></p>
<p>应该避免使用 HTML 事件句柄的名称作为 Javascript 的变量及函数名。</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
<th style="text-align:left">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onblur</td>
<td style="text-align:left">onclick</td>
<td style="text-align:left">onerror</td>
<td style="text-align:left">onfocus</td>
</tr>
<tr>
<td style="text-align:left">onkeydown</td>
<td style="text-align:left">onkeypress</td>
<td style="text-align:left">onkeyup</td>
<td style="text-align:left">onmouseover</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">onmouseup</td>
<td style="text-align:left">onmousedown</td>
<td style="text-align:left">onsubmit</td>
</tr>
</tbody>
</table>
<p><strong>非标准 JavaScript</strong></p>
<p>除了保留关键字，在 JavaScript 实现中也有一些非标准的关键字。<br>一个实例是 <code>const</code> 关键字，用于定义变量。 一些 js 引擎把 <code>const</code> 当作 <code>var</code> 的同义词。另一些引擎则把 <code>const</code> 当作只读变量的定义。<br><code>const</code> 是 js 的扩展。js 引擎支持它用在 Firefox 和 Chrome 中。但是它并不是 JavaScript 标准 ES3 或 ES5 的组成部分。建议：不要使用它。</p>
<h2 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h2><ul>
<li>js 只有在缺少了分号就无法正确解析代码时才会自动填补分号。有两个例外：<ul>
<li>若 <code>return</code>、<code>break</code> 和 <code>continue</code> 后紧跟换行，js 会填补分号；</li>
<li>对于 <code>++</code> 和 <code>--</code> 运算符，若既可以解释为表达式前缀，又可以解释为后缀，js 会优先解释为前缀；</li>
</ul>
</li>
<li>通常以 <code>(</code>、<code>[</code>、<code>/</code>、<code>+</code>、<code>-</code> 开始的语句较有可能和前一条语句一起解析，保守起见可在此类语句前加分号，这样即使前一条语句结尾的分号被误删了，当前语句也能正常执行。</li>
</ul>
<h1 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h1><ul>
<li>基本类型：数字、字符串、布尔值、null、undefined。</li>
<li>除基本类型外都是对象类型。js 核心定义了五种类：Array、Function、Date、RegExp、Error。</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>采用 IEEE 754 标准定义的 64 位浮点格式，最大值 ±1.7976931348623157x10^308，最小值 ±5x10^-324。整数范围 -2^53~2^53，包含边界值。若超过此范围则无法保证低位的精度。</li>
<li><strong>Javascript 在实际操作时基于 32 位整数</strong>，这在操作大数时可能会出现意外的情况。</li>
<li>ECMAScript 标准不支持八进制数字，但某些 JavaScript 实现允许以数字 0 开始的八进制数字。在 ES6 的严格模式下，八进制直接量是明令禁止的。</li>
<li>数字表示方式：<code>[digits][.digits][(E|e)[+|-]digits]</code>。</li>
<li>数字溢出以 <code>Infinity</code> <code>-Infinity</code> 表示，基于它们的加减乘除结果还是无穷大。</li>
<li>数字下溢以 <code>0</code> <code>-0</code> 表示。</li>
<li>零除以零、无穷大除以无穷大、负数做开方、数字运算符与非数字或无法转换成数字的对象一起使用时，会返回 <code>NaN</code>。</li>
<li>ECMAScript 3 中 <code>Infinity</code> 和 <code>NaN</code> 是可读可写可修改的，ES5 中修复了这个 bug。</li>
<li>NaN 与任何值都不相等，包括自身。也就是说不能通过 <code>x==NaN</code> 来判断，而要通过 <code>x!=x</code> 来判断。或者使用 <code>isNaN()</code> 函数判断。</li>
<li>正负零值严格相等，除了它们作为除数时得到的结果。</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li>字符串是一组由 16 位值组成的不可变的有序序列，每个字符通常来自于 Unicode 字符集。</li>
<li>js 采用 UTF-16 编码，这意味着字符串的长度是其所含 16 位值的个数，而不是字面上的字符个数。</li>
<li>js 定义的字符串操作方法均作用于 16 位值，而非字符，且不会对代理项做单独处理。同样，js 不会对字符串做标准化加工，甚至不能保证字符串是合法的 UTF-16 格式。</li>
<li>js 中没有表示单个字符的“字符类型”。</li>
<li>在 ES3 中，字符串直接量必须写在一行中。在 ES5 中，可以将字符串拆分成数行，每行以 <code>\</code> 结束，<code>\</code> 和后面隐含的换行符都不算字符串直接量的组成部分。如果想换行，可以使用 <code>\n</code>。</li>
<li>若 <code>\</code> 后的字符不存在对应的转义字符，则会忽略 <code>\</code>，仍解释为该字符本身。</li>
<li>在 ES5 中，字符串可以当作只读数组，使用 charAt() 方法或方括号来访问其中的字符。以 Mozilla 为首的多数浏览器都在 ES5 之前就支持这种特性，除了 IE。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\o</code></td>
<td style="text-align:left">NUL 字符（\u0000）</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">退格符（\u0008）</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">水平制表符（\u0009）</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">换行符（\u000A）</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">垂直制表符（\u000B）</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">换页符（\u000C）</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">回车符（\u000D）</td>
</tr>
<tr>
<td style="text-align:left"><code>\&quot;</code></td>
<td style="text-align:left">双引号（\u0022）</td>
</tr>
<tr>
<td style="text-align:left"><code>\&#39;</code></td>
<td style="text-align:left">撇号或单引号（\u0027）</td>
</tr>
<tr>
<td style="text-align:left"><code>\\</code></td>
<td style="text-align:left">反斜线（\u005C）</td>
</tr>
<tr>
<td style="text-align:left"><code>\xXX</code></td>
<td style="text-align:left">由两位十六进制数指定的 Latin-1 字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\uXXXX</code></td>
<td style="text-align:left">由四位十六进制数制定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>任意 js 的值都可以转换为布尔值。</p>
<p>以下值会被转换为 false：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NaN</li>
<li>“”</li>
</ul>
<p>其他所有值（包括对象）都会被转换为 true。</p>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><ul>
<li>typeof(null) === “object”</li>
<li>typeof(undefined) === “undefined”</li>
<li>null == undefined –&gt; true</li>
<li>null === undefined –&gt; false</li>
</ul>
<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>当 js 解释器启动时，或浏览器加载新页面时，将创建一个新的全局对象，并给它一组定义的初始属性：</p>
<ul>
<li>全局属性，比如 undefined，Infinity，NaN</li>
<li>全局函数，比如 isNaN()，parseInt()，eval()</li>
<li>构造函数，比如 Date()，RegExp()，String()，Object()，Array()</li>
<li>全局对象，比如 Math，JSON</li>
</ul>
<p>全局对象的初始属性不是保留字，但应该当作保留字来对待。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">字符串</th>
<th style="text-align:left">数字</th>
<th style="text-align:left">布尔值</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">“undefined”</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">“null”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">“true”</td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">new Boolean(true)</td>
</tr>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">“false”</td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td style="text-align:left">new Boolean(false)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">“”</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">new String(“”)</td>
</tr>
<tr>
<td style="text-align:left">“1.2”</td>
<td style="text-align:left"></td>
<td style="text-align:left">1.2</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“1.2”)</td>
</tr>
<tr>
<td style="text-align:left">“one”</td>
<td style="text-align:left"></td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“one”)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(0)</td>
</tr>
<tr>
<td style="text-align:left">-0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(-0)</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">“NaN”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(NaN)</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">“Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(Infinity)</td>
</tr>
<tr>
<td style="text-align:left">-Infinity</td>
<td style="text-align:left">“-Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(-Infinity)</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">“1”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(1)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">{}任意对象</td>
<td style="text-align:left">#1</td>
<td style="text-align:left">#2</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[]任意数组</td>
<td style="text-align:left">“”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[9]1个数字元素</td>
<td style="text-align:left">“9”</td>
<td style="text-align:left">9</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[‘a’]其它数组</td>
<td style="text-align:left">使用join()方法</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">function(){}任意函数</td>
<td style="text-align:left">@</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
</tr>
</tbody>
</table>
<ol>
<li>对象 -&gt; 字符串：<ul>
<li>尝试 toString() 方法，若返回一个原始值，则转为字符串。</li>
<li>若无 toString() 方法，或返回的不是原始值，则调用 valueOf() 方法，若返回一个原始值，则转为字符串。</li>
<li>若无法通过以上两种方法获取原始值，则抛出类型异常。</li>
</ul>
</li>
<li>对象 -&gt; 数字：<ul>
<li>尝试 valueOf() 方法，若返回一个原始值，则转为数字。</li>
<li>否则，尝试 toString() 方法，将得到的字符串转为数字。</li>
<li>否则，抛出类型异常。</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li>一个值转换为另一个值并不意味两个值“相等”。比如在期望布尔值的地方使用了 undefined，它将会转换 false，但这并不表明 undefined == false。“==”运算符从不试图将其操作数转换为布尔值。</li>
<li>对于 Boolean()、Number()、String() 或 Object()，当不通过 new 调用这些函数时，它们会作为类型转换函数。</li>
<li>如果试图把 undefined 和 null 转换为对象，会抛出 TypeError，但用 Object() 显式转换不会抛异常，而是返回一个空对象。</li>
<li>数字转字符串的不同方法（3 个方法都会适当地四舍五入或填充 0）：<ul>
<li>toFixed()：指定小数点后的位数，从不使用指数记数法。</li>
<li>toExponential()：使用指数记数法，其中小数点前固定 1 位，小数点后位数由参数决定。</li>
<li>toPrecision()：指定有效数字的位数，若指定的有效数字位数小于整数部分位数，则转换成指数形式。</li>
</ul>
</li>
<li>使用 Number() 将字符串转换为数字直接量，只能基于十进制，且不能出现非法的尾随字符。</li>
<li>parseInt() 只解析整数，parseFloat() 可解析整数和浮点数。两者都会跳过任意数量的前导空格，并尽可能多地解析字符，并忽略后面无法解析的部分。若第一个非空字符即非数字，则返回 NaN。若字符串前缀为 0x 或 0X，则 parseInt() 将其解释为十六进制数。parseInt() 可接受第二个参数来指定基数，范围 2~36。</li>
</ul>
<h1 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h1><h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">结合性</th>
<th style="text-align:left">操作数</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">++</td>
<td style="text-align:left">前/后增量</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→num</td>
</tr>
<tr>
<td style="text-align:left">–</td>
<td style="text-align:left">前/后增量</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→num</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">求反</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">num→num</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">转换为数字</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">num→num</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">按位求反</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">int→int</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">逻辑非</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">bool→bool</td>
</tr>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">删除属性</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">lval→bool</td>
</tr>
<tr>
<td style="text-align:left">typeof</td>
<td style="text-align:left">检测操作数类型</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">any→str</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">返回 undefined 值</td>
<td style="text-align:left">←</td>
<td style="text-align:left">1</td>
<td style="text-align:left">any→undef</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">*、/、%</td>
<td style="text-align:left">乘、除、取余</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→num</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">+、-</td>
<td style="text-align:left">加、减</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→num</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">字符串拼接</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,str→str</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左位移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left">>&gt;</td>
<td style="text-align:left">有符号右移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left">>&gt;&gt;</td>
<td style="text-align:left">无符号右移</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&lt;、&lt;=、&gt;、&gt;=</td>
<td style="text-align:left">比较数字顺序</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">num,num→bool</td>
</tr>
<tr>
<td style="text-align:left">&lt;、&lt;=、&gt;、&gt;=</td>
<td style="text-align:left">比较在字母表中的顺序</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,str→bool</td>
</tr>
<tr>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">测试对象类</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">obj,func→bool</td>
</tr>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">测试属性是否存在</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">str,obj→bool</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">判断相等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">判断不等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">===</td>
<td style="text-align:left">判断恒等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left">!==</td>
<td style="text-align:left">判断非恒等</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→bool</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">按位异或</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">按位或</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td>int,int→int</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑与</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">逻辑或</td>
<td style="text-align:left">→</td>
<td>2</td>
<td>any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">?:</td>
<td style="text-align:left">条件运算符</td>
<td style="text-align:left">←</td>
<td style="text-align:left">3</td>
<td style="text-align:left">bool,any,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">变量赋值或对象属性赋值</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">lval,any→any</td>
</tr>
<tr>
<td style="text-align:left">*=、/=、%=、+=、-=、&amp;=、^=、\</td>
<td style="text-align:left">=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td>
<td style="text-align:left">运算且赋值</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td>lval,any→any</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">,</td>
<td style="text-align:left">忽略第一个、返回第二个操作数</td>
<td style="text-align:left">→</td>
<td style="text-align:left">2</td>
<td style="text-align:left">any,any→any</td>
</tr>
</tbody>
</table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>位运算符要求操作数是整数，并表示为 32 位整型而不是 64 位浮点型。必要时位运算符会先将操作数转换为数字并强制表示为 32 位整型，这会忽略小数部分和超过32位的二进制部分。</li>
<li>移位运算符要求右运算符在 0~31 之间。</li>
<li>位运算符会将 NaN、Infinity 和 -Infinity 都转换为 0。</li>
</ul>
<h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><ul>
<li>逻辑与（&amp;&amp;）和逻辑或（||）将所有操作数都当作真、假值来计算，并将其中某个操作数当作真、假值结果来返回。</li>
<li>考虑到逻辑表达式具有短路的性质，因此当计算到某个操作数就可以确定整个逻辑表达式的结果时，就不再继续计算，且将该操作数作为真、假值结果来返回。</li>
<li>逻辑非（!）运算符与 &amp;&amp; 和 || 不同，它不是将操作数当作真、假值，而是将操作数转换为布尔值然后取反。</li>
</ul>
<h2 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h2><p><strong>“+”运算符</strong></p>
<ul>
<li>若其中一个操作数为对象，则按照规则将其转换为原始类值。</li>
<li>转换之后，若其中一个操作数为字符串，则将另一个也转为字符串然后进行拼接。</li>
<li>否则，将两者都转为数字或 NaN，然后做加法。</li>
</ul>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p><strong>typeof</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">x</th>
<th style="text-align:left">typeof x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">“undefined”</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">true/flase</td>
<td style="text-align:left">“boolean”</td>
</tr>
<tr>
<td style="text-align:left">任意数字或 NaN</td>
<td style="text-align:left">“number”</td>
</tr>
<tr>
<td style="text-align:left">任意字符串</td>
<td style="text-align:left">“string”</td>
</tr>
<tr>
<td style="text-align:left">任意函数</td>
<td style="text-align:left">“function”</td>
</tr>
<tr>
<td style="text-align:left">任意内置对象（非函数）</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">任意宿主对象</td>
<td style="text-align:left">由编译器各自实现的字符串，但不是”undefined”、”boolean”、”number”或”string”</td>
</tr>
</tbody>
</table>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式是 ES5 的一个受限制的子集。与非严格模式的区别：</p>
<ul>
<li>禁止使用 with 语句。</li>
<li>如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将抛出一个引用错误异常。（在非严格模式中会给全局对象添加一个属性）</li>
<li>调用的函数（不是方法）中的 this 值是 undefined。（在非严格模式中是全局对象）。可以此判断是否支持严格模式：<code>var hasStrictMode = (function(){&quot;use strict&quot;; return this === undefined}());</code></li>
<li>当通过 <code>call()</code> 或 <code>apply()</code> 来调用函数时，其中的 this 值就是 <code>call()</code> 或 <code>apply()</code> 传入的第一个参数（在非严格模式中 null 和 undefined 值被全局对象和转换为对象的非对象值代替）。</li>
<li>给只读属性赋值和给不可扩展的对象创建成员都会抛出类型错误异常（非严格模式中只是失败，不会抛异常）。</li>
<li>传入 <code>eval()</code> 的代码不能在调用程序所在的上下文中声明变量或定义函数。变量和函数的定义是在 <code>eval()</code> 创建的新作用域中，这个作用域在 <code>eval()</code> 返回时弃用。</li>
<li>函数里的 arguments 对象拥有传入函数值的静态副本。在非严格模式中，两者是指向同一个值的引用。</li>
<li>当 delete 运算符后跟随非法标识符（变量、函数、函数参数）时，将抛出语法错误异常（在非严格模式中什么也不做，并返回 false）。</li>
<li>在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（非严格模式下不会报错）。</li>
<li>函数声明中存在两个或多个同名参数将产生一个语法错误（非严格模式下不会报错）。</li>
<li>不允许使用八进制整数直接量（以 0 为前缀）。</li>
<li>标识符 <code>eval</code> 和 <code>arguments</code> 当作关键字，它们的值不能修改，不能给它们赋值、声明为变量、用作函数名、用作函数参数或用作 catch 块的标识符。</li>
<li>限制了对调用栈的检测能力。在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。严格模式的函数同样具有 caller 和 arguments 属性，访问它们时会抛出类型错误异常（一些 js 实现在非严格模式里定义了这些非标准的属性）。</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><ul>
<li>属性名字里有空格或连字符的，必须用字符串表示。</li>
<li>ES5 和部分 ES3 的实现中，保留字可以用作不带引号的属性名。保险起见，属性名字是保留字的，要用字符串表示。</li>
<li>ES5 中，对象直接量中最后一个属性后的逗号会被忽略。在 ES3 的大部分实现中也会忽略，除了 IE。</li>
</ul>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>ES5 中定义了 Object.create() 方法，第一个参数是这个对象的原型，第二个可选参数用以对对象的属性进行描述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);<span class="comment">//创建的对象没有原型，也就是没有任何基础方法，比如 toString() 之类的</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><h3 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h3><p>设置属性会失败的场景：</p>
<ul>
<li>o 中的属性 p 是只读的：不能给只读属性重新赋值（<code>defineProperty()</code> 方法中有一个例外，可以对可配置的只读属性重新赋值）。</li>
<li>o 中的属性 p 是继承属性，且是只读的：不能通过同名自有属性覆盖只读的继承属性。</li>
<li>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性是 false。如果 o 中不存在 p，且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。</li>
</ul>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><ul>
<li><code>&quot;x&quot; in o</code>：包括自有属性和继承属性。</li>
<li><code>o.hasOwnProperty(&quot;x&quot;)</code>：包括自有属性。</li>
<li><code>o.propertyIsEnumerable(&quot;x&quot;)</code>：包括自有属性，且属性是可枚举的。</li>
<li><code>o.x !== undefined</code>：同 <code>in</code>，但不能区分赋值为 undefined 的属性。</li>
<li><code>o.x != null</code>：不区分 null 和 undefined。</li>
</ul>
<h2 id="属性-getter-和-setter"><a href="#属性-getter-和-setter" class="headerlink" title="属性 getter 和 setter"></a>属性 getter 和 setter</h2><p>在 ES5 中，属性值可以由 getter 和 setter 方法来代替，这种属性称为“存取器属性”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  $n = <span class="number">0</span>; <span class="comment">// $ 暗示是私有属性</span></span><br><span class="line">  get next() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$n++;</span><br><span class="line">  &#125;</span><br><span class="line">  set next(n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="keyword">this</span>.$n) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$n = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"blabla"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>属性的 4 个特性：值 value、可写性 writable、可枚举性 enumerable、可配置性 configurable。<br>存取器属性没有值和可写性，取而代之的是读取 get、写入 set。</p>
<p>ES3 中无法配置这些特性，ES5 中定义了一个“属性描述符”的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;value: 1, writable:true, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;get:[Function: get x], set:undefined, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;get x()&#123;&#125;&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在的属性和继承属性</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"x"</span>);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"toString"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建或修改属性的特性</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> pd = &#123;<span class="attr">value</span>:<span class="number">1</span>, <span class="attr">writable</span>:<span class="literal">true</span>, <span class="attr">enumerble</span>:<span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, pd);<span class="comment">//创建属性并定义特性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">writable</span>:<span class="literal">false</span>&#125;);<span class="comment">//修改特性</span></span><br><span class="line"><span class="comment">//多个属性的特性，返回修改后的对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  x: &#123;<span class="attr">value</span>:<span class="number">1</span>, <span class="comment">/*...*/</span>&#125;,</span><br><span class="line">  y: &#123;<span class="attr">value</span>:<span class="number">2</span>, <span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>任何对 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 违反规则的使用都会抛出类型错误异常：</p>
<ul>
<li>若对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。</li>
<li>若属性是不可配置的，则不能修改它的可配置性和可枚举性。</li>
<li>若存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。</li>
<li>若数据属性是不可配置的，则不能将它转换为存取器属性。</li>
<li>若数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 改为 false。</li>
<li>若数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写，然后修改值，最后转换为不可写）。</li>
</ul>
<h2 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h2><p>原型、类、可扩展性</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>通过对象直接量创建：Object.prototype。</li>
<li>通过 new 构造函数创建：构造函数的 prototype。</li>
<li>通过 <code>Object.create()</code> 创建：使用第一个参数，可以是 null。</li>
</ul>
<p>在 ES5 中，通过 <code>Object.getPrototypeOf()</code> 查询对象的原型。在 ES3 中没有对应的函数，可以通过 <code>o.constructor.prototype</code> 来查询原型，但这种方式并不可靠。</p>
<p>通过对象直接量创建的对象和通过 <code>Object.create()</code> 创建的对象都含有 constructor 属性，它们的这个属性都指向构造函数 <code>Object()</code>。但只有对象直接量创建的对象的原型是 <code>Object()</code> 函数的 prototype 属性，而 <code>Object.create()</code> 创建的对象往往不是。</p>
<p>要检测 a 对象是否是 b 对象的原型（或在原型链上），应使用 <code>b.isPrototypeOf(a)</code>。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>可扩展性表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的。</p>
<ul>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.preventExtensions()</code>：转为不可扩展，然后就无法转回可扩展了。只影响对象本身，依然可以给原型添加属性，此对象仍会继承添加的属性。</li>
<li><code>Object.seal()</code>：将对象设置为不可扩展，且所有自有属性都不可配置。已封闭的对象不能解封，可用 <code>Object.isSealed()</code> 来检测。</li>
<li><code>Object.freeze()</code>：在 seal 的基础上，还将所有自有数据属性置为只读（若存取器属性有 setter 方法则仍能赋值）。可用 <code>Object.isFrozen()</code> 来检测。</li>
</ul>
<h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p><code>JSON.stringify()</code> 和 <code>JSON.parse()</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>判断数组中的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a[i]); <span class="comment">// null、undefined 和不存在的元素</span></span><br><span class="line"><span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>); <span class="comment">// undefined 和不存在的元素</span></span><br><span class="line"><span class="keyword">if</span> (!(i <span class="keyword">in</span> a)); <span class="comment">// 不存在的元素</span></span><br></pre></td></tr></table></figure>
<p>由于 for/in 循环会枚举继承的属性，所以对于数组要么不用 for/in 循环，要么手动判断继承的属性。</p>
<p>for/in 循环的遍历顺序不能确定，可以改用传统的 for 循环，或用 ES5 中新增的 forEach() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//operations on the element</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>拼接数组元素，默认使用逗号，也可以自定义连接符。是 string.split() 的逆向操作。</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转排列。在原数组中反转，而不是新建一个数组。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>默认按字母表顺序排序，必要时会把元素临时转为字符串进行比较。undefined 元素会被排到末尾。</p>
<p>可传入比较函数，若第一个参数应排在前面，则函数应返回小于 0 的数值。</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>返回一个<strong>新数组</strong>，其中包含原有的元素和所有入参。若参数是数组，则添加的是其中的每个元素，而不是将该数组整个作为一个元素。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>返回一个<strong>新数组</strong>，该数组是原数组的一部分。</p>
<ul>
<li>两个入参：两个索引，子数组包含了第一个索引的元素到第二个索引前面一个元素。</li>
<li>一个入参：入参表示开始位置，结束位置固定为数组末尾。</li>
<li>入参为负数：表示相对于 0 索引的位置。</li>
</ul>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>对<strong>原数组</strong>进行删除和插入操作。被操作的元素后面的元素会自动调整位置。返回结果是一个数组，包含了被删除的元素，可能为空数组。</p>
<ul>
<li>第一个参数：删除和插入的起始位置。</li>
<li>第二个参数：删除的元素个数。</li>
<li>第三个开始的所有参数：要插入的元素，若参数为数组，则这个数组本身作为一个元素（这一点与 <code>concat()</code> 不同）。</li>
</ul>
<h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push 和 pop"></a>push 和 pop</h3><p>在<strong>原数组</strong>的末尾插入和弹出元素。若插入的是数组，则数组本身作为一个元素。</p>
<p><code>push()</code> 返回插入后的数组长度。<code>pop()</code> 返回弹出的元素。</p>
<h3 id="unshift-和-shift"><a href="#unshift-和-shift" class="headerlink" title="unshift 和 shift"></a>unshift 和 shift</h3><p>在<strong>原数组</strong>的开始插入和弹出元素。若插入的是数组，则数组本身作为一个元素。</p>
<p><code>unshift()</code> 返回插入后的数组长度。<code>shift()</code> 返回弹出的元素。</p>
<p>同时插入多个元素时会一次性插入，而不是一个个插入，也就是说插入后的元素顺序跟参数里的顺序一致。</p>
<h2 id="ES5-中的数组方法"><a href="#ES5-中的数组方法" class="headerlink" title="ES5 中的数组方法"></a>ES5 中的数组方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach()</code> 方法的第一个参数是一个函数。该函数有 3 个参数，依次为：数组元素、元素的索引、数组本身。</p>
<p><code>forEach()</code> 方法只能通过在函数中抛出 <code>foreach.break</code> 异常来提前中断。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>传入一个映射函数，对每个元素做映射，然后返回一个包含新元素的新数组。</p>
<p>若原数组是稀疏数组，则新数组也是稀疏数组，缺失的元素一样。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>传入一个判断函数，该函数返回 true/false，通过判断的元素会被放入新数组中。</p>
<p>稀疏数组中缺失的元素会被跳过，即返回的数组总是稠密的。</p>
<h3 id="every-和-some"><a href="#every-和-some" class="headerlink" title="every 和 some"></a>every 和 some</h3><p>传入一个判断函数，该函数返回 true/false，对所有元素应用该函数。</p>
<ul>
<li>every：仅当所有元素都通过判断时才返回 true。</li>
<li>some：当至少有一个元素通过判断时就返回 true。</li>
</ul>
<p>一旦确认返回值就会直接返回。根据数学上的惯例，对于空数组，every 返回 true，some 返回 false。</p>
<h3 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce 和 reduceRight"></a>reduce 和 reduceRight</h3><p>传入的第一个参数是一个组合函数，对数组内的元素进行组合，最终返回一个组合后的值。第二个参数是初始值，缺省为第一个元素。</p>
<p>reduce 是按照索引从低到高，reduceRight 则相反。</p>
<h3 id="indexOf-和-lasIndexOf"><a href="#indexOf-和-lasIndexOf" class="headerlink" title="indexOf 和 lasIndexOf"></a>indexOf 和 lasIndexOf</h3><p>在数组中查找指定元素，返回找到的第一个元素的索引，若未找到则返回 -1。</p>
<p>第二个参数是可选的，它指定开始搜索的位置。</p>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>ES5 中可以使用 <code>Array.isArray()</code> 来判断对象是否为数组。ES3 要自行判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">"[object Aray]"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p><strong>函数声明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function funcName(params) &#123;/*code*/&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = function(a, b) &#123;return a * b&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);</span><br></pre></td></tr></table></figure>
<p>但一般不使用构造函数。</p>
<p><strong>函数提升（Hoisting）</strong></p>
<p>“提升”是 JavaScript 默认将当前作用域提升到前面去的行为。<br>“提升”应用在变量的声明与函数的声明，但不应用于变量和函数的赋值。<br>因此，函数可以在声明之前调用。<br>“提升”是在 js 引擎预编译的时候进行的，即运行前。</p>
<p><strong>函数是对象</strong></p>
<p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” 。<br>但是 JavaScript 函数描述为一个对象更加准确。<br>JavaScript 函数有 属性 和 方法。<br>arguments.length 属性返回函数调用过程接收到的参数个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return arguments.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>toString()</code> 方法将函数作为一个字符串返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">var txt = myFunction.toString();</span><br></pre></td></tr></table></figure>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>有 4 种方式来调用 JavaScript 函数：</p>
<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过函数的 <code>call()</code> 和 <code>apply()</code> 方法间接调用</li>
</ul>
<h3 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h3><p>根据 ECMAScript 3 和非严格的 ECMAScript 5 对函数调用的规定，调用上下文 this 的值是全局对象。而在严格模式下调用上下文则是 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前是否为严格模式</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span>; &#125;());</span><br></pre></td></tr></table></figure>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用的上下文是包含方法的那个对象。</p>
<p>嵌套函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套函数作为函数调用，其 this 的值要么是全局对象（非严格模式）要么是 undefined （严格模式）。</p>
<p>若内部函数想访问外层函数的 this，则要在外层函数中把 this 赋给一个变量（通常为 self），然后内部函数访问这个变量。</p>
<h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>如果函数或方法调用之前带有关键字 new，就构成构造函数调用。</p>
<p>没有形参的构造函数调用可以省略括号。</p>
<p>构造函数调用新对象，该对象继承自构造函数的 prototype 属性。</p>
<p>构造函数中的 this 指向它新创建的对象，而不是调用构造函数的对象。比如 <code>new o.m()</code> 中，this 指向的不是 o。</p>
<h3 id="即调函数-IIFE"><a href="#即调函数-IIFE" class="headerlink" title="即调函数 IIFE"></a>即调函数 IIFE</h3><blockquote>
<p>Immediately-Invoked Function Expression</p>
</blockquote>
<p><strong>为什么需要 IIFE</strong></p>
<p>由于 js 在作用域方面比较薄弱，只有全局作用域和方法作用域，直到 ES6 才有块作用域，所以只能通过将逻辑封装到函数声明中来实现作用域隔离。</p>
<p>很多时候，我们需要执行一段逻辑，而这段逻辑很可能只需要执行一次，那么让这段逻辑的方法名和里面变量名去占用全局的命名空间就很不划算，这时候就需要使用 IIFE。</p>
<p>函数表达式可以 “自调用”。<br>自调用表达式会自动调用。<br>如果表达式后面紧跟 <code>()</code> ，则会自动调用。<br>不能自调用声明的函数。<br>通过添加括号，来说明它是一个函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var x = &quot;Hello!!&quot;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">//实际上只要想办法把函数声明转换成表达式就行</span><br><span class="line">(function() &#123;</span><br><span class="line">    var x = &quot;Hello!&quot;;</span><br><span class="line">&#125;());</span><br><span class="line">//再比如</span><br><span class="line">!function() &#123;</span><br><span class="line">    var x = &quot;Hello!&quot;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>虽然各种把函数声明转换成表达式的方式都能生效，但是性能会有差别。</p>
<p>js 引擎为了提升执行速度，在函数声明的时候只会做简单的语法分析，然后在函数执行的时候再做进一步的处理。对于自调函数显然应该直接做完整的处理。然而由于 js 引擎是通过符号特征来识别自调函数的（比如 <code>(function</code>），而有些引擎漏掉了一些不常见的特征，从而导致使用这些语法把函数声明转换成表达式的时候引擎不会把它当成自调函数来做优化，因而影响性能。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p><strong>函数显式参数(Parameters)与隐式参数(Arguments)</strong></p>
<blockquote>
<p>显示参数在函数定义时给出，相当于形参。<br>隐式参数在函数调用时传递，相当于实参。</p>
</blockquote>
<p><strong>参数规则</strong></p>
<p>JavaScript 函数定义时显式参数没有指定数据类型。<br>JavaScript 函数对隐式参数没有进行类型检测。<br>JavaScript 函数对隐式参数的个数没有进行检测。</p>
<h3 id="实参对象"><a href="#实参对象" class="headerlink" title="实参对象"></a>实参对象</h3><p>实参对象 <code>arguments</code> 不是一个数组，而是一个对象，只是它的属性碰巧是以数字为索引。</p>
<p>在非严格模式下，<code>arguments</code> 中的属性和对应的实参指向的是同一个对象，即修改时两处会同时改变。（ES5 中移除了此特性）</p>
<p><strong>callee 和 caller 属性</strong></p>
<p>实参对象还定义了 <code>callee</code> 和 <code>caller</code> 属性。</p>
<p>在 ECMAScript 5 严格模式下，对这两个属性读写会产生类型错误。在非严格模式下，ES 规范规定 <code>callee</code> 属性指代当前正在执行的函数，而 <code>caller</code> 是非标准的，大多数浏览器实现这个属性指代调用当前执行函数的那个函数。</p>
<h2 id="函数属性、方法和构造函数"><a href="#函数属性、方法和构造函数" class="headerlink" title="函数属性、方法和构造函数"></a>函数属性、方法和构造函数</h2><h3 id="call-方法和-apply-方法"><a href="#call-方法和-apply-方法" class="headerlink" title="call() 方法和 apply() 方法"></a>call() 方法和 apply() 方法</h3><p>第一个参数作为方法中 <code>this</code> 的值，后面的参数作为方法的实参。</p>
<p>在 ES5 的严格模式中，第一个参数即使是原始类型或者 null 或者 undefined 也会作为 <code>this</code> 的值。在 ES3 和非严格模式中，原始类型会被包装对象替代，null 和 undefined 会被全局对象替代。</p>
<p>call() 从第二个参数开始依次作为函数的实参。apply() 将函数的所有实参放入一个数组中作为第二个参数。</p>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h3><p>bind() 方法的第 1 个参数是一个对象，它会被作为被绑定方法的 this。从第 2 个参数开始是可选的，它们依次绑定到被绑定方法的入参上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y + <span class="keyword">this</span>.z; &#125;;</span><br><span class="line"><span class="keyword">var</span> newSum = sum.bind(&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = newSum(<span class="number">2</span>);<span class="comment">// x=1,y=2,z=3</span></span><br></pre></td></tr></table></figure>
<p>通常被用来实现科里化。</p>
<h1 id="类和模块"><a href="#类和模块" class="headerlink" title="类和模块"></a>类和模块</h1><h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><p>构造函数的 prototype 属性被用作新对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数首字母大写，这是编程约定而不是语法限制。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">  <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">  includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rangeObj = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和类的标识"><a href="#构造函数和类的标识" class="headerlink" title="构造函数和类的标识"></a>构造函数和类的标识</h3><p>两个对象是否为同一个类的实例，取决于它们的 prototype 是否指向同一个对象，而不是取决于它们是否从同一个构造函数创建的。</p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>因为任何函数都可以作为构造函数，而调用构造函数是需要用到 prototype 属性的，所以每个函数（除 ES5 中的 <code>Function.bind()</code>）都自动拥有一个 prototype 属性。该属性包含唯一一个不可枚举属性 constructor，它的值是一个函数对象。</p>
<p>像上述那样显式定义 Range.prototype 的话就不存在 constructor 属性了，需要显式定义。</p>
<p>另一种方式是在预设的 prototype 上添加方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.includes = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">Range.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Javascript-中的-Java-式类继承"><a href="#Javascript-中的-Java-式类继承" class="headerlink" title="Javascript 中的 Java 式类继承"></a>Javascript 中的 Java 式类继承</h2><ul>
<li>构造函数对象：构造函数为类定义了名字。任何添加到构造函数对象中的属性都是类属性或类方法。</li>
<li>原型对象：原型对象的属性被类的所有实例继承。</li>
<li>实例对象：添加到实例对象中的属性是该对象独享的。</li>
</ul>
<h2 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 右边的参数是构造函数，但计算过程实际上是检测了对象的原型继承关系，而不是创建对象的构造函数。</p>
<p>也可以不用构造函数，而直接用对象来判断继承关系：<code>examplePrototype.isPrototypeOf(obj)</code>。</p>
<p>这两种方法的缺点是：</p>
<ul>
<li>只能检测对象是否属于某个类，而不能在类未知的情况下通过对象获取类名。</li>
<li>在 Web 客户端中，每个窗口和框架子页面都有独立的上下文，概念上相同的类/对象在不同上下文中都是独立的。</li>
</ul>
<h3 id="构造函数的名称"><a href="#构造函数的名称" class="headerlink" title="构造函数的名称"></a>构造函数的名称</h3><p>为解决不同上下文中的类型检测问题，可以通过构造函数名称来区分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t, c, n; <span class="comment">// type, class, name</span></span><br><span class="line">  <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">  <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">"NaN"</span></span><br><span class="line">  <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">"object"</span>) <span class="keyword">return</span> t; <span class="comment">// 原始值的类型和函数</span></span><br><span class="line">  <span class="keyword">if</span> ((c = classof(o) !== <span class="string">"Object"</span>) <span class="keyword">return</span> c; <span class="comment">// 可以识别出大多数的内置对象</span></span><br><span class="line">  <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">"function"</span> &amp;&amp; (n = o.constructor.getName())) <span class="keyword">return</span> n; <span class="comment">// 若构造函数名字存在的话</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Object"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字（可能是空字符串），不是函数的话返回 null</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*)\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的问题在于，不是所有对象都有 constructor 属性，也不是所有函数都有名字，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个构造函数没名字</span></span><br><span class="line"><span class="keyword">var</span> Complex = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> Range = <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">f, t</span>) </span>&#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="鸭式辩型"><a href="#鸭式辩型" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h3><blockquote>
<p>不要关注“对象的类是什么”，而是关注“对象能做什么”。</p>
</blockquote>
<h2 id="Javascript-中的面向对象技术"><a href="#Javascript-中的面向对象技术" class="headerlink" title="Javascript 中的面向对象技术"></a>Javascript 中的面向对象技术</h2><h3 id="标准转换方法"><a href="#标准转换方法" class="headerlink" title="标准转换方法"></a>标准转换方法</h3><ul>
<li>toString：在希望使用字符串的地方（比如将对象用作属性名或用“+”拼接字符串），JavaScript 会自动调用此方法。</li>
<li>toLocaleString：默认情况下 toLocalString 方法只是简单的调用了 toString 方法。</li>
<li>valueOf：用来将对象转换为原始值。比如当数字运算符（除了“+”）和关系运算符作用于数字文本表示的对象时，会自动调用 valueOf。</li>
<li>toJSON：由 JSON.stringify() 自动调用，用来进行对象序列化。</li>
</ul>
<h3 id="私有状态"><a href="#私有状态" class="headerlink" title="私有状态"></a>私有状态</h3><p>通过将变量（或参数）闭包在一个构造函数内来模拟私有实例字段。但是这样会降低运行速度、占用更多内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funtion Range(<span class="keyword">from</span>, to) &#123;</span><br><span class="line">  <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;;</span><br><span class="line">  <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式的模式匹配"><a href="#正则表达式的模式匹配" class="headerlink" title="正则表达式的模式匹配"></a>正则表达式的模式匹配</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>一些 Perl 正则语法不被 ECMAScript 支持：</p>
<ul>
<li>s（单行模式）和 x（扩展语法）标记。</li>
<li>\a、\e、\l、\u、\L、\U、\E、\Q、\A、\Z、\z、\G 转义字符。</li>
<li><code>(?&lt;=</code> 正向后行断言、<code>(?&lt;!</code> 负向后行断言。</li>
<li><code>(?#</code> 注释和扩展 <code>(?</code> 的语法。</li>
</ul>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>i：不区分大小写。</li>
<li>g：全局匹配。</li>
<li>m：多行匹配。<code>^</code> 匹配字符串开头和换行后的开头，<code>$</code> 同理。</li>
</ul>
<h2 id="用于模式匹配的-String-方法"><a href="#用于模式匹配的-String-方法" class="headerlink" title="用于模式匹配的 String 方法"></a>用于模式匹配的 String 方法</h2><p><code>&quot;abc&quot;.search(/ab/);</code></p>
<p>传入正则表达式（若不是则自动通过 RegExp 构造函数转换），返回 -1（匹配不到）或匹配结果的首字符的索引。不支持全局搜索（即使使用修饰符 g）。</p>
<p><code>&quot;abc&quot;.replace(/ab/, &quot;cd&quot;);</code></p>
<p>传入两个参数。第一个参数是正则表达式（若不是则自动通过 RegExp 构造函数转换），第二个参数是要替换的字符串或是用来计算字符串的函数。第二个参数中可以通过 <code>$</code> 加数字来引用分组。</p>
<p><code>&quot;abc&quot;.match(/ab/);</code></p>
<p>传入正则表达式（若不是则自动通过 RegExp 构造函数转换），返回由匹配结果组成的数组。需要在表达式中使用修饰符 g 来获取全部匹配结果。若是全局匹配，则结果数组包含了所有匹配。若不是全局匹配，则 a[0] 是完整的匹配，a[1] 开始的元素依次是每个分组的匹配。</p>
<p><code>&quot;abc&quot;.split(/a/);</code></p>
<p>入参可以是字符串或正则表达式。返回分割之后的数组。</p>
<h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p>构造函数接受一个必选参数，一个可选参数。</p>
<p>必选参数是字符串形式的正则表达式。可选参数是字符串形式的修饰符。</p>
<h3 id="RegExp-的属性"><a href="#RegExp-的属性" class="headerlink" title="RegExp 的属性"></a>RegExp 的属性</h3><ul>
<li>source：只读的字符串，包含正则表达式的文本。</li>
<li>global：只读的布尔值，说明是否带有修饰符 g。</li>
<li>ignoreCase：只读的布尔值，说明是否带有修饰符 i。</li>
<li>multiline：只读的布尔值，说明是否带有修饰符 m。</li>
<li>lastIndex：可读/写的整数，如果带有修饰符 g，则这个属性存储在整个字符串中下次检索的开始位置。</li>
</ul>
<h3 id="RegExp-的方法"><a href="#RegExp-的方法" class="headerlink" title="RegExp 的方法"></a>RegExp 的方法</h3><p><strong>exec()</strong></p>
<p>传入一个字符串。如果没有匹配，则返回 null；如果有一个匹配，则返回一个数组，a[0] 是匹配结果，a[1] 开始依次是分组匹配，index 属性包含了发生匹配的字符位置，input 属性包含了正在检索的字符串。跟 <code>String.match()</code> 不同，不管有没有修饰符 g，都会返回一样的数组。</p>
<p>若带有修饰符 g，则可以反复调用此方法来尝试获得多个匹配。此方法会通过设置正则表达式的 lastIndex 属性来实现此功能。</p>
<p><strong>test()</strong></p>
<p>和 <code>exec()</code> 等价，当 <code>exec()</code> 返回不是 null 时，此方法返回 true。如带有修饰符 g，则也可以反复调用此方法来尝试进行多次匹配。</p>
<p><strong>与 String 的方法的区别</strong></p>
<p>String 的 <code>search()</code>、<code>replace()</code>、<code>match()</code> 方法不会用到 lastIndex 属性，它们只是简单地将该属性置为 0。如果让一个全局正则表达式对多个字符串执行 <code>exec()</code> 和 <code>test()</code> 方法，要么找出所有匹配以便将 lastIndex 属性置为 0，要么手动进行设置，否则会影响后续匹配的起始位置。</p>
<h1 id="JavaScript-的子集和扩展"><a href="#JavaScript-的子集和扩展" class="headerlink" title="JavaScript 的子集和扩展"></a>JavaScript 的子集和扩展</h1><h2 id="JavaScript-的子集"><a href="#JavaScript-的子集" class="headerlink" title="JavaScript 的子集"></a>JavaScript 的子集</h2><h3 id="子集的安全性"><a href="#子集的安全性" class="headerlink" title="子集的安全性"></a>子集的安全性</h3><p>为了让 js 代码静态地通过安全检查，必须移除一些特性：</p>
<ul>
<li><code>eval()</code> 和 <code>Function()</code> 构造函数在任何安全子集里都是禁止的，因为它们可以执行任意代码，无法对这些代码做静态分析。</li>
<li>禁止使用 <code>this</code>，因为在非严格模式中，函数可以通过 <code>this</code> 访问全局对象。而沙箱系统的一个重要目标就是禁止对全局对象的访问。</li>
<li>禁止使用 <code>with</code>，因为会增加静态代码检查的难度。</li>
<li>禁止使用某些全局变量。<code>window</code> 和 <code>document</code> 对象可以操作浏览器和页面，因而存在隐患。一种方法是完全禁用这些全局对象，提供自定义的一组 API 来进行有限制的操作。另一种方法是在沙箱代码运行的“容器”内定义一个只对外提供安全的标准 DOM API 的 facade 或 proxy。</li>
<li>禁止使用某些属性和方法，以免沙箱中的代码拥有过多权限。包括 <code>arguments</code> 的 <code>caller</code> 和 <code>callee</code> 属性（甚至是 <code>arguments</code> 本身）、函数的 <code>call()</code> 和 <code>apply()</code>，以及 <code>constructor</code> 和 <code>prototype</code> 属性。</li>
<li>相对于 <code>.</code> 运算符访问属性而言，<code>[]</code> 中的字符串表达式无法做静态分析。因此，安全子集通常禁止使用方括号，除非里面是数字或字符串直接量。安全子集将 <code>[]</code> 替换为全局函数，这些全局函数在存取属性之前会执行运行时检查以确保不会读写那些禁止访问的属性。</li>
</ul>
<p>一些比较重要的安全子集实现：</p>
<ul>
<li>ADsafe：只包含静态检查，使用 JSLint 作为检验器。禁止访问大部分全局变量，并定义了一个 <code>ADSAFE</code> 变量，提供了一组安全的 API，包括一些特殊的 DOM 方法。</li>
<li>dojox.secure：基于静态检查，静态检查受限于子集范围内。使用标准 DOM API。同时，它包含一个用 JavaScript 实现的检查器。</li>
<li>Caja：它定义了两个语言子集。Cajita （小沙盒）是一个与 ADsafe 和 dojox.secure 相似的严格子集。Valija (手提箱或行李箱）范围更广，接近 ECMAScript 5 的严格模式（不含 eval()）。Caja 本身也是一个编译器的名字，可以将一段网页内容转换为一个安全的模块</li>
<li>FBJS：它是 JavaScript 的变种，依赖代码转换来保证代码的安全性，转换器同时提供运行时检查，以避免通过 <code>this</code> 访问全局对象，并对所有顶层标识符重命名，给它们增加了一个标识模块的前缀。因为这种重命名，任何对全局变量和其他模块的变量的操作都无法进行。FBJS 模拟实现了 DOM API 的一个安全子集。</li>
<li>Microsoft Web Sandbox：定义了 JavaScript 的一个更宽泛的子集，包含 HTML 和 CSS，它的代码重写规则非常激进，有效地重新实现了一个安全的 JavaScript 虚拟机，针对不安全的 js 顶层代码进行处理。</li>
</ul>
<h2 id="常量和局部变量"><a href="#常量和局部变量" class="headerlink" title="常量和局部变量"></a>常量和局部变量</h2><p>在 js 1.5 及以后版本中可以用 <code>const</code> 定义常量。对常量重新赋值会失败但不会报错，重新声明会报错。常量会被提升至函数顶部。<code>const</code> 是 js 保留字，所以无需加入版本号。</p>
<p><code>const</code> 类似 Java 中的 <code>final</code>，只能保证引用不被修改，不保证引用的对象内部不被修改。</p>
<p>js 1.7 针对没有块级作用域的缺陷增加了 <code>let</code> 关键字，由于不是保留字，所以需要手动加入版本号。</p>
<p>这里的版本号指的是 Mozilla 的语言版本。在 Spidermonkey 和 Rhino 解析器和 Firefox Web 浏览器中实现了这些语言版本。</p>
<p>在 Spidermonkey 或 Rhino 中，可以通过命令行选项指定版本，或通过一个内置函数 <code>version()</code> 指定。指定的版本号是实际版本号乘以 100。在 Firefox 中，可以在 script 标签中指定版本：<code>&lt;script type=&quot;application/javascript; version=1.8&quot;&gt;</code>。</p>
<p><code>let</code> 4 种使用方式：</p>
<ul>
<li>作为变量声明，和 <code>var</code> 一样。</li>
<li>在 for 循环种，作为 <code>var</code> 的替代方案。</li>
<li>在语句块中定义一个新变量并显式指定它的作用域。</li>
<li>定义一个在表达式内部作用域中的变量，只在表达式内可用。</li>
</ul>
<p>其中第 4 种用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let 语句块</span></span><br><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> (x=x+<span class="number">1</span>, y=x+<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y); <span class="comment">//5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x+y);   <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let 表达式</span></span><br><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">let</span>(x=x+<span class="number">1</span>, y=x+<span class="number">2</span>) x+y);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 语句中的变量初始化表达式不是语句块的一部分，并且是在作用域外部解析的。</p>
<p>在 ES6 之前，全局变量会自动挂构成顶层对象（比如浏览器中的 window）的属性，反之亦然。ES6 规定，<code>let</code>、<code>const</code>、<code>class</code> 声明的变量不属于顶层对象的属性。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>Spidermonkey 1.7 实现了一种混合式赋值，即“解构赋值”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// let x=1, y=2</span></span><br><span class="line"><span class="keyword">let</span> [,x,,y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// let x=2, y=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构赋值运算的返回值是右侧的整个数据结构，而不是提取出来的某个值</span></span><br><span class="line"><span class="keyword">let</span> a, b, all;</span><br><span class="line">all = [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a=1, b=2, all=[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于数组嵌套的情况，左侧应当是同样格式的嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> [a, [b, c]] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]; <span class="comment">// a=1, b=2, c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:a, <span class="attr">age</span>:b&#125; = &#123;<span class="attr">name</span>: <span class="string">"tom"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>(a + <span class="string">" "</span> + b); <span class="comment">// tom 18</span></span><br></pre></td></tr></table></figure>
<p>左侧多余的变量赋值为 undefined，右侧多余的变量被忽略。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for/each 循环"></a>for/each 循环</h3><p>for/each 循环是由 E4X 规范（ECMAScript for XML）定义的一种新的循环语句。遍历范围包含继承来的可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> each (<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> each (<span class="keyword">let</span> p <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器必须包含 <code>next()</code> 方法，返回集合中的下一个值。</li>
<li>当没有下一个值时，会抛出 <code>StopIteration</code>。它是 JavaScript 1.7 中的全局对象的属性。</li>
</ul>
<p>一般不直接用迭代器，而是用可迭代对象。</p>
<ul>
<li>可迭代对象必须包含 <code>_iterator_()</code> 方法，该方法返回一个迭代器。</li>
<li>JavaScript 1.7 的 for/in 循环会自动调用 <code>_iterator_()</code> 方法，并处理 StopIteration 异常。</li>
</ul>
<p>JavaScript 1.7 中有一个全局函数 <code>Iterator()</code>。</p>
<ul>
<li><code>Iterator()</code> 会自动调用参数的 <code>_iterator_()</code>，并返回该迭代器。</li>
<li>若参数没有 <code>_iterator_()</code> 方法，则会返回参数的一个自定义迭代器。该迭代器每次返回一个包含两个值的数组，第一个元素是属性名，第二个是对应的值。<ul>
<li>该迭代器只对自有属性进行遍历，忽略继承属性。</li>
<li>如果传入 <code>Iterator()</code> 的第二个参数是 true，返回的迭代器只对属性名进行遍历，忽略属性值。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">in</span> Iterator(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k + <span class="string">"="</span> + v); <span class="comment">// a=1 b=2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是 JavaScript 1.7 中的特性。</p>
<p>任何使用关键字 <code>yield</code> 的函数（哪怕不可达）都称为生成器函数。生成器函数通过 <code>yield</code> 返回值，通过 <code>return</code> 来终止函数而不带返回值。对生成器函数的调用不是执行函数体本身，而是返回一个生成器对象。</p>
<p>生成器是一个迭代器对象，表示生成器函数当前的执行状态。它有几个方法：</p>
<ul>
<li><code>next()</code>：该方法可恢复生成器函数的执行，直到下一条 <code>yield</code> 语句，<code>yield</code> 的返回值就是 <code>next()</code> 的返回值，而 <code>return</code> 会使 <code>next()</code> 抛出一个 <code>StopIteration</code>。</li>
<li><code>close()</code>：用来释放生成器对象，相当于在挂起位置执行了 <code>return</code>。</li>
<li><code>send()</code>：<code>yield</code> 是一个表达式而不是语句，也就是说它是可以有值的。<code>send()</code> 和 <code>next()</code> 一样继续执行生成器，不同的是它可以传入一个参数作为 <code>yield</code> 表达式的值。</li>
<li><code>throw()</code>：继续执行生成器，可以传入一个参数，<code>yield</code> 表达式会将该参数作为异常抛出。</li>
</ul>
<h3 id="数组推导"><a href="#数组推导" class="headerlink" title="数组推导"></a>数组推导</h3><p>语法：<code>[expression for (variable in object) if (condition)]</code></p>
<p>数组推导包含三部分：</p>
<ol>
<li>一个没有循环体的 for/in 或 for/each 循环。其中，变量之前没有 <code>var</code> 或 <code>let</code>，实际上是使用了隐式的 <code>let</code>，因而不会覆盖外部的变量。</li>
<li>在执行循环获得对象之后，用 if 条件判断，若为 true 则继续。if 判断是可选的。</li>
<li>将变量用 expression 计算，并将结果插入要创建的数组中。</li>
</ol>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>在 JavaScript 1.8 中，将数组推导中的方括号替换成圆括号就成了一个生成器表达式。该表达式的值是一个生成器对象，而不是数组。</p>
<h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>JavaScript 1.8 中，函数有一种简写形式。如果函数只是计算并返回一个表达式的值，那么可以写成：<code>function(arg) expression</code>。</p>
<h2 id="多-catch-从句"><a href="#多-catch-从句" class="headerlink" title="多 catch 从句"></a>多 catch 从句</h2><p>从 JavaScript 1.5 开始支持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e <span class="keyword">if</span> e <span class="keyword">instanceof</span> Example) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e <span class="keyword">if</span> e === <span class="string">"blabla"</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E4X-ECMAScript-for-XML"><a href="#E4X-ECMAScript-for-XML" class="headerlink" title="E4X:ECMAScript for XML"></a>E4X:ECMAScript for XML</h2><p>E4X 是 JavaScript 的一个标准扩展。通常用于服务端，大部分客户端还没支持。</p>
<h1 id="web-浏览器中的-JavaScript"><a href="#web-浏览器中的-JavaScript" class="headerlink" title="web 浏览器中的 JavaScript"></a>web 浏览器中的 JavaScript</h1><h2 id="JavaScript-程序的执行"><a href="#JavaScript-程序的执行" class="headerlink" title="JavaScript 程序的执行"></a>JavaScript 程序的执行</h2><h3 id="客户端-Javascript-时间线"><a href="#客户端-Javascript-时间线" class="headerlink" title="客户端 Javascript 时间线"></a>客户端 Javascript 时间线</h3><p>以下是理想的事件线，但不是所有浏览器都完全实现。</p>
<ol>
<li>浏览器创建 <code>Document</code> 对象，并开始解析页面：在解析 HTML 元素和它们的文本内容后添加 <code>Element</code> 对象和 <code>Text</code> 节点到文档中。此阶段 <code>document.readystate</code> 属性是“loading”。</li>
<li>当 HTML 解析器遇到没有 <code>async</code> 和 <code>defer</code> 属性的 <code>&lt;script&gt;</code> 元素时，它把元素添加到文档中并执行相应脚本。脚本的执行是同步的，在脚本下载（若需要）和执行时解析器会暂停。因此脚本可以通过 <code>document.write()</code> 向输入流写入文本。同步脚本可以看到它自身和之前的文档内容。</li>
<li>当遇到 <code>async</code> 属性的 <code>&lt;script&gt;</code> 元素时，会下载脚本并继续解析文档。脚本会在下载完成后尽快执行，但解析器不会为它暂停。异步脚本禁止使用 <code>document.write()</code>。它可以看到自身和之前的文档内容。</li>
<li>当文档解析完成，<code>document.readystate</code> 变为“interactive”。</li>
<li>按出现顺序依次执行所有 <code>defer</code> 属性脚本。它能访问完整的文档树，但不能使用 <code>document.write()</code>。</li>
<li>浏览器在 <code>Document</code> 对象上触发 <code>DOMContentLoaded</code> 事件，标志着程序执行从同步阶段转到了异步事件驱动阶段。此时可能还有异步脚本没有执行完成。</li>
<li>至此文档已解析完毕，但可能还有其他内容没载入完成，比如图片。当所有内容载入完成、异步脚本执行完成后，<code>document.readystate</code> 属性变为“complete”，浏览器触发 <code>Window</code> 对象上的 <code>load</code> 事件。</li>
<li>开始调用异步事件。</li>
</ol>
<h2 id="兼容性和互用性"><a href="#兼容性和互用性" class="headerlink" title="兼容性和互用性"></a>兼容性和互用性</h2><h3 id="Internet-Explorer-里的条件注释"><a href="#Internet-Explorer-里的条件注释" class="headerlink" title="Internet Explorer 里的条件注释"></a>Internet Explorer 里的条件注释</h3><p>条件注释不是标准规范，而是 IE5 开始引入的功能，主要用于解决 IE 相关的兼容性问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]&gt;</span></span><br><span class="line"><span class="comment">只会在 IE6 显示。</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">在 IE5、6、7 中显示。还可以用 lt、gt、gte。</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;&lt;--&gt;</span></span><br><span class="line">不会在 IE 中显示。</span><br><span class="line"><span class="comment">&lt;!--&gt;&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>
<p>IE 的 JavaScript 解释器也支持条件注释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    alert("in IE");//会在 IE 中执行</span></span><br><span class="line"><span class="comment">  @end</span></span><br><span class="line"><span class="comment">  @*/</span></span><br></pre></td></tr></table></figure>
<h1 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h1><h2 id="浏览器定位和导航"><a href="#浏览器定位和导航" class="headerlink" title="浏览器定位和导航"></a>浏览器定位和导航</h2><p><code>Window</code> 对象和 <code>Document</code> 对象的 <code>location</code> 属性引用同一个 <code>Location</code> 对象，表示当前显示文档的 URL。</p>
<p><code>Document</code> 对象还有一个 <code>URL</code> 属性，是文档首次载入后保存文档 URL 的静态字符串。如果定位到文档中的片段标识符，<code>Location</code> 对象会相应更新，而 <code>document.URL</code> 则不会。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p><code>window.location</code> 引用的是 <code>Location</code> 对象，表示当前显示文档的 URL。</p>
<p><code>location.href</code> 是一个字符串形式的 URL。</p>
<p><code>Location</code> 对象的 <code>toString()</code> 返回 <code>href</code> 的值。</p>
<p><code>Location</code> 对象还有其他属性：<code>protocol</code>、<code>host</code>、<code>hostname</code>、<code>port</code>、<code>pathname</code>、<code>search</code>，分别表示 URL 的各部分。</p>
<p><code>Location</code> 对象的 <code>hash</code> 属性（若存在的话）返回 URL 中的片段标识符部分。<code>search</code> 属性返回问号之后的 URL（含问号）。</p>
<h3 id="载入新的文档"><a href="#载入新的文档" class="headerlink" title="载入新的文档"></a>载入新的文档</h3><p>在 <code>Location</code> 对象中：</p>
<ul>
<li><code>assign()</code> 使窗口载入指定 URL 的文档。</li>
<li><code>replace()</code> 类似 <code>assign()</code>，只是在载入新文档之前会从浏览历史中删除当前文档。</li>
<li>另一种更传统的跳转方法是把新的 URL 赋给 location` 属性。</li>
<li><code>reload()</code> 重现载入当前文档。</li>
</ul>
<h2 id="浏览历史"><a href="#浏览历史" class="headerlink" title="浏览历史"></a>浏览历史</h2><p><code>window.history</code> 属性引用的是 <code>History</code> 对象。<code>History.length</code> 表示浏览历史列表中的元素数量。出于安全考虑，脚本不能访问已保存的 URL，否则任意脚本都能窥探浏览历史。</p>
<p><code>back()</code> 和 <code>forward()</code> 跟浏览器的后退、前进一样。<code>go()</code> 接受一个整数参数，在历史列表中向前（正整数）或向后（负整数）跳跃指定页数。</p>
<p>如果窗口包含多个子窗口（比如 <code>&lt;iframe&gt;</code>），子窗口的历史会按时间顺序穿插在主窗口的历史中。</p>
<h2 id="浏览器和屏幕信息"><a href="#浏览器和屏幕信息" class="headerlink" title="浏览器和屏幕信息"></a>浏览器和屏幕信息</h2><h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><p><code>window.nevigator</code> 引用的是包含浏览器厂商和版本信息的 <code>Navigator</code> 对象（此名字是为了纪念 Netscapte Nevigator 浏览器）。</p>
<ul>
<li><code>appName</code>：Web 浏览器的全称。在 IE 中是“Microsoft Internet Explorer”，在其他浏览器中通常是“Netscape”。</li>
<li><code>appVersion</code>：通常以数字开始，跟着包含浏览器厂商和版本信息的详细字符串。字符串没有标准格式，不能直接用来判断浏览器的类型。</li>
<li><code>userAgent</code>：浏览器在 <code>USER-AGENT</code> 头部中发送的字符串。</li>
<li><code>platform</code>：运行浏览器的操作系统的字符串。</li>
<li><code>onLine</code>：若存在的话表示浏览器当前是否连接到网络。</li>
<li><code>geolocation</code>：用于确定用户地理位置。</li>
<li><code>javaEnabled()</code>：非标准方法，判断浏览器是否可以运行 Java 小程序。</li>
<li><code>cookieEnable()</code>：非标准方法，判断浏览器是否可以保存永久的 cookie。当 cookie 配置为“视具体情况而定”时可能返回不正确的值。</li>
</ul>
<h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><ul>
<li><code>width</code>、<code>height</code>：以像素为单位的窗口大小。</li>
<li><code>availWidth</code>、<code>availHeight</code>：实际可用的大小。</li>
<li><code>colorDepth</code>：显示的 BPP（bits-per-pixel）值，典型的值是 16、24、32。</li>
</ul>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ul>
<li><code>alert()</code>：提示框。</li>
<li><code>confirm()</code>：确认框，返回布尔值。</li>
<li><code>prompt()</code>：提示输入框，返回用户输入的字符串。</li>
<li><code>showModalDialog()</code>：显示一个包含 HTML 格式的“模态对话框”，可以给它传入参数，以及从对话框里返回值。</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><code>Window.onerror</code> 的值是一个事件处理程序。由于历史原因，它接受三个字符串参数而不是一个事件对象。</p>
<ol>
<li>描述错误的一条消息。</li>
<li>引发错误的 js 代码所在文档的 URL 的字符串。</li>
<li>文档中发生错误的行数。</li>
<li>返回 false，表示它通知浏览器事件处理程序已经处理了错误，即浏览器不应该显示错误消息。但由于历史原因，Firefox 里的错误处理程序必须返回 true 来表示它已经处理了错误。</li>
</ol>
<h2 id="多窗口和窗体"><a href="#多窗口和窗体" class="headerlink" title="多窗口和窗体"></a>多窗口和窗体</h2><h3 id="打开和关闭窗口"><a href="#打开和关闭窗口" class="headerlink" title="打开和关闭窗口"></a>打开和关闭窗口</h3><p><code>Window.open()</code> 有 4 个可选参数：</p>
<ol>
<li>新窗口中文档的 URL，若省略或为空字符串，则会使用 about:blank。</li>
<li>新窗口的名字。若指定的是已存在的窗口名字，则会直接使用该窗口。若省略会使用 <code>_blank</code>。<ul>
<li>只有设置了“允许导航”（allowed to navigator）（HTML5 术语）的页面才行。当且仅当窗口包含的文档是同源的，或是此脚本打开了那个窗口（包括递归打开），脚本才能只通过名字来指定存在的窗口。</li>
<li>若两个窗口是内嵌关系，那它们的脚本可以互相导航。此时可以用保留的名字 <code>_top</code> 和 <code>_parent</code> 来获取彼此的上下文。</li>
</ul>
</li>
<li>以逗号分隔的列表，包含大小和各种属性。若省略则会用一个默认的大小，而且带有一整组标准的 UI 组件，即菜单栏、状态栏、工具栏等。这个参数是非标准的。</li>
<li>一个布尔值，只在第二个参数命名的是一个存在的窗口时才有用，声明了由第一个参数指定的 URL 是应该替换掉窗口浏览历史的当前条目（true），还是应该在历史中创建一个新的条目（false），后者是默认值。</li>
</ol>
<p>返回值是代表命名或新创建的窗口的 <code>Window</code> 对象。该对象的 <code>opener</code> 属性引用的是调用 <code>open</code> 方法的那个窗口。</p>
<h3 id="窗体之间的关系"><a href="#窗体之间的关系" class="headerlink" title="窗体之间的关系"></a>窗体之间的关系</h3><p>顶级窗口或标签的 <code>parent</code> 和 <code>top</code> 属性引用的是自身。</p>
<p><code>&lt;iframe&gt;</code> 元素由 <code>contentWindow</code> 属性，引用的是该窗体对象。反过来，窗体的 <code>window.frameElement</code> 属性引用的是相应的 <code>&lt;iframe&gt;</code> 元素对象。顶级窗口对象的 <code>frameElement</code> 属性为 null。</p>
<p>通常用另一种方式来获取其他窗体对象。</p>
<p>每个 <code>Window</code> 对象都有一个 <code>frames</code> 属性，包含了该窗口所包含的窗口或窗体的 <code>Window</code> 对象（而不是 <code>&lt;iframe&gt;</code> 对象）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个子窗体的第三个子窗体。</span></span><br><span class="line"><span class="keyword">var</span> w1 = frames[<span class="number">1</span>].frames[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//兄弟窗体</span></span><br><span class="line"><span class="keyword">var</span> w2 = parent.frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//通过 &lt;iframe&gt; 元素的 name 或 id 来索引</span></span><br><span class="line"><span class="keyword">var</span> w3 = frames[<span class="string">"f1"</span>];</span><br></pre></td></tr></table></figure>
<p>实际上 <code>frames</code> 属性引用的是 <code>window</code> 本身，也就是说 <code>window</code> 本身就是一个由子窗体对象组成的数组。不过通过 <code>frames</code> 来引用会显得清楚一点。</p>
<h1 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h1><h2 id="文档结构和遍历"><a href="#文档结构和遍历" class="headerlink" title="文档结构和遍历"></a>文档结构和遍历</h2><h3 id="作为节点树的文档"><a href="#作为节点树的文档" class="headerlink" title="作为节点树的文档"></a>作为节点树的文档</h3><p><code>Document</code>、<code>Element</code>、<code>Text</code> 对象都是 <code>Node</code> 对象。<code>Node</code> 定义了以下属性：</p>
<ul>
<li><code>parentNode</code>：若无父节点则为 null。</li>
<li><code>childNodes</code>：只读的类数组对象（<code>NodeList</code>）。</li>
<li><code>firstChild</code>、<code>lastChild</code></li>
<li><code>nextSibling</code>、<code>previousSibling</code></li>
<li><code>NodeType</code>：节点类型。9：Document，1：Element，3：Text，8：Comment，11：DocumentFragment。</li>
<li><code>NodeValue</code>：Text 节点或 Comment 节点的文本内容。</li>
<li><code>nodeName</code>：元素的标签名，大写。</li>
</ul>
<h1 id="Javascript核心参考"><a href="#Javascript核心参考" class="headerlink" title="Javascript核心参考"></a>Javascript核心参考</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>属性</strong></p>
<ul>
<li><code>length</code>: 字符数。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><code>charAt</code> 返回指定索引处的字符。</li>
<li><code>charCodeAt</code> 返回指定索引处的字符的编码。</li>
<li><code>concat</code> 将若干值拼接成一个字符串。</li>
<li><code>indexOf</code> 返回子字符串第一次出现的位置。</li>
<li><code>lastIndexOf</code> 返回子字符串最后一次出现的位置。</li>
<li><code>localeCompare</code> 使用本地定义的顺序比较字符串。</li>
<li><code>match</code> 使用正则进行匹配。</li>
<li><code>replace</code> 使用正则进行替换。</li>
<li><code>search</code> 返回匹配正则的子字符串。</li>
<li><code>slice(start, end)</code> 返回一个子字符串。<ul>
<li><code>start</code> 起始处索引（包含），可为负数。</li>
<li><code>end</code> 结束处索引（不含），可为负数。若未指定则默认为结尾。</li>
</ul>
</li>
<li><code>split</code> 用指定字符串或正则表达式作为分隔符，返回分割后的字符串数组。</li>
<li><code>substr(start, length)</code> 返回一个子字符串。指定起始索引和子字符串长度。</li>
<li><code>substring(start, end)</code> 返回一个子字符串。索引不能为负数。</li>
<li><code>toLowerCase</code> 转小写。</li>
<li><code>toUpperCase</code> 转大写。</li>
<li><code>trim</code> 删除前后空白字符。</li>
</ul>
<p><strong>静态方法</strong></p>
<ul>
<li><code>fromCharCode</code> 创建指定编码对应的字符串。</li>
</ul>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><blockquote>
<p>string.replace(regex, replacement)</p>
</blockquote>
<ul>
<li><code>regex</code> 正则表达式对象。若实际传入的是字符串而不是正则对象，则按照字符串字面量匹配，而不会自动转换成正则对象。</li>
<li><code>replacement</code> 替换用的字符串或函数。<ul>
<li>若为函数（ES3 开始），则函数的入参是：<ul>
<li>匹配到字符串，它的返回值会作为替换用的字符串。</li>
</ul>
</li>
<li>若为字符串，则其中的 <code>$</code> 有特殊含义。<ul>
<li><code>$1</code>, <code>$2</code>, …, <code>$99</code>: 对应 <code>regex</code> 中的分组内匹配到的文本。</li>
<li><code>$&amp;</code>: <code>regex</code> 匹配到的子串。</li>
<li><code>$``</code>: 子串的左边文本。</li>
<li><code>$&#39;</code>: 子串的右边文本。</li>
<li><code>$$</code>: 美元符号本身。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>[^1]:Unicode 对其所有字符做了分类，这种分类用“通用类别值”表示，这里的“Mn”、“Mc”和“Pc”分别表示基字符的修改中出现的非间距字符、基字符的修改中影响了基字符标识位的宽度的间距字符、连接两个字符的连接符或标点符号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/XStream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/XStream/" itemprop="url">XStream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">作用目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>@XStreamAlias(&quot;label_name&quot;)</code></td>
<td style="text-align:left">别名注解</td>
<td style="text-align:left">作用目标: 类,字段</td>
</tr>
<tr>
<td style="text-align:left"><code>@XStreamImplicit</code></td>
<td style="text-align:left">隐式集合</td>
<td style="text-align:left">集合字段</td>
</tr>
<tr>
<td style="text-align:left"><code>@XStreamImplicit(itemFieldName=&quot;item_field_name&quot;)</code></td>
<td style="text-align:left">隐式集合，并指定集合内标签名</td>
<td style="text-align:left">集合字段</td>
</tr>
<tr>
<td style="text-align:left"><code>@XStreamConverter(SingleValueCalendarConverter.class)</code></td>
<td style="text-align:left">注入转换器</td>
<td style="text-align:left">对象</td>
</tr>
<tr>
<td style="text-align:left"><code>@XStreamAsAttribute</code></td>
<td style="text-align:left">设为该标签的属性</td>
<td style="text-align:left">字段</td>
</tr>
<tr>
<td style="text-align:left"><code>@XStreamOmitField</code></td>
<td style="text-align:left">忽略字段</td>
<td style="text-align:left">字段</td>
</tr>
<tr>
<td style="text-align:left"><code>xstream.autodetectAnnotations(true);</code></td>
<td style="text-align:left">自动侦查注解</td>
</tr>
</tbody>
</table>
<p><em>自动侦查注解与 <code>XStream.processAnnotations(Class[] cls)</code> 的区别在于性能.自动侦查注解将缓存所有类的类型.</em>  </p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/Java/XStream/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zeerho</p>
              <p class="site-description motion-element" itemprop="description">Just a repo for documents</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZephyrHuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zephyrhuang21@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeerho</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
