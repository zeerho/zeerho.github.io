<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Just a repo for documents">
<meta property="og:type" content="website">
<meta property="og:title" content="Tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="zeerho">
<meta property="og:description" content="Just a repo for documents">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-05T02:37:10.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tags">
<meta name="twitter:description" content="Just a repo for documents">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/"/>





  <title>zeerho</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zeerho</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/volatile/" itemprop="url">volatile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文内容摘取及参考自<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">此博客</a></em></p>
<h1 id="硬件层面的并发同步问题"><a href="#硬件层面的并发同步问题" class="headerlink" title="硬件层面的并发同步问题"></a>硬件层面的并发同步问题</h1><p>CPU 处理数据时，先将内存中的数据读取到高速缓存中，处理结束之后将高速缓存中的数据写回到内存中。</p>
<p>这种数据处理方式提高了速度，但会引起并发同步问题。即使是单核 CPU，也会以线程调度的形式表现出该问题。</p>
<p>为解决缓存不一致问题，通常有 2 种解决方法：</p>
<ul>
<li>在总线加 LOCK# 锁；</li>
<li>通过缓存一致性协议。</li>
</ul>
<p>在早期的 CPU 中，是通过在总线上加 LOCK# 锁的方式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。但是由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是 Intel 的 MESI 协议。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<hr>
<h1 id="并发编程涉及到的-3-个概念及-Java-提供的方案"><a href="#并发编程涉及到的-3-个概念及-Java-提供的方案" class="headerlink" title="并发编程涉及到的 3 个概念及 Java 提供的方案"></a>并发编程涉及到的 3 个概念及 Java 提供的方案</h1><p>在 Java 虚拟机规范中通过定义一种 Java 内存模型（Java Memory Model，JMM）试图来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。</p>
<p>注意，为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在 Java 内存模型中，也会存在缓存一致性问题和指令重排序的问题</strong>。</p>
<p>Java 内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h2><blockquote>
<p>原子性指的是操作的不可拆解性。具有原子性的操作要么全部执行，要么全部不执行，无法拆解开一步步地执行。</p>
</blockquote>
<p>在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。如果要实现更大范围操作的原子性，可以通过 <code>synchronized</code> 和 <code>Lock</code> 来实现。<br>在低版本 JDK 中，在 32 位平台下，对 64 位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的 JDK 中，JVM 已经保证对 64 位数据的读取和赋值也是原子性操作了。</p>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><blockquote>
<p>可见性指的是当多线程访问同一变量时，若某一线程更改了该变量，则其他线程能立即获知该变量已被修改，并去读取最新的值。</p>
</blockquote>
<p>对于可见性，Java 提供了 <code>volatile</code> 关键字来保证可见性。当一个共享变量被 <code>volatile</code> 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，会去主存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过 <code>synchronized</code> 和 <code>Lock</code> 也能够保证可见性，<code>synchronized</code> 和 <code>Lock</code> 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><blockquote>
<p>有序性指的是程序按照源代码的编写顺序执行。</p>
</blockquote>
<p>在 Java 内存模型中，允许编译器和处理器对指令进行重排序（Instruction Reorder），但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在 Java 里面，可以通过 volatile 关键字来保证一定的“有序性”。另外可以通过 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性，很显然，<code>synchronized</code> 和 <code>Lock</code> 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 “<strong>happens-before</strong>” 原则。如果两个操作的执行次序无法从“happens-before”原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p><strong>happens-before</strong> 原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。（这条实际上指的是编译器的指令重排一定不会影响单线程状态下的正确性，即对于单线程来说，程序就像是按照代码顺序执行的一样）</li>
<li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作</li>
<li>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</li>
<li>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始</li>
</ul>
<hr>
<h1 id="深入剖析-volatile"><a href="#深入剖析-volatile" class="headerlink" title="深入剖析 volatile"></a>深入剖析 volatile</h1><h2 id="volatile-的两层语义"><a href="#volatile-的两层语义" class="headerlink" title="volatile 的两层语义"></a>volatile 的两层语义</h2><ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ol>
<h2 id="volatile-是否保证原子性"><a href="#volatile-是否保证原子性" class="headerlink" title="volatile 是否保证原子性"></a>volatile 是否保证原子性</h2><p>volatile 不保证原子性。可用 synchronized、Lock、java.util.concurrent.atomic.* 来保证原子性</p>
<h2 id="volatile-是否保证可见性"><a href="#volatile-是否保证可见性" class="headerlink" title="volatile 是否保证可见性"></a>volatile 是否保证可见性</h2><ol>
<li>使用 volatile 关键字会强制将修改的值立即写入主存；</li>
<li>使用 volatile 关键字的话，当线程 2 修改某共享变量时，会导致线程 1 的工作内存中的该变量的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）；</li>
<li>由于线程 1 的工作内存中的缓存变量的缓存行无效，所以线程 1 再次读取变量的值时会去主存读取。</li>
</ol>
<h2 id="volatile-是否保证有序性"><a href="#volatile-是否保证有序性" class="headerlink" title="volatile 是否保证有序性"></a>volatile 是否保证有序性</h2><p>volatile 关键字禁止指令重排序有两层意思：</p>
<ol>
<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对 volatile 变量访问的语句前面的语句放在其后面执行，也不能把在对 volatile 变量访问的语句后面的语句放到其前面执行。</li>
</ol>
<h2 id="volatile-的原理和实现机制"><a href="#volatile-的原理和实现机制" class="headerlink" title="volatile 的原理和实现机制"></a>volatile 的原理和实现机制</h2><p>“观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令”——《深入理解Java虚拟机》</p>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：</p>
<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Effective Java 笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Effective Java 笔记/" itemprop="url">Effective Java 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><h2 id="1-考虑用静态工厂方法代替构造器"><a href="#1-考虑用静态工厂方法代替构造器" class="headerlink" title="1 考虑用静态工厂方法代替构造器"></a>1 考虑用静态工厂方法代替构造器</h2><ol>
<li>静态工厂方法可以自定义名称，这样可以根据方法名来区分不同的对象实例化入口。而构造器只能通过参数来区分，容易弄错。</li>
<li>静态工厂方法可以灵活地决定返回新对象还是单例。</li>
<li>静态工厂方法可以返回原返回类型的任何子类型。</li>
<li>静态工厂方法在创建参数化类型实例时可以利用编译器的类型推导特性来使代码更简洁（Java 8 中构造器也实现了这个特性）。</li>
</ol>
<p>静态工厂方法返回的对象所属的类，在编写该静态工厂方法时可以不必存在。这种灵活的静态工厂方法构成了<strong>服务提供者框架（Service Provider Framework）</strong>。</p>
<p><strong>服务提供者框架</strong></p>
<blockquote>
<p>多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。</p>
</blockquote>
<p>服务提供者框架中的三个重要组件和一个可选组件：</p>
<ul>
<li>服务接口（Service Interface）：由提供者实现；</li>
<li>提供者注册 API（Provider Registration API）：系统用来注册实现或提供者，让客户端访问它们；</li>
<li>服务访问 API（Service Access API）：客户端用来获取服务的实例；</li>
<li>服务提供者接口（Service Provider Interface）（可选）：这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</li>
</ul>
<p>服务访问 API 是“灵活的静态工厂”，它是服务提供者框架的基础。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务提供者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">newService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供服务注册和访问的类，本身不能被实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Services</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Services</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Provider&gt; providers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Provider&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"default"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供者注册接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDefaultProvider</span><span class="params">(Provider p)</span> </span>&#123;</span><br><span class="line">        registerProvider(DEFAULT_NAME, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(String name, Provider p)</span> </span>&#123;</span><br><span class="line">    providers.put(name, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务访问 API</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newInstance(DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">newInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Provider p = providers.get(name);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"blabla"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.newService();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-用私有构造器或者枚举类型强化-Singleton-属性"><a href="#3-用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="3 用私有构造器或者枚举类型强化 Singleton 属性"></a>3 用私有构造器或者枚举类型强化 Singleton 属性</h2><p>私有构造器只阻断了 new 的构造方式，除此之外还有两种对象实例化方式：</p>
<ul>
<li>反射</li>
<li>反序列化</li>
</ul>
<p>解决方法依次是：</p>
<ul>
<li>在私有构造器中抛出异常。</li>
<li>所有的实例域都加上<code>transient</code> 修饰；实现 <code>readResolve()</code> 方法，方法中直接返回已存在的单例。</li>
</ul>
<p>Java 5 开始的 enum 可以阻断上述三种实例化方式，这样构造单例就很简单。</p>
<h2 id="4-消除过期的对象引用"><a href="#4-消除过期的对象引用" class="headerlink" title="4 消除过期的对象引用"></a>4 消除过期的对象引用</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Apache 通用日志工具 commons-logging 和 Log4j 使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Apache 通用日志工具 commons-logging 和 Log4j 使用总结/" itemprop="url">Apache 通用日志工具 commons-logging 和 Log4j 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Apache 为了让众多日志工具有一个相同操作方法，制作了一个通用日志工具包 commons-logging。</strong></p>
<h1 id="Log4j-的架构"><a href="#Log4j-的架构" class="headerlink" title="Log4j 的架构"></a>Log4j 的架构</h1><p>Log4j三大板块：日志写入器、日志输出终端、日志布局模式。<br><img src="http://img1.51cto.com/attachment/200705/200705091178696293444.png" alt=""><br><code>Logger</code> 类是日志包的核心，<code>Lgger</code> 的名称大小写敏感，并且名称之间有继承关系——子名由父名做前缀，用点号“.”分隔。<br><code>Logger</code> 系统中有个根 <code>logger</code>，是所有 <code>logger</code> 的祖先，它总是存在，且不可通过名字获取，可以通过 <code>Logger.getRootLogger()</code> 获取。</p>
<p><strong><code>Logger</code> 对象获取方法，具体参考 API 文档</strong><br><code>static Logger getLogger(Class clazz)</code><br><em>Shorthand for getLogger(clazz.getName()).</em><br><code>static Logger getLogger(String name)</code><br><em>Retrieve a logger named according to the value of the name parameter.</em><br><code>static Logger getLogger(String name, LoggerFactory factory)</code><br><em>Like getLogger(String) except that the type of logger instantiated depends on the type returned by the LoggerFactory.makeNewLoggerInstance(java.lang.String) method of the factory parameter.</em><br><code>static Logger getRootLogger()</code><br><em>Return the root logger for the current logger rpository.</em><br>在某对象中，用该对象所属的类作为参数，调用<code>Logger.getLogger(Class clazz)</code>以获取<code>logger</code>对象被认为是目前所知最明智的命名<code>logger</code>方法。<br>用同名参数调用<code>Logger.getLogger(Class clazz)</code>将返回同一个<code>logger</code>对象。<code>Logger</code>的创建可以按照任意顺序，<code>log4j</code>将自动维护<code>logger</code>的继承树。</p>
<h1 id="Log4j的日志级别（Level）"><a href="#Log4j的日志级别（Level）" class="headerlink" title="Log4j的日志级别（Level）"></a>Log4j的日志级别（Level）</h1><p>每个<code>logger</code>都有一个日志级别，用来控制日志的输出。未分配级别的<code>logger</code>将自动继承它最近的父<code>logger</code>的日志级别。<br><strong><code>Logger</code>的级别由低到高：</strong><br><strong>ALL&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL&lt;OFF</strong><br>*<code>Logger</code>的级别越低，输出的日志越详细。</p>
<h1 id="Log4j的输出终端（Appender接口）"><a href="#Log4j的输出终端（Appender接口）" class="headerlink" title="Log4j的输出终端（Appender接口）"></a>Log4j的输出终端（Appender接口）</h1><p><code>Log4j</code>提供了以下几个实现：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天都产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小达到指定尺寸时产生一个新的日志文件，文件名称上会自动添加数字序号。）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流的格式发送到任意指定的地方）<br>默认情况下，子<code>logger</code>将继承父<code>logger</code>的所有<code>appenders</code>。<br><code>rootlogger</code>拥有目标为<code>system.out</code>的<code>consoleAppender</code>，故默认情况下，所有<code>logger</code>都将继承该<code>appender</code>。</li>
</ul>
<h1 id="Log4j的输出布局模式（Layout接口）"><a href="#Log4j的输出布局模式（Layout接口）" class="headerlink" title="Log4j的输出布局模式（Layout接口）"></a>Log4j的输出布局模式（Layout接口）</h1><p><code>Log4j</code>提供Layout有以下几种：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>
<li><p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）<br><code>Log4j</code>采用类似C语言中的printf函数的打印格式格式化日志信息。参数如下：</p>
</li>
<li><p><code>%m</code>：输出代码中指定的消息。</p>
</li>
<li><code>%p</code>：输出优先级。</li>
<li><code>%r</code>：输入自应用启动到输出该log信息耗费的毫秒数。</li>
<li><code>%c</code>：输出所属的类目，通常就是所在类的全名。</li>
<li><code>%t</code>：输出产生该日志线程的线程名。</li>
<li><code>%n</code>：输出一个回车换行符。Windows平台为“\r\n”，UNIX平台为“\n”。</li>
<li><code>%d</code>：输出日志时间点的日期或时间，默认格式为ISO8601，推荐使用“%d{ABSOLUTE}”，这个输出格式形如“2007-05-07 18:21:13,500”，符合中国人习惯。</li>
<li><code>%l</code>：输出日志事件发生的位置，包括类名、线程名，以及所在代码的行数。</li>
</ul>
<h1 id="Log4j的配置"><a href="#Log4j的配置" class="headerlink" title="Log4j的配置"></a>Log4j的配置</h1><p><code>Log4j</code>一般通过配置文件配置使用。配置文件有两种：Java properties和XML。一般选用properties文件来配置，因为简洁易读。<br>对<code>Log4j</code>的配置就是对<code>rootLogger</code>和子<code>Logger</code>的配置。主要的配置项为：<code>rootLogger</code>、输出终端、输出布局模式。<br>所有的配置项须以<code>log4j</code>开头。</p>
<p><strong>log4j.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> ##logger的配置###</span><br><span class="line"> # 配置根logger</span><br><span class="line">log4j.rootLogger=INFO,stdout</span><br><span class="line"> # 配置子logger:org.lavasoft（在org.lavasoft包中类的日志在没有指定logger名的情况下使用这个logger）</span><br><span class="line">log4j.logger:org.lavasoft=ERROR,file</span><br><span class="line"> # 配置子logger:org.lavasoft.test（在org.lavasoft.test包中类的日志在没有指定logger名的情况下使用这个logger）</span><br><span class="line">log4j.logger:org.lavasoft.test=ERROR,file1,stout</span><br><span class="line"></span><br><span class="line"> ## direct log message to stdout ###（标准的终端输出）</span><br><span class="line"> #控制台输出</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"> #自定义输出布局</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"> #输出的格式</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;;%L - %m%n</span><br><span class="line"></span><br><span class="line"> ## direct messages to file ttt.log ###（输入到文件ttt.log的配置）</span><br><span class="line"> #输出到滚动文件</span><br><span class="line">log4j.appender.file1=org.apache.log4j.RollingFileAppender</span><br><span class="line"> #输出文件最大为10M</span><br><span class="line">log4j.appender.file1.MaxFileSize=10MB</span><br><span class="line"> #输出文件最大序号为10</span><br><span class="line">log4j.appender.file1.MaxBackupIndex=10</span><br><span class="line"> #输出文件路径</span><br><span class="line">log4j.appender.file1.File=C:/ttt1.log</span><br><span class="line"> #自定义输出布局</span><br><span class="line">log4j.appender.file1.layout=org.apache.log4j.PatternLayout</span><br><span class="line"> #输出格式</span><br><span class="line">log4j.appender.file1.layout.ConversionPattern=%d %-5p [%t] (%13F:%L) %3x - %m%n</span><br></pre></td></tr></table></figure>
<p>logger的配置语法为：级别，输入终端1，输出终端2，……<br>根logger的配置项为：log4j.rootLogger<br>子logger的配置项为：log4j.logger.&lt;子logger名&gt;</p>
<h1 id="Log4j与通用日志包commons-logging的结合"><a href="#Log4j与通用日志包commons-logging的结合" class="headerlink" title="Log4j与通用日志包commons-logging的结合"></a>Log4j与通用日志包commons-logging的结合</h1><p>其实commons-logging中默认都支持Log4j，因此只要同时加载<code>commons-logging</code>包和<code>log4j</code>包，可以不用配置即可用在应用中使用<code>commons-logging</code>的接口方法。<br>当然，标准的应用的是需要的配置，如果你log4j则这个配置是可选的。下面我说明如何通过配置文件来组合commons-logging和log4j。</p>
<p>配置文件内容很简单，就指定一个日志实现类即可，下面是个示例文件：</p>
<p><strong>commons-logging.properties</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger</span><br></pre></td></tr></table></figure></p>
<p>在使用Log4j作为日志工具的时候，commons-logging.properties的配置可以不要.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/操作系统/DOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/操作系统/DOS/" itemprop="url">DOS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简单批处理命令"><a href="#简单批处理命令" class="headerlink" title="简单批处理命令"></a>简单批处理命令</h1><p><code>echo</code><br>:   <code>echo [{on|off}] [message]</code><br>打开/关闭回显功能，或显示消息。若没有参数，<code>echo</code>命令将显示当前回显设置。<br>在实际应用中会把<code>echo</code>和重定向符号（也称管道符号）结合来实现输入一些命令到特定的文件中。</p>
<p><code>rem</code> 和 <code>::</code><br>:   <code>rem message</code><br>注释命令。关闭回显时，<code>rem</code>和<code>::</code>及其后的内容都不会显示；打开回显时，<code>rem</code>及其后的内容会显示，而<code>::</code>不会。</p>
<p><code>pause</code><br>:   暂停命令。运行<code>pause</code>命令时，将显示<code>Press any key to continue...</code>或<code>请按任意键继续...</code>。</p>
<p><code>call</code><br>:   <code>call [[Drive:][Path]FileName] [:label [arguments]]</code><br>从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序。<code>call</code>命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。</p>
<p><code>start</code><br>:   调用外部程序，所有的 DOS 命令和命令行程序都可以由 start 命令来调用。<br>常用参数：</p>
<pre><code>- `MIN` 开始时窗口最小化。
- `SEPARATE` 在分开的空间内开始 16 位 Windows 程序。
- `HIGH` 在 HIGH 优先级类别开始应用程序。
- `REALTIME` 在 REALTIME 优先级类别开始应用程序。
- `WAIT` 启动应用程序并等候它结束。

执行的应用程序是 32 位 GUI 应用程序时，CMD.EXE 不等应用程序终止就返回命令提示。如果在命令脚本内执行，该新行为则不会发生。
</code></pre><p><code>goto</code><br>:   <code>goto label</code><br><code>:LABEL</code> 表示一个标签<br>跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。</p>
<p><code>set</code><br>:  显示、设置或删除临时变量（仅在当前命令行窗口有效）。</p>
<pre><code>- 显示变量：`set`或`set s`，前者显示批处理当前已定义的所有变量及其值，后者显示所有以s开头的变量及值。
- 设值变量：`set a=abc`向变量a赋值abc。若变量a已被定义，则a的值被修改为abc；若变量a未定义，则此命令定义新的变量a，同时赋初始值abc。
- 删除变量：`set a= `此命令可删除变量a。若变量a已被定义，则删除变量a；若a未定义，则此命令无实际意义。

批处理中的变量不区分类型。
</code></pre><p><code>set</code>命令具有扩展功能，如用作交互输入、字符串处理、数值计算等，属于高级命令范畴。</p>
<p><code>setx [/m] {key} {value}</code> 设置非临时变量。默认是用户环境变量，<code>/m</code> 表示系统环境变量。</p>
<h1 id="批处理符号"><a href="#批处理符号" class="headerlink" title="批处理符号"></a>批处理符号</h1><p><code>@</code><br>:   回显屏蔽，不显示<code>@</code>后面的命令。</p>
<p><code>&gt;</code> 与 <code>&gt;&gt;</code><br>:   将输出信息重定向到指定的设备或文件。系统默认输出到显示器。<br><code>echo abc&gt;a.txt</code>将本在显示器上显示的消息abc输出到文件a.txt中，屏幕上无显示。若文件a.txt已存在，则将擦除其内容并写入消息abc；若a.txt不存在，则将新建一个a.txt文件并写入消息abc。<br><code>echo abc&gt;&gt;a.txt</code>若a.txt已存在，则不会擦除原有内容而是在文件末尾添加消息abc；若a.txt不存在，则同上。</p>
<p><code>&lt;</code><br>:   将输入信息来源重定向为指定的设备或文件。系统默认从显示器读取输入信息。</p>
<p><code>|</code><br>:   将管道符号<code>|</code>前面的命令的输出结果重定向输出到管道符号后面的命令中去，作为后面命令的输入。</p>
<p><code>^</code><br>:   转义符<code>^</code>将特殊符号转化为一般符号。特殊符号指：<code>|</code> <code>&amp;</code> <code>&gt;</code> <code>&lt;</code>。</p>
<p><code>&amp;</code> <code>&amp;&amp;</code> <code>||</code><br>:   逻辑命令符：<br><code>&amp;</code>:用来连接n个DOS命令，并把这些命令按顺序执行，不管是否有命令执行失败。<br><code>&amp;&amp;</code>:当<code>&amp;&amp;</code>前面的命令成功执行时，才执行后面的命令，否则不执行。<br><code>||</code>:当<code>||</code>前面的命令失败时，执行<code>||</code>后面的命令，否则不执行。<br><em><code>&amp;&amp;</code>和<code>||</code>实际上是通过判断errorlevel来实现的</em></p>
<h1 id="常用-DOS-命令"><a href="#常用-DOS-命令" class="headerlink" title="常用 DOS 命令"></a>常用 DOS 命令</h1><h2 id="文件夹管理"><a href="#文件夹管理" class="headerlink" title="文件夹管理"></a>文件夹管理</h2><ul>
<li><code>cd</code>：显示当前目录名或改变当前目录。</li>
<li><code>md</code>：创建目录。</li>
<li><code>rd</code>：删除一个目录。</li>
<li><code>dir</code>：显示目录中的文件和子目录列表。</li>
<li><code>tree</code>：以图形的形式显示驱动器或路径的文件夹结构。</li>
<li><code>path</code>：为可执行文件显示或设置一个搜索路径。</li>
<li><code>copy</code>：复制文件和目录树。</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul>
<li><code>type</code>：显示文本文件的内容。</li>
<li><code>copy</code>：将一份或多份文件复制到另一个位置。</li>
<li><code>del</code>：删除一个或数个文件。</li>
<li><code>move</code>：移动文件并重命名文件和目录。（Windows XP Home Edition中没有）。</li>
<li><code>ren</code>：重命名文件。</li>
<li><code>replace</code>：替换文件。</li>
<li><code>attrib</code>：显示或更改文件属性。</li>
<li><code>find</code>：搜索字符串。</li>
<li><code>fc</code>：比较两个文件或两个文件集并显示它们之间的不同。</li>
</ul>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><ul>
<li><code>ping</code>：进行网络连接测试、名称解析。</li>
<li><code>ftp</code>：文件传输。</li>
<li><code>net</code>：网络命令集及用户管理。<ul>
<li><code>net start|stop {service}</code> 启动/停止服务</li>
</ul>
</li>
<li><code>telnet</code>：远程登陆。</li>
<li><code>ipconfig</code>：显示、修改TCP/IP设置。</li>
<li><code>msg</code>：给用户发送消息。</li>
<li><code>arp</code>：显示、修改局域网的IP地址-物理地址映射列表。</li>
</ul>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ul>
<li><code>at</code>：安排在特定日期和时间运行命令和程序。</li>
<li><code>shutdown</code>：立即或定时关机或重启。</li>
<li><code>tskill</code>：结束进程。</li>
<li><code>taskkill</code>：结束进程（比<code>tskill</code>高级，但Win XP Home版中无该命令。</li>
<li><code>tasklist</code>：显示进程列表（Windows XP Home Edition中没有）。</li>
<li><code>sc</code>：系统服务设置与控制。<ul>
<li><code>sc config {service} start=demand|auto|disabled</code> 手动/自动/禁用</li>
<li><code>sc start|stop {service}</code> 启动/停止服务</li>
</ul>
</li>
<li><code>reg</code>：注册表控制台工具。 </li>
<li><code>powercfg</code>：控制系统上的电源设置。</li>
</ul>
<p>对于以上列出的所有命令，在cmd中输入<code>命令/？</code>即可查看该命令的帮助信息。</p>
<h1 id="语句结构"><a href="#语句结构" class="headerlink" title="语句结构"></a>语句结构</h1><h2 id="if语句（选择结构）"><a href="#if语句（选择结构）" class="headerlink" title="if语句（选择结构）"></a>if语句（选择结构）</h2><ol>
<li>字符串比较<br>if语句只能对两个字符（串）是否相同、先后顺序进行判断等。命令格式：<br><code>IF [/i] [not] string1 compare-op string2 command1 [else command2]</code><br>选择开关 <code>/i</code> 则不区分字符串大小写；选择 <code>not</code> 项，则对判断结果进行逻辑非。<br>其中，比较操作符 compare-op 有以下几类：</li>
</ol>
<ul>
<li><code>==</code> 等于</li>
<li><code>EQU</code> 等于</li>
<li><code>NEQ</code> 不等于</li>
<li><code>LSS</code> 小于</li>
<li><code>LEQ</code> 小于或等于</li>
<li><code>GTR</code> 大于</li>
<li><code>GEQ</code> 大于或等于</li>
</ul>
<ol>
<li>存在判断<br>判断文件或文件夹是否存在。命令格式：<br><code>IF [NOT] EXIST filename command1 [else command2]</code></li>
</ol>
<ul>
<li>存在判断既可以判断文件也可以判断文件夹；</li>
<li><code>%0</code>代表当前批处理的全称（包括驱动器盘符、路径、文件名和扩展类型）；</li>
<li><code>%~df0</code>是对<code>%0</code>的修正，只保留了其驱动器盘符和路径，详情参考<code>for /?</code>；</li>
<li>if语句的多行书写要求<code>command1</code>的左括号必须和<code>if</code>在同一行、<code>else</code>必须和<code>command1</code>的右括号同行、<code>command2</code>的左括号必须与<code>else</code>同行、<code>command1</code>和<code>command2</code>都可以任意多行，即<code>command</code>可以是命令集。</li>
</ul>
<ol>
<li><p>定义判断<br>判断变量的是否存在，即是否已被定义。命令格式：<br><code>IF [NOT] DEFINED variable command1 [else command2]</code></p>
</li>
<li><p>结果判断<br>判断命令执行后的返回码。命令格式：<br><code>IF [NOT] errorlevel n command]</code><br>DOS程序在运行完成后都有返回码（也叫错误码），如果和命令中定义的返回码<code>n</code>相符，则执行<code>command</code>。</p>
</li>
</ol>
<h2 id="for语句（循环结构）"><a href="#for语句（循环结构）" class="headerlink" title="for语句（循环结构）"></a>for语句（循环结构）</h2><p>for语句有多个开关，不同开关将会实现不同功能。</p>
<ol>
<li><p>无开关<br>无开关的for语句能够在设定的范围内进行循环。命令格式：<br><code>FOR %%variable IN (set) DO command</code><br>其中，<code>%%variable</code>是批处理程序中的书写格式，在DOS中书写为<code>%variable</code>；<code>set</code>是需要设定的循环范围（变量集合）；<code>do</code>后面的<code>command</code>是循环所执行的命令，即循环体。</p>
</li>
<li><p>开关<code>/L</code><br>根据<code>set</code>里面的设置进行循环，从而实现对循环次数的直接控制。命令格式：<br><code>FOR /L %%variable IN (start,step,end) DO command</code><br>其中，<code>start</code>为开始计数的初始值，<code>step</code>为每次递增的值，<code>end</code>为结束值。当<code>end</code>小于<code>start</code>时，<code>step</code>需要设置为负数。<code>%%i</code>的结束值有可能不是<code>end</code>而是不大于<code>end</code>的一个数。</p>
</li>
<li><p>开关<code>/F</code><br>能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的ASCII码文件，比如txt文档等。命令格式：<br><code>FOR /F [&quot;options&quot;] %%variable IN (set) DO command</code><br>其中，<code>set</code>为<code>&quot;String&quot;</code>、<code>&#39;command&#39;</code>、<code>file-set</code>中的一个；<code>options</code>是<code>eol=c</code>、<code>skip=n</code>、<code>delims=xxx</code>、<code>tokens=x,y,m-n</code>、<code>usebackq</code>中的一个或多个的组合。各选项的意义参见<code>for /f</code>。</p>
</li>
<li><p>开关<code>/D</code>或<code>/R</code><br>含开关<code>/D</code>或<code>/R</code>的for语句是与目录或文件有关的命令，有时被用于通过遍历文件夹来查找一个文件或文件夹。</p>
</li>
<li><p>其他<br>在for循环中，当一个变量被多次赋值时，<code>%dd%</code>所获取的仅仅是<code>dd</code>第一次被赋予的值。要想刷新<code>dd</code>的值，就必须先通过命令<code>setlocal enabledelayedexpansion</code>来开启延迟变量开关，然后用<code>!dd!</code>来获取<code>dd</code>的值。</p>
</li>
</ol>
<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><ol>
<li><p>截取字符串<br><code>%var:~m,n%</code> 截取第m+1到n+1个字符<br><code>%var:~m</code> 截取第1到第m+1个字符<br>其中表示下标的<code>m</code> <code>n</code>可为负数。<br><strong>替换操作不会直接改变被操作的字符串，若要使生效变动，需再次对被操作字符串赋值。</strong></p>
</li>
<li><p>替换字符串<br><code>%var:src_part=des_part%</code><br><strong>替换操作不会直接改变被操作的字符串，若要使生效变动，需再次对被操作字符串赋值。</strong></p>
</li>
<li><p>合并字符串<br><code>%str1%%str2%</code><br>只需直接将字符串放在一起。</p>
</li>
<li><p>扩充字符串<br>对表示文件路径的字符串进行特殊处理。<br><code>~I</code> 删除任何引号（”），扩充<code>%I</code><br><code>%~fI</code> 将<code>%I</code>扩充到一个完全合格的路径名<br><code>%~dI</code> 仅将<code>%I</code>扩充到一个驱动器号<br><code>%~pI</code> 仅将<code>%I</code>扩充到一个路径<br><code>%~nI</code> 仅将<code>%I</code>扩充到一个文件名<br><code>%~xI</code> 仅将<code>%I</code>扩充到一个文件扩展名<br><code>%~sI</code> 扩充的路径只含有短名<br><code>%~aI</code> 将<code>%I</code>扩充到文件的文件属性<br><code>%~tI</code> 将<code>%I</code>扩充到文件的日期/时间<br><code>%~zI</code> 将<code>%I</code>扩充到文件的大小<br><code>%~$PATH:I</code> 查找被列在路径环境变量PATH中的目录，并将<code>%I</code>扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串<br>可以组合修饰符来得到多重结果：<br><code>%~dpI</code> 仅将<code>%I</code>扩充到一个驱动器号和路径<br><code>%~nxI</code> 仅将<code>%I</code>扩充到一个文件名和扩展名<br><code>%~fsI</code> 仅将<code>%I</code>扩充到一个带有短名的完整路径名<br><code>%~dp$PATH:i</code> 查找被列在路径环境变量PATH中的目录，并将<code>%I</code>扩充到找到的第一个驱动器号和路径。<br><code>%~ftzaI</code> 将<code>%I</code>扩充到类似输出线路的DIR<br>以上<code>I</code>代表一个变量，该被扩充的变量需满足两个条件：</p>
</li>
</ol>
<ul>
<li>该字符串代表一个文件路径。</li>
<li>变量要用<code>%x</code>来表示，<code>x</code>可取<code>a-z A-Z 0-9</code>供62个字符中的任意一个。</li>
</ul>
<h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><p>批处理只能进行整型计算，忽略浮点数的小数部分；同时数值计算的范围也受限于系统位数。命令格式：<br><code>set /a expression</code><br><code>set</code>支持的运算符跟C语言中的一样，只是没有增一减一。<br><code>set</code>支持的运算符及优先级排序：<br><code>()</code> 分组<br><code>!~-</code>一元运算符（逻辑非、按位非、取负）<br><code>*/%</code> 算数运算符（乘、取商、取余）<br><code>+-</code> 算数运算符（加、减）<br><code>&lt;&lt;&gt;&gt;</code> 逻辑移位（左移一位、右移一位）<br><code>&amp;</code> 按位与<br><code>^</code> 按位异<br><code>|</code> 按位或<br><code>= *= /= %= += -=</code> 赋值<br><code>&amp;= ^= |= &lt;&lt;= &gt;&gt;= ,</code> 表达式分隔符（<code>set</code>可一次处理多个表达式）<br><code>set /a</code>中，直接用变量名即可取得变量的值；<code>set</code>支持八进制（数字前缀0）、十进制（数字无前缀）和十六进制（数字前缀0x），且支持不同进制之间的计算，计算及显示结果为十进制。</p>
<h1 id="批处理概念方法"><a href="#批处理概念方法" class="headerlink" title="批处理概念方法"></a>批处理概念方法</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>系统变量由操作系统事先定义好，适用于任何批处理。要查看所有系统变量，可以在cmd窗口中输入<code>set</code>。<br>几个常用的系统变量：<br><code>ComputerName</code> 计算机名，即右键-我的电脑-属性-计算机名-选项卡中的“完整的计算机名称”<br><code>ComSpec</code> cmd.exe的完整路径名<br><code>HomeDrive</code> 系统分区盘符<br><code>Path</code> 可执行文件的默认搜索路径<br><code>ProgramFiles</code> 系统的Program Files的路径<br><code>Prompt</code> 返回当前解释程序的命令提示符设置，由 Cmd.exe 生成<br><code>SystemDrive</code> 包含系统根目录的分区<br><code>SystemRoot</code> 系统根目录路径<br><code>Temp</code> <code>Tmp</code> 临时文件的存放目录<br><code>UserName</code> 当前用户名<br><code>UserProfile</code> 当前用户的配置目录<br><code>WinDir</code> 操作系统路径</p>
<h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>用户变量由 <code>set</code> 命令定义，可参考 <code>set /?</code>。<br><strong>变量引用</strong><br>一般情况下可以直接用变量名操作变量，通过<code>%var%</code>或<code>!var!</code>来获取变量的值。其中，只有在for语句里面重复对同一变量多次赋值时才需要使用<code>!var!</code>，并且在使用<code>!var!</code>调用变量时，要首先“启用延迟环境变量扩充”，<code>setlocal enabledelayedexpansion</code>。启用延迟环境变量扩充后，所有的<code>!</code>都将被视为“取变量值”的特殊符号，即使用<code>^!</code>也不能输出符号“!”。若要输出“!”，需要停用延迟环境变量扩充，<code>setlocal disabledelayedexpansion</code>。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol>
<li><p>直接传递<br>在使用<code>call</code>命令时，不使用任何参数，在子函数或子批处理里面直接对主函数（也称父批处理）里面的变量进行修改。</p>
</li>
<li><p>间接传递<br>在使用<code>call</code>命令时，在其后面添加参数，形如<code>call {[:label][ChildBatch]} Parameter1 Parameter2 ... ParameterN</code>。参数在子函数或子批处理里面是以%1~%9的形式表示的。 </p>
</li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>有些命令在执行之后将会返回一定的错误值（errorlevel），可以通过errorlevel的值判断命令执行状况。获取返回值errorlevel的方法是，在执行命令后立马调用返回值errorlevel。<br><em><code>if errorlevel 0</code>和<code>if %errorlevel%==0</code>是一样的。</em></p>
<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><ol>
<li><p>视窗</p>
<ol>
<li>设置窗口背景色和字体颜色。详见<code>color /?</code>。</li>
<li>设置窗口大小，<code>mode con [cols=c] [lines=n]</code>，cols即宽度，lines即高度。</li>
<li>GUI交互窗口。详见<code>msg /?</code>。</li>
</ol>
</li>
<li><p>声音<br>调用vbs的方法：<br><code>vbscript:createobject(&quot;sapi.spvoice&quot;).speak(&quot;Here are the words to say.&quot;)</code><br>其中spvoice是支持语音合成（TTS）的核心类。</p>
</li>
<li><p>控制</p>
<ol>
<li>暂停批处理：按下键盘上的Pause键。</li>
<li>终止批处理：组合键Ctrl+C。</li>
</ol>
</li>
</ol>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>暂略。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/电脑相关/硬件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/电脑相关/硬件/" itemprop="url">硬件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h1><p>基本参数：</p>
<ul>
<li><strong>磁头 head</strong>：用来读写数据的探针，每个磁头对应一个盘面。现代硬盘的磁盘通常是双面读写，故磁头数量通常为磁盘数量的两倍。</li>
<li><strong>磁道 track</strong>：同一盘面上位于同一半径处的同心圆磁轨。</li>
<li><strong>柱面 cylinder</strong>：所有盘面上半径相同的磁道的统称。</li>
<li><strong>扇区 sector</strong>：数据存储的基本单位。老式硬盘每个扇区对应的圆心角相等，新式硬盘为节约磁盘空间，改为每个扇区对应的圆周长度相等。 </li>
<li><strong>分配单元（旧称“簇”）</strong>：DOS 系统存储文件的基本逻辑单位，为扇区的整数倍，因存储介质的不同、存储介质容量的不同、分区格式的不同而不同。</li>
</ul>
<p>分区</p>
<ul>
<li>MBR（Master Boot Record）分区表格式<ul>
<li>磁盘的第1个扇区保存两个数据<ul>
<li><strong>主要启动记录区（MBR）</strong>：可以安装开机管理程序的地方</li>
<li><strong>分区表（partition table）</strong>：记录整个硬盘的分区状态</li>
</ul>
</li>
<li>磁盘的第1个扇区中的分区表将磁盘分为<strong>主要（Primary）分区</strong>和<strong>扩展（Extended）分区</strong>，扩展分区的数量为{0,1}</li>
<li>扩展分区的第1个扇区中的分区表将扩展分区分为若干<strong>逻辑（Logical）分区</strong>（此项可选）</li>
</ul>
</li>
<li>GPT（GUID partition table）分区表格式<ul>
<li>为了兼容 512Bytes 和 4K 的扇区，改用<strong>逻辑区块地址（Logical Block Address，LBA）</strong>来定义扇区<ul>
<li>LBA0（MBR 兼容区块）：分为两个部分。第一部分储存开机管理程序，第二部分放入一个特殊标志，表示此磁盘为 GPT 分区格式。</li>
<li>LBA1（GPT 表头记录）：记录了分区表本身的位置和大小，同时记录了备份用的 GPT 分区的位置，并放置了分区表的校验机制码（CRC32）</li>
<li>LBA2-33（实际记录分区信息处）：每个 LBA 可以记录 4 个分区记录，每个分区最大 8ZB，最多可有 128 个分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h1><h2 id="怎样延长使用寿命："><a href="#怎样延长使用寿命：" class="headerlink" title="怎样延长使用寿命："></a>怎样延长使用寿命：</h2><ol>
<li>确保硬盘读写模式是AHCI。<br>在AHCI 1.0规范中，Intel引入了NCQ（Native Command Queuing）功能。支持NCQ技术的硬盘在接到读写指令后，会根据指令对访问地址进行重新排序，减少了读取时间，使数据传输更为高效，同时也有效地延长了硬盘的使用寿命。</li>
<li>确保你的电脑开启了TRIM。<br>一般来说，WIN7以上操作系统都是默认开启的，那如何确认呢？只需要在命令提示符（管理员模式）内输入这串命令：fsutil behavior query DisableDeleteNotify<br>如果反馈的结果是0，证明是开启了；如果反馈的结果是1，那就代表没有开启，可能就是你的系统出了问题，最好更新下补丁或者重新安装下。顺便提一句，XP系统不支持TRIM哦，所以还是再建议一下：XP系统用SSD比较奢侈。</li>
<li>确保4K对齐。<br>这个名词，想象大家都很熟悉了~根据测算，4K没有对齐的情况下，SSD的效率会损失一半，寿命也大大减少，所以这是一个非常重要的设置。至于方法，很简单了！只需要用正版的系统镜像安装系统，系统安装过程一定会把4K对齐的！</li>
<li>关闭Windows Search服务和Superfetch服务。<br>这两项服务更适合速度较慢的机型硬盘，在我们不需要进行搜索或者运行程序的时候，它就已经做了一些“预备工作”，以便我们实际工作时可以更快的响应，而对于SSD来说，完全没有必要，反而增加读写次数，因此还是关掉为好。<br>方法如下：<ol>
<li>运行Services.msc回车</li>
<li>找到Windows Search和SuperFetch选项，右键单击属性</li>
<li>将其停止</li>
</ol>
</li>
</ol>
<h2 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h2><ol>
<li>主控<br>推荐浦科特、闪迪</li>
<li>闪存<br>优选MLC。SLC贵，TLC速度略慢寿命略短（相对而言）。<br>自家生产：Intel、美光、三星、海力士、东芝、闪迪。<br>使用他家原厂：浦科特、建兴、海盗船等等。</li>
<li>固件<br>固件影响效率。具备自主研发固件的厂商：Intel、英睿达、浦科特、OCZ、三星等。</li>
<li>缓存<br>缓存延长寿命，略提高TLC的速度。缓存不必须，若有则越大越好。</li>
<li>性能<br>4k随机读写速度（4k IOPS）</li>
<li>断电保护</li>
<li>功耗</li>
<li>售后</li>
</ol>
<h2 id="硬盘相关知识科普"><a href="#硬盘相关知识科普" class="headerlink" title="硬盘相关知识科普"></a>硬盘相关知识科普</h2><p><strong>什么是簇？</strong><br>　　最开始从WIN98一直到WIN XP，都是机械硬盘的天下，容量有限。而且绝大多数机械硬盘默认扇区都是512K大小。分区的时候有一个东西叫做物理存储单元，俗称簇。分区的时候可以指定这个大小。这个簇不是硬盘的物理结构，而是使用方法。<br>　　这个簇很有意思，一个簇只能容纳一个文件，但是一个簇可以包含多个扇区，当时流行小簇，因为小簇不“浪费”磁盘。 打个比方，比如我的簇是10K，文件是25K，我需要保存这个文件需要占用3个簇;那如果簇是5K，那么我想保存该数据，需要使用5个磁盘扇区单元。显得磁盘利用率更高。<br>　　那这么看来，是不是簇越小越好呢?不是!因为一个簇是一个磁盘最小的管理存储单元，如果一个文件读了4个单元和400个单元，你觉得哪个更快呢? 而且目前大容量硬盘已经不在乎那几K了，簇这个东西没必要太小。 </p>
<p><strong>簇和扇区有什么区别？</strong><br>　　簇和扇区不是属于一个范畴。簇是系统在硬盘上读写文件时的单位，是一个数据块。而扇区是硬盘划分的最小单位值，就是簇（数据块）占用的地方。<br>　　簇的大小大于扇区的大小。硬盘每簇的扇区数与硬盘的总容量大小有关。扇区是存储介质上可由硬件寻址的基本单位，x86系统几乎总是定义512字节的扇区大小；簇是许多文件系统格式使用的可寻址数据块，簇的大小总是扇区大小的整数倍，且不同文件系统对于不同大小的卷（分区）会有不同的默认簇大小，比如FAT32对于8GB以下的分区，默认簇大小为4KB，对于8GB～16GB的分区，默认簇大小为16个扇区（8KB），NTFS对于大于2GB的分区，默认簇大小为8个扇区（4KB）。<br>　　打个比方，你（系统）要在仓库（仓库可视为硬盘）里存放一些书（数据）。你先把书分门别类放到一些大纸箱（簇）里，然后放进仓库，纸箱的体积是根据你仓库大小来决定的，而仓库始终划分成单位为0.1m?的小格子（扇区），仓库大了，纸箱就大些，仓库小了，纸箱就小些。</p>
<p><strong>存储器中说的块、页、簇、扇区对应的关系是什么？</strong><br>　　简单的说，就是块可以包含若干页，页可以包含若干簇，簇可以包含若干扇区。这里“若干”一般是二的方次。例如：一簇等于128扇区，一页等于64簇，一块等于4页，那么一块就等于4x64x128扇区。</p>
<p><strong>什么是4K?</strong><br>　　绝大多数的机械硬盘默认是512字节的扇区，采用的是DRAM作为存储介质; 而机械硬盘，无论是SLC颗粒还是MLC颗粒，都属于NAND闪存存储单元。 这种硬盘的扇区是4K，这就是4K的由来!<br>　　由于win98和win xp大多数采用FAT格式。 这种格式具备32位、16位磁盘格式相互兼容所以被大多数朋友采纳作为系统盘。 但是到了Vista时代，已经不需要16位的DOS了，所以全部采用了纯32位的NTFS格式，NTFS格式也升级到了第五代。 其实XP时代就有NTFS，虽然这种格式性能更高更安全，但是兼容性差，所以一直不作为系统分区，一般作为存储分区。<br>　　NTFS格式有一个特性，那就是起始簇的位置!<br>　　NTFS分区起始位置不是从0开始，而是从LBA63开始，就是第六十三个扇区开始开始存储。<br>　　而且NFTS默认认为扇区是512字节大小，而不是智能调节到第六十三个扇区。<br>　　这样问题就来了，63个扇区×512字节=31.5K，也就是说，磁盘的前31.5K是不能被使用的。<br>　　使用机械硬盘就算了，使用固态硬盘，存储第一个字，也需要占用31.5K-35.5K之间的磁盘扇区。<br>　　最过分的是这样子排列下去，恰好每到一个扇区的4K位置，就会造成一个数据存2个扇区的情况。<br>　　而且这样排列，只要到了那个能被4K整除的位置就100%占用了2个扇区，哪怕只写一个字。<br>　　固态硬盘无论是MLC还是SLC，都是有写入读取次数的，这样极大的损伤了性能和寿命。 而且，增加了读取次数。 这个时候无论簇是多大，都会造成性能和空间的浪费。<br>　　所以这个问题就叫做4K! </p>
<p><strong>什么是4K对齐？</strong>　　<br>　　硬盘分区的时候有一个东西叫做物理存储单元，俗称簇。分区的时候可以指定这个大小。这个簇不是硬盘的物理结构，而是使用方法。随着时代发展，硬盘容量不断扩展，使得之前定义的每个扇区512字节不再是那么的合理，于是将每个扇区512字节改为每个扇区4096 个字节，也就是现在常说的“4K扇区”。随着NTFS成为了标准的硬盘文件系统，其文件系统的默认分配单元大小（簇）也是4096字节，为了使簇与扇区相对应，即使物理硬盘分区与计算机使用的逻辑分区对齐，保证硬盘读写效率，所以，有了“4K对齐”的概念。　　传统硬盘的每个扇区固定是512字节，新标准的”4K扇区”的硬盘，硬盘厂商为了保证与操作系统兼容性，也将扇区模拟成512B扇区，这时就会有4K扇区和4K簇不对齐的情况发生。所以就要用“4K对齐的方式，将硬盘模拟扇区对齐成“4k扇区”。“4K对齐”就是将硬盘扇区对齐到8的整数倍个模拟扇区，即512Bx8=4096B，4096字节即是4K。所以只要是8的倍数都是4K对齐了。</p>
<h1 id="芯片组"><a href="#芯片组" class="headerlink" title="芯片组"></a>芯片组</h1><p>芯片组是一块主板的核心，是主板南桥北桥的统称，决定了主板的绝大部分特性。</p>
<p>Intel 目前的芯片组从低到高分为 H、B、Q、Z、X 系列。</p>
<ul>
<li>H：低端入门，适合奔腾、赛扬、i3 系列。</li>
<li>B：中端，适合不带 K 的 i5、i7 系列。</li>
<li>Q：嵌入式或工控主板。</li>
<li>Z：带 K 处理器超频。</li>
<li>X：高端至尊处理器，如 i9、至尊 i7。</li>
</ul>
<p>AMD 目前的芯片组从低到高分为 A、B、X 系列，以及仅支持 Threadripper 的 X399 芯片组。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/字符集和编码/字符集和编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/字符集和编码/字符集和编码/" itemprop="url">字符集和编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="一些主要编码的区别"><a href="#一些主要编码的区别" class="headerlink" title="一些主要编码的区别"></a>一些主要编码的区别</h1><p>摘自 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">developerWorks-深入分析 Java 中的中文编码问题</a></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/字符集和编码/字符集和编码/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/工具/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/工具/Maven/" itemprop="url">Maven</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Maven 是一个项目管理工具，包含：</p>
<ul>
<li>一个项目对象模型（Project Object Model）</li>
<li>一组标准集合</li>
<li>一个项目生命周期（Project Lifecycle）</li>
<li>一个依赖管理系统（Dependency Management System）</li>
<li>用来运行定义在生命周期阶段（phase）中插件目标（goal）的逻辑</li>
</ul>
<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ul>
<li><code>mvn install:install-file  -Dfile=D:/xxx.jar  -DgroupId=xxx.xxx  -DartifactId=xxx -Dversion=x.x -Dpackaging=jar</code> 将指定 jar 包安装至本地库</li>
</ul>
<p>若要使打包得到的 .jar 中包含 main 方法（即为可执行 .jar），需要借助 <code>maven-shade-plugin</code>，配置该插件如下：</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/工具/Maven/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Java 8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Java 8/" itemprop="url">Java 8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Lamda"><a href="#Lamda" class="headerlink" title="Lamda"></a>Lamda</h1>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/Java/Java 8/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Java Web Services/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Java Web Services/" itemprop="url">Java Web Services</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-基于-SOAP-的-Web-服务"><a href="#1-基于-SOAP-的-Web-服务" class="headerlink" title="1. 基于 SOAP 的 Web 服务"></a>1. 基于 SOAP 的 Web 服务</h1><h2 id="1-1-TimeServer-的服务端点接口（SEI，Service-Endpoint-Interface）"><a href="#1-1-TimeServer-的服务端点接口（SEI，Service-Endpoint-Interface）" class="headerlink" title="1.1 TimeServer 的服务端点接口（SEI，Service Endpoint Interface）"></a>1.1 TimeServer 的服务端点接口（SEI，Service Endpoint Interface）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01.ts; <span class="comment">//time server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebMethod;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding.Style;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="meta">@SOAPBinding</span>(style=Style.RPC)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeServer</span></span>&#123;</span><br><span class="line">    <span class="meta">@WebMethod</span> <span class="function">String <span class="title">getTimeAsString</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@WebMethod</span> <span class="function"><span class="keyword">long</span> <span class="title">getTimeAsElapsed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-TimeServer-服务实现-Bean（SIB，Service-Implementation-Bean）-new-Date"><a href="#1-2-TimeServer-服务实现-Bean（SIB，Service-Implementation-Bean）-new-Date" class="headerlink" title="1.2 TimeServer 服务实现 Bean（SIB，Service Implementation Bean）[^new Date()]"></a>1.2 TimeServer 服务实现 Bean（SIB，Service Implementation Bean）[^new Date()]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01.ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span>(endpointInterface=<span class="string">"ch01.ts.TimeServer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerImpl</span> <span class="keyword">implements</span> <span class="title">TimeServer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTimeAsString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date().toString();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeAsElapsed</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date().getTime(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-将-Java-程序发布为-Web-服务"><a href="#1-3-将-Java-程序发布为-Web-服务" class="headerlink" title="1.3 将 Java 程序发布为 Web 服务"></a>1.3 将 Java 程序发布为 Web 服务</h2><p>Web 服务可以发布到独立的 Java 应用服务器中，也可以如下简单地为其提供一个 Web 服务发布程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01.ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerPublisher</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Endpoint.publish(<span class="string">"http://127.0.0.1:9876/ts"</span>,<span class="keyword">new</span> TimeServerImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样发布的服务同一时刻只能处理一个客户端服务请求。</p>
<p><span id="return1"></span></p>
<h2 id="1-4-通过浏览器测试-Web-服务"><a href="#1-4-通过浏览器测试-Web-服务" class="headerlink" title="1.4 通过浏览器测试 Web 服务"></a>1.4 通过浏览器测试 Web 服务</h2><p>通过浏览器查看由发布程序自动产生的服务契约 WSDL（Web Services Description Language）文档。访问地址 <code>http://127.0.0.1:9876/ts?wsdl</code>。详细报文见<a href="#wsdl">这里</a>。</p>
<h2 id="1-5-传输SOAP消息时HTTP请求的内容结构"><a href="#1-5-传输SOAP消息时HTTP请求的内容结构" class="headerlink" title="1.5 传输SOAP消息时HTTP请求的内容结构"></a>1.5 传输SOAP消息时HTTP请求的内容结构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST http://127.0.0.1:9876/ts HTTP/ 1.1</span><br><span class="line">Accept:text/xml</span><br><span class="line">Accept:multipart/*</span><br><span class="line">Accept:application/soap</span><br><span class="line">User-Agent:SOAP::Lite/Perl/0.69</span><br><span class="line">Content-Length:434</span><br><span class="line">Content-Type:text/xml;charset=utf-8</span><br><span class="line">SOAPAction:""</span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag">    <span class="attr">soap:encodingStyle</span>=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soapenc</span>=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tns</span>=<span class="string">"http://ts.ch01/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tns:getTimeAsString</span> <span class="attr">xsi:nil</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 请求第一行指定了请求方法为“POST”。在 SOAP 请求中，通常是 POST 方式，而不是 GET，因为只有  POST 请求才有 Body 域，可以用来封装一个 SOAP 消息。URL 之后是协议和协议版本号。</li>
<li>HTTP 头之后是一些由冒号分割的键值对。它们出现的顺序是任意的。“Accept”键以 MIME（Multipurpose Internet Mail Extension）类型/子类型的方式出现，3个“Accept”键表明请求者客户端可以分别处理任意类型的 XML 文档，附带任意数量的不同类型文档（SOAP消息通常可以有任意多个附件）的请求响应，以及一个 SOAP 文档。“SOAPAction”键通常用来表示这个 HTTP 请求是一个 Web 服务请求，同时取值可以为空字符串，也有可能是请求的 Web 服务操作的名称。</li>
<li>一个空行分隔 HTTP 头数据和 Body 域。本例中 Body 域包含一个 SOAP 文档，称为 SOAP 信封（SOAP Envelope）。</li>
</ul>
<p>针对 Web 服务来说，底层的 Java 支持库处理 HTTP 请求，并将 SOAP 信封拆包，分析出客户端请求的服务操作，然后调用对应的方法，生成相应的 SOAP 消息返回给客户端。</p>
<h2 id="1-6-来自-TimeServer-服务的-HTTP-响应"><a href="#1-6-来自-TimeServer-服务的-HTTP-响应" class="headerlink" title="1.6 来自 TimeServer 服务的 HTTP 响应"></a>1.6 来自 TimeServer 服务的 HTTP 响应</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length:323</span><br><span class="line">Content-Type:text/xml;charset=utf-8</span><br><span class="line">Client-Date:Mon,28 Apr 2008 02:12:54 GMT</span><br><span class="line">Client-Peer:127.0.0.1:9876</span><br><span class="line">Client-Response-Num:1</span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ans:getTimeAsStringResponse</span> <span class="attr">xmlns:ans</span>=<span class="string">"http://ts.ch01/"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">return</span>&gt;</span>Mon Apr 28 14:12:54 CST 2008<span class="tag">&lt;/<span class="name">return</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ans:getTimeAsStringResponse</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据 WSDL 文档提供的信息（这里未列出），要求从 Web 服务返回的值出现在 XML 的 <code>&lt;return&gt;</code> 元素中。</p>
<h2 id="1-7-Java-语言实现的-Web-服务客户端"><a href="#1-7-Java-语言实现的-Web-服务客户端" class="headerlink" title="1.7 Java 语言实现的 Web 服务客户端"></a>1.7 Java 语言实现的 Web 服务客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01.ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.namespace.QName;</span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Service;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URL url=<span class="keyword">new</span> URL(<span class="string">"http://localhost:9876/ts?wsdl"</span>);</span><br><span class="line">        <span class="comment">//Qualified name of the service.</span></span><br><span class="line">        QName qname=<span class="keyword">new</span> QName(<span class="string">"http://ts.ch01/"</span>,<span class="string">"TimeServerImplService"</span>);</span><br><span class="line">        <span class="comment">//Create a factory for the service.</span></span><br><span class="line">        Service service=Service.create(url,qname);</span><br><span class="line">        <span class="comment">//Extract the endpoint interface, the service "port".</span></span><br><span class="line">        TimeServer eif=service.getPort(TimeServer.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(eif.getTimeAsString());</span><br><span class="line">        System.out.println(eif.getTimeAsElapsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java客户端明确地创建了一个语法格式为“URI：本地名称”的 XML 限定名，<code>java.xml.namespace.Qname</code> 类用来表示一个 XML 限定名。本类中的命名空间 URI 在 WSDL 文档中提供；本地名称在 WSDL 文档最后一段的 Service 元素中描述（这里是“TimeServerImplService”）。<br>调用 <code>Service.create()</code> 方法后，执行 <code>getPort()</code> 方法，该方法返回一个 Java 对象，可以通过此对象调用 portType 中描述的操作。</p>
<h1 id="2-全面了解-WSDL"><a href="#2-全面了解-WSDL" class="headerlink" title="2. 全面了解 WSDL"></a>2. 全面了解 WSDL</h1><h2 id="2-1-从-WSDL-文档中生成客户端支持代码"><a href="#2-1-从-WSDL-文档中生成客户端支持代码" class="headerlink" title="2.1 从 WSDL 文档中生成客户端支持代码"></a>2.1 从 WSDL 文档中生成客户端支持代码</h2><p>2.1.1 使用 wsimport</p>
<p>通过 Jdk1.6+ 提供的 wsimport 工具轻松完成基于 SOAP 协议的 Web 服务客户端生成工作。</p>
<p><strong>首先确认服务端已经运行，这样才能访问到 WSDL。</strong><br>在 cmd.exe 中运行命令：<br><code>wsimport -d class -s source -keep http://localhost:9876/ts?wsdl</code></p>
<ul>
<li><code>-d</code>：class 文件存放目录；</li>
<li><code>-s</code>：java 文件存放目录；</li>
<li><code>-keep</code>：保留 java 文件。</li>
</ul>
<p>该命令以 cmd.exe 运行目录为当前目录。class 和 source 都是当前目录下已存在的自定义目录。默认使用服务实现的包名作为客户端代码包名，注意避免覆盖。若 SEI 采用 Document 的绑定方式则会自动生成相关工件。<br>其中，契约地址可换成本地 wsdl 文件的路径。</p>
<p>根据之前的 wsdl 文档，wsimport 会生成 TimeServer.class 和 TimeServerImplService.class 两个字节码文件。可基于这两个文件编写服务调用客户端。</p>
<p>wsimport 使用的编码为操作系统的编码，且源代码中的注释使用的是英文。</p>
<p>2.1.2 使用 wsdl2java</p>
<p>wsdl2java.exe 通常在 webservice 框架（如 CXF、AXIS2）的文件夹内。</p>
<p><code>wsdl2java [options] [URL|wsdl文件]</code></p>
<ul>
<li><code>-d</code>：源码输出目录；</li>
<li><code>-compile</code>：是否编译源码；</li>
<li><code>-classdir</code>：字节码输出目录；</li>
<li><code>-b</code>：指定数据绑定文件；</li>
</ul>
<p>生成的客户端中会出现类似 <code>JaxbElement&lt;String&gt;</code> 的对象，而不是 <code>String</code>。可以通过参数 <code>-b</code> 来指定数据绑定文件，并在该文件中进行设置。<br>比如先创建文件 cxf_binding.xml，内容如下。然后指定参数 <code>-b cxf_binding.xml</code>，若文件不在当前路径，则需写明绝对路径。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jaxb:bindings</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">xmlns:jaxb</span>=<span class="string">"http://java.sun.com/xml/ns/jaxb"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jaxb:bindings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jaxb:globalBindings</span> <span class="attr">generateElementProperty</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jaxb:bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jaxb:bindings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeClientWSDL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeServerImplService service = <span class="keyword">new</span> TimeServerImplService();</span><br><span class="line">        TimeServer eif = service.getTimeServerImplPort();</span><br><span class="line">        </span><br><span class="line">        System.out.println(eif.getTimeAsString());</span><br><span class="line">        System.out.println(eif.getTimeAsElapsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到与服务对应的Qname和服务端点等复杂细节都被隐藏了。</p>
<p><strong>基于WSDL协议所生成的相关工件（Artifact）编写服务客户端的一些常用做法：</strong></p>
<ol>
<li>通过 wsimport 产生的 Class 文件中的构造方法构造一个服务对象，比如本例中的 <code>TimeServerImplService</code> 类。</li>
<li>通过构建的服务对象调用对应的 get 方法。</li>
</ol>
<h2 id="2-2-WSDL文档结构"><a href="#2-2-WSDL文档结构" class="headerlink" title="2.2 WSDL文档结构"></a>2.2 WSDL文档结构</h2><p>根元素 <code>&lt;definitions&gt;</code> 内部分为 3 部分：</p>
<ul>
<li><strong>类型（Types）：</strong>非必需。通常基于像XML模式（XML Schema）这样的类型系统来提供数据类型的定义。这种用来定义数据类型的文档就是XSD（XML Schema Definition）。在数据类型部分可以持有、指向或引入一个XSD。若为空，则只使用简单数据类型，比如<code>xsd:String</code>和<code>xsd:long</code>。</li>
<li><strong>消息（Message）：</strong>定义了实现服务的相关消息。消息使用的数据类型来自前面的类型部分。消息的顺序表明了服务的请求模式：“in/out”对应请求/响应（request/response）模式；“out/in”对应要求/响应（solicit/response）模式。</li>
<li><strong>portType：</strong>以命名的操作描述了服务，每一个操作都是一个或多个消息。服务操作的名称由Web服务方法的注解<code>@WebMethods</code>指定。“portType”与Java接口类似，抽象描述服务而不包括实现细节。</li>
<li><strong>绑定（Binding）：</strong> WSDL定义从抽象到具体的描述。绑定部分可类比为Java接口的实现。它详细说明了“portType”部分的抽象定义：<ul>
<li><code>&lt;soap:binding style=&quot;RPC&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;&gt;</code>其中<code>transport</code>属性指明收发SOAP消息所使用的传输协议。</li>
<li><code>style</code>属性可选“rpc”或“document”，默认为“document”。由SEI中的<code>@SOAPBinding(style=Style.RPC)</code>指定。</li>
<li>SOAP消息中使用的数据编码格式有两种：“literal”（逐字的）和“encoded”。其中“encoded”不符合WS-I指导原则，一般不使用。</li>
</ul>
</li>
<li><strong>服务（service）：</strong>指定了一个或多个端点，端点中描述了服务的功能和所包括的操作。从技术上看，服务部分包括一个或多个port（端口），每个port包括portType（接口）及与之对应的binding（接口实现）。port一词源自分布式系统。</li>
</ul>
<h2 id="2-4-wsgen-工具与-JAX-B-工件（Artifacts）"><a href="#2-4-wsgen-工具与-JAX-B-工件（Artifacts）" class="headerlink" title="2.4 wsgen 工具与 JAX-B 工件（Artifacts）"></a>2.4 wsgen 工具与 JAX-B 工件（Artifacts）</h2><p>任何 Document 样式的服务，都需要由 wsgen 工具产生的工件（Artifacts，支持客户端开发的相关代码资源）。<br>假设 TimeServerImpl.class(注意是 <strong>.class</strong> 而不是 <strong>.java</strong>)的路径为 <code>C:/workspace/MyProject/build/classes/com/demo/TimeServerImpl.class</code>，则需要在 <code>C:/workspace/MyProject/build/classes</code> 目录内运行下列命令，否则提示 <code>Class Not Found.</code><br><code>wsgen -keep -cp . com.demo.TimeServerImpl</code><br>运行该命令后将在 <code>../com/demo</code> 目录中生成一个“javax”文件夹，里面包含生成的代码资源。<br>在底层，wsgen 工具利用 JAX-B（Java API for XML-Binding）相关的 API 包实现“Java对象<strong>编码（Marshal）</strong>为 XML 文档”和“XML 文档<strong>解码（Unmarshal）</strong>为 Java 对象”的功能。<br>具体的注解见 <code>javax.xml.bind.annotation.*</code>。</p>
<p><strong>利用wsgen工具产生WSDL文档</strong><br><code>wsgen -cp &quot;.&quot; -wsdl com.demo.TimeServerImpl</code><br>命令运行目录同前文所述。运行后将在<code>../MyProject/build/classes</code>内生成相应的<code>.wsdl</code>和<code>.xsd</code>。</p>
<p>#3. Web Service注解<br>JSR 181<br><strong>注释类：</strong> </p>
<p>##javax.jws.WebService<br><strong>注释：</strong><br>当实现 Web Service 时，<code>@WebService</code> 注释标记 Java 类；实现 Web Service 接口时，标记服务端点接口（SEI）。<br>要点：<br>• 实现 Web Service 的 Java 类必须指定 <code>@WebService</code> 或 <code>@WebServiceProvider</code> 注释。不能同时提供这两种注释。<br>• 此注释适用于客户机/服务器 SEI 或 JavaBeans 端点的服务器端点实现类。<br>• 如果注释通过 <code>endpointInterface</code> 属性引用了某个 SEI，那么还必须使用 <code>@WebService</code> 注释来注释该 SEI。<br><strong>属性：</strong><br>注释目标：类型<br>• <em>name</em><br><code>wsdl:portType</code> 的名称。缺省值为 Java 类或接口的非限定名称。（字符串）<br>• <em>targetNamespace</em><br>指定从 Web Service 生成的 WSDL 和 XML 元素的 XML 名称空间。缺省值为从包含该 Web Service 的包名映射的名称空间。（字符串）<br>• <em>serviceName</em><br>指定 Web Service 的服务名称<code>wsdl:service</code>。缺省值为 “Java 类的简单名称 + Service”。（字符串）<br>• <em>endpointInterface</em><br>指定用于定义服务的抽象 Web Service 约定的服务端点接口的限定名。如果指定了此限定名，那么会使用该服务端点接口来确定抽象 WSDL 约定。（字符串）<br>• <em>portName</em><br><code>wsdl:portName</code>。缺省值为 WebService.name+Port。（字符串）<br>• <em>wsdlLocation</em><br>指定用于定义 Web Service 的 WSDL 文档的 Web 地址。Web 地址可以是相对路径或绝对路径。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.WebMethod<br><strong>注释：</strong><br><code>@WebMethod</code> 注释表示作为一项 Web Service 操作的方法。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br>要点：<br>• 仅支持在使用 <code>@WebService</code> 注释来注释的类上使用 <code>@WebMethod</code> 注释。<br><strong>属性：</strong><br>注释目标：方法<br>• <em>operationName</em><br>指定与此方法相匹配的 <code>wsdl:operation</code> 的名称。缺省值为 Java 方法的名称。（字符串）<br>• <em>action</em><br>定义此操作的行为。对于 SOAP 绑定，此值将确定 SOAPAction 头的值。缺省值为 Java 方法的名称。（字符串）<br>• <em>exclude</em><br>指定是否从 Web Service 中排除某一方法。缺省值为 false。（布尔值）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.Oneway<br><strong>注释：</strong><br><code>@Oneway</code> 注释将一个方法表示为只有输入消息而没有输出消息的 Web Service 单向操作。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法<br>没有适用于 Oneway 注释的属性。</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.WebParam<br><strong>注释：</strong><br><code>@WebParam</code> 注释用于定制从单个参数至 Web Service 消息部件和 XML 元素的映射。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：参数<br>• <em>name</em><br>参数的名称。如果操作是远程过程调用（RPC）类型并且未指定<code>partName</code> 属性，那么这是用于表示参数的 <code>wsdl:part</code> 属性的名称。如果操作是文档类型或者参数映射至某个头，那么 <code>name</code> 是用于表示该参数的 XML 元素的局部名称。如果操作是文档类型、参数类型为 BARE 并且方式为 OUT 或 INOUT，那么必须指定此属性。（字符串）<br>• <em>partName</em><br>定义用于表示此参数的 <code>wsdl:part</code> 属性的名称。仅当操作类型为 RPC 或者操作是文档类型并且参数类型为 BARE 时才使用此参数。（字符串）<br>• <em>targetNamespace</em><br>指定参数的 XML 元素的 XML 名称空间。当属性映射至 XML 元素时，仅应用于文档绑定。缺省值为 Web Service 的 <code>targetNamespace</code>     。（字符串）<br>• <em>mode</em><br>此值表示此方法的参数流的方向。有效值为 IN、INOUT 和 OUT。（字符串）<br>• <em>header</em><br>指定参数是在消息头还是消息体中。缺省值为 false。（布尔值）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.WebResult<br><strong>注释：</strong><br><code>@WebResult</code> 注释用于定制从返回值至 WSDL 部件或 XML 元素的映射。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法<br>• <em>name</em><br>当返回值列示在 WSDL 文件中并且在连接上的消息中找到该返回值时，指定该返回值的名称。对于 RPC 绑定，这是用于表示返回值的 <code>wsdl:part</code> 属性的名称。对于文档绑定，<code>name</code>参数是用于表示返回值的 XML 元素的局部名。对于 RPC 和 DOCUMENT/WRAPPED 绑定，缺省值为 return。对于 DOCUMENT/BARE 绑定，缺省值为”方法名 + Response”。（字符串）<br>• <em>targetNamespace</em><br>指定返回值的 XML 名称空间。仅当操作类型为 RPC 或者操作是文档类型并且参数类型为 BARE 时才使用此参数。（字符串）<br>• <em>header</em><br>指定头中是否附带结果。缺省值为false。（布尔值）<br>• <em>partName</em><br>指定 RPC 或 DOCUMENT/BARE 操作的结果的部件名称。缺省值为<code>@WebResult.name</code>。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.HandlerChain<br><strong>注释：</strong><br><code>@HandlerChain</code> 注释用于使 Web Service 与外部定义的处理程序链相关联。<br>只能通过对 SEI 或实现类使用 <code>@HandlerChain</code> 注释来配置服务器端的处理程序。<br>但是可以使用多种方法来配置客户端的处理程序。可以通过对生成的服务类或者 SEI 使用 <code>@HandlerChain</code> 注释来配置客户端的处理程序。此外，可以按程序在服务上注册您自己的 HandlerResolver 接口实现，或者按程序在绑定对象上设置处理程序链。<br><strong>属性：</strong><br>注释目标：类型<br>• <em>file</em><br>指定处理程序链文件所在的位置。文件位置可以是采用外部格式的绝对 java.net.URL，也可以是类文件中的相对路径。（字符串）<br>• <em>name</em><br>指定配置文件中处理程序链的名称。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.jws.SOAPBinding<br><strong>注释：</strong><br><code>@SOAPBinding</code> 注释指定 Web Service 与 SOAP 消息协议之间的映射。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的类型或方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br>方法级别的注释仅限于它可以指定的对象，仅当 style 属性为 DOCUMENT 时才使用该注释。如果未指定方法级别的注释，那么将使用类型的 <code>@SOAPBinding</code> 行为。<br><strong>属性：</strong><br>注释目标：类型或方法<br>• <em>style</em><br>定义发送至 Web Service 和来自 Web Service 的消息的编码样式。有效值为 DOCUMENT 和 RPC。缺省值为 DOCUMENT。（字符串）<br>• <em>use</em><br>定义用于发送至 Web Service 和来自 Web Service 的消息的格式。缺省值为 LITERAL。ENCODED 在 Feature Pack for Web Services 中不受支持。（字符串）<br>• <em>parameterStyle</em><br>确定方法的参数是否表示整个消息体，或者参数是否是封装在执行操作之后命名的顶级元素中的元素。有效值为 WRAPPED 或 BARE。对于DOCUMENT 类型的绑定只能使用 BARE 值。缺省值为 WRAPPED。（字符串）</p>
<p>JSR 224<br><strong>注释类：</strong> </p>
<p>##javax.xml.ws.BindingType<br><strong>注释：</strong><br><code>@BindingType</code> 注释指定在发布此类型的端点时要使用的绑定。<br>将此注释应用于 JavaBeans 端点或提供程序端点的服务器端点实现类。<br>要点：<br>• 可以通过将该注释的值指定为 javax.xml.ws.soap.SOAPBinding.SOAP11HTTP_MTOM_BINDING 或 javax.xml.ws.soap.SOAPBinding.SOAP12HTTP_MTOM_BINDING 来对 Java bean 端点实现类使用 <code>@BindingType</code> 注释以启用 MTOM。<br><strong>属性：</strong><br>注释目标：类型：<br>• <em>value</em><br>指示绑定标识 Web 地址。有效值为 javax.xml.ws.soap.SOAPBinding.SOAP11HTTP_BINDING、javax.xml.ws.soap.SOAPBinding.SOAP12HTTP_BINDING 和 javax.xml.ws.http.HTTPBinding.HTTP2HTTP_BINDING。缺省值为 javax.xml.ws.soap.SOAPBinding.SOAP11HTTP_BINDING。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.xml.ws.RequestWrapper<br><strong>注释：</strong><br><code>@RequestWrapper</code> 注释提供 JAXB 生成的请求包装器 bean、元素名称和名称空间，用于对在运行时使用的请求包装器 bean 进行序列化和反序列化。<br>从 Java 对象开始时，此元素用来解决 document literal 方式下的重载冲突。在这种情况下，只有 className 属性是必需的。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法<br>• <em>localName</em><br>指定用于表示请求包装器的 XML 模式元素的局部名称。缺省值为在 javax.jws.WebMethod 注释中定义的 operationName。（字符串）<br>• <em>targetNamespace</em><br>指定请求包装器方法的 XML 名称空间。缺省值为 SEI 的目标名称空间。（字符串）<br>• <em>className</em><br>指定用于表示请求包装器的类的名称。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.xml.ws.ResponseWrapper<br><strong>注释：</strong><br><code>@ResponseWrapper</code> 注释提供 JAXB 生成的响应包装器 bean、元素名称和名称空间，用于对在运行时使用的响应包装器 bean 进行序列化和反序列化。<br>从 Java 对象开始时，此元素用来解决 document literal 方式下的重载冲突。在这种情况下，只有 className 属性是必需的。<br>将此注释应用于客户机或服务器服务端点接口（SEI）上的方法，或者应用于 JavaBeans 端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法<br>• <em>localName</em><br>指定用于表示请求包装器的 XML 模式元素的局部名称。缺省值为 operationName + Response。operationName 是在 <code>javax.jws.WebMethod</code> 注释中定义的。（字符串）<br>• <em>targetNamespace</em><br>指定请求包装器方法的 XML 名称空间。缺省值为 SEI 的目标名称空间。（字符串）<br>• <em>className</em><br>指定用于表示响应包装器的类的名称。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.xml.ws.ServiceMode<br><strong>注释：</strong><br><code>@ServiceMode</code> 注释指定服务提供者是需要对整个协议消息具有访问权还是只需对消息有效内容具有访问权。<br>要点：<br>• 仅支持在使用 <code>@WebServiceProvider</code> 注释来注释的类上使用 <code>@ServiceMode</code> 注释。<br><strong>属性：</strong><br>注释目标：类型<br>• <em>value</em><br>指示提供者类是接受消息的有效内容 PAYLOAD 还是整个消息 MESSAGE。缺省值为 PAYLOAD。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.xml.ws.WebFault<br><strong>注释：</strong><br><code>@WebFault</code> 注释将 WSDL 故障映射至 Java 异常。对从 WSDL 故障消息引用的全局元素生成的 JAXB 类型进行序列化期间，该注释用来捕获故障的名称。它还可以用来定制从特定于服务的异常到 WSDL 故障的映射。<br>此注释只能应用于客户机或服务器上的故障实现类。<br><strong>属性：</strong><br>注释目标：类型<br>• <em>name</em><br>指定用于表示 WSDL 文件中相应故障的 XML 元素的局部名称。必须指定实际值。（字符串）<br>• <em>targetNamespace</em><br>指定用于表示 WSDL 文件中相应故障的 XML 元素的名称空间。（字符串）<br>• <em>faultBean</em><br>指定故障 bean 类的名称。（字符串）</p>
<p><strong>注释类：</strong> </p>
<p>##javax.xml.ws.WebServiceProvider<br><strong>注释：</strong><br><code>@WebServiceProvider</code> 注释表示一个类满足 JAX-WS 提供程序实现类的要求。<br>要点：<br>• 实现 Web Service 的 Java 类必须指定 <code>@WebService</code> 或 <code>@WebServiceProvider</code> 注释。不能同时提供这两种注释。<br>• 只有服务实现类才支持 <code>@WebServiceProvider</code> 注释。<br>• 任何具有 <code>@WebServiceProvider</code> 注释的类都必须具有名为 invoke 的操作。<br><strong>属性：</strong><br>注释目标：类型<br>• <em>targetNamespace</em><br>指定从 Web Service 生成的 WSDL 和 XML 元素的 XML 名称空间。缺省值为从包含该 Web Service 的包名映射的名称空间。（字符串）<br>• <em>serviceName</em><br>指定 Web Service 的服务名称 <code>wsdl:service</code>。缺省值为 “Java 类的简单名称 + Service”。（字符串）<br>• <em>portName</em><br><code>wsdl:portName</code>。缺省值为”类的名称 + Port”。（字符串）<br>• <em>wsdlLocation</em></p>
<p>JSR 250<br><strong>注释类：</strong></p>
<p>##javax.annotation.Resource<br><strong>注释：</strong><br><code>@Resource</code> 注释标记应用程序所需要的 WebServiceContext 资源。<br>将此注释应用于 JavaBeans 端点或提供程序端点的服务器端点实现类。对容器进行初始化时，容器会将 WebServiceContext 资源的实例添加到端点实现中。<br><strong>属性：</strong><br>注释目标：字段或方法<br>• <em>type</em><br>指示资源的 Java 类型。您需要使用缺省值 java.lang.Object 或者 javax.xml.ws.Web ServiceContext 值。如果类型是缺省值，那么必须将资源添加到字段或方法中。在这种情况下，字段的类型或者由方法定义的 JavaBeans 属性的类型必须为 javax.xml.ws.WebServiceContext。（字符串）</p>
<p><strong>注释类：</strong></p>
<p>##javax.annotation.PostConstruct<br><strong>注释：</strong><br><code>@PostConstruct</code> 注释标记需要在对类执行依赖性注入之后才执行的方法。<br>将此注释应用于 JAX-WS 应用程序处理程序、JavaBeans 端点或提供程序端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法</p>
<p><strong>注释类：</strong></p>
<p>##javax.annotation.PreDestroy<br><strong>注释：</strong><br><code>@PreDestroy</code> 注释标记在容器除去实例时必须执行的方法。<br>将此注释应用于 JAX-WS 应用程序处理程序、JavaBeans 端点或提供程序端点的服务器端点实现类。<br><strong>属性：</strong><br>注释目标：方法</p>
<p>适用于使用 <code>@WebService</code> 注释的类的方法的规则<br>下列规则适用于使用 <code>@WebService</code> 注释来注释的类的方法。<br>如果某个实现类的 <code>@WebService</code> 注释引用了 SEI，那么该实例类不能具有任何 <code>@WebMethod</code> 注释。<br>无论是否指定了 <code>@WebMethod</code> 注释，SEI 的所有公用方法都被认为是已显示的方法。在包含 exclude 属性的 SEI 上使用 <code>@WebMethod</code> 注释是不正确的。<br>对于不引用 SEI 的实现类，如果对 <code>@WebMethod</code> 注释指定了值 exclude=true，那么不会显示该方法。如果未指定 <code>@WebMethod</code> 注释，那么将显示包括继承的方法在内的所有公用方法，但是不包括从 java.lang.Object 继承的方法。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="WSDL详细报文"><a href="#WSDL详细报文" class="headerlink" title="WSDL详细报文"></a><span id="wsdl">WSDL详细报文</span></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tns</span>=<span class="string">"http://ts.ch01/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">targetNamespace</span>=<span class="string">"http://ts.ch01/"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"TimeServerImplService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">types</span>&gt;</span><span class="tag">&lt;/<span class="name">types</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"getTimeAsString"</span>&gt;</span><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"getTimeAsStringResponse"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">part</span> <span class="attr">name</span>=<span class="string">"return"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span><span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"getTimeAsElapsed"</span>&gt;</span><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"getTimeAsElapsedResponse"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">part</span> <span class="attr">name</span>=<span class="string">"return"</span> <span class="attr">type</span>=<span class="string">"xsd:long"</span>&gt;</span><span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">portType</span> <span class="attr">name</span>=<span class="string">"TimeServer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"getTimeAsString"</span> <span class="attr">parameterOrder</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">message</span>=<span class="string">"tns:getTimeAsString"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">output</span> <span class="attr">message</span>=<span class="string">"tns:getTimeAsStringResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">operation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"getTimeAsElapsed"</span> <span class="attr">parameterOrder</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">message</span>=<span class="string">"tns:getTimeAsElapsed"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">output</span> <span class="attr">message</span>=<span class="string">"tns:getTimeAsElapsedResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">operation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">portType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"TimeServerImplPortBinding"</span> <span class="attr">type</span>=<span class="string">"tns:TimeServer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">style</span>=<span class="string">"rpc"</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">soap:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"getTimeAsString"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:operation</span> <span class="attr">soapAction</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:operation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> <span class="attr">namespace</span>=<span class="string">"http://ts.ch01/"</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> <span class="attr">namespace</span>=<span class="string">"http://ts.ch01/"</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">operation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"getTimeAsElapsed"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:operation</span> <span class="attr">soapAction</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:operation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> <span class="attr">namespace</span>=<span class="string">"http://ts.ch01/"</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> <span class="attr">namespace</span>=<span class="string">"http://ts.ch01/"</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">operation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">"TimeServerImplService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">"TimeServerImplPort"</span> <span class="attr">binding</span>=<span class="string">"tns:TimeServerImplPortBinding"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://localhost:9876/ts"</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#return1">返回</a></p>
<p>[^new Date()]:该服务以字符串的形式向调用者返回当前系统时间或返回一个 Unix 时间戳，即从1970年1月1日（UTC（Universal Time Coordinated）/GMT（Greenwich Mean Time）的午夜零点）开始到目前所经过的秒数，不考虑闰秒。最早出现的 UNIX 操作系统考虑到计算机产生的年代和应用的时限综合取了 1970 年 1 月 1 日作为 UNIX TIME 的纪元时间(开始时间)，而 java 作为源于 UNIX 的一种语言自然也遵循了这一约束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/工具/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/工具/Git/" itemprop="url">Git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h1><p><code>git add -i</code> 进入交互模式</p>
<ul>
<li>status：展示已暂存的（staged）、未暂存的（unstaged）和该文件的路径。</li>
<li>update：命令行提示符变为 <code>Update&gt;&gt;</code>，通过输入数字来选择文件，数字之间用空格或逗号分隔，如：2-3 5,6；数字前加减号取消选择。最后输入一个空行表示确认，被选择的文件会被暂存。</li>
<li>revert：交互模式同 update。被选择的文件会用 HEAD 覆盖暂存区内容。</li>
<li>add untracked：交互模式同 update。</li>
<li>patch：选择一个文件，对文件内容分块依次决定是否暂存。<ul>
<li>y：暂存此块。</li>
<li>n：不暂存此块。</li>
<li>q：取消并退出。</li>
<li>a：暂存此块以及后面的块。</li>
<li>d：不暂存此块以及后面的块。</li>
<li>g：选择并跳转到某个块。</li>
<li>/：用正则表达式搜索某个块。</li>
<li>j：暂时不决定此块，跳转到下一个未决定的块。</li>
<li>J：暂时不决定此块，跳转到下一个块。</li>
<li>k：暂时不决定此块，跳转到上一个未决定的块。</li>
<li>K：暂时不决定此块，跳转到上一个块。</li>
<li>s：将当前块继续分割成小块。</li>
<li>e：编辑当前块。</li>
<li>?：帮助</li>
</ul>
</li>
<li>diff：展示 HEAD 和暂存区之间的区别。</li>
<li>quit</li>
<li><p>help</p>
</li>
<li><p><code>git add -p</code> 同交互模式中的 patch。</p>
</li>
<li><code>-N|--intent-to-add</code> 将未跟踪的文件列为要跟踪，而不是直接 add 到暂存区。这样方便比较工作区和暂存区间的差异。</li>
</ul>
<h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><ul>
<li><code>git commit</code><br>打开编辑器来撰写 commit 信息</li>
<li><code>git commit -m &quot;message&quot;</code><br>commit 到 Head，并附带备注 “message”</li>
<li><code>git commit -am &quot;message&quot;</code><br>结合了 add . 和 commit，不适用于新添加的文件</li>
<li><code>git commit --amend</code><br>修改最近一次提交，使用当前暂存区做提交，并可以修改提交信息</li>
</ul>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul>
<li><code>git rm [-f|--force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] {filename}...</code><br>删除暂存区和工作区中的指定文件。该文件在三棵树中的内容必须相同，否则要用 <code>-f</code> 强制删除暂存区和工作区，或用 <code>--cached</code> 删除暂存区（此时暂存区必须要么跟工作区相同，要么跟版本库相同）。<ul>
<li><code>{filename}</code> 可以用通配符（要做 shell 转义）</li>
<li><code>-f|--force</code> 强制删除暂存区和工作区中的指定文件（否则要求该文件在三棵树中的内容相同）</li>
<li><code>-n|--dry-run</code> 预览操作结果</li>
<li><code>-r</code> 指定目录做递归删除</li>
<li><code>--cached</code> 只从暂存区删除</li>
<li><code>--ignore-unmatch</code> 若未匹配到文件也不显示错误</li>
<li><code>-q|--quiet</code> 不显示执行结果</li>
</ul>
</li>
<li><code>git rm [-r] --cached {filename}</code><br>删除 index 中的文件，保留工作区中的文件，<code>-r</code> 表示递归</li>
<li><code>git clean [-d] [-f] [-i] [-n] [-q] [-e &lt;pattern&gt;] [-x | -X] [--] &lt;path&gt;...</code> 清除未跟踪的文件和目录<ul>
<li><code>-n</code> 预览将被删除的文件，不会直接删除。</li>
<li><code>-d</code> 除了未跟踪的文件外，还删除未跟踪的目录。</li>
<li><code>-f</code> <code>--force</code> 若未将 <code>clean.requireForce</code> 选项置为 false，则不能删除文件和目录，除非带有参数 <code>-f</code>/<code>-n</code>/<code>-i</code>。对于子目录中带有 .git 文件夹的，需要给出两个 <code>-f</code> 参数。</li>
<li><code>-x</code> 扫描未跟踪文件时无视 .gitignore 和 $GIT_DIR/info/exclude，但仍会考虑 <code>-e</code> 参数。</li>
<li><code>-X</code> 仅删除被 git 忽略的文件。通常用来在清理的同时保留用户自建的文件。</li>
<li><code>-q</code> <code>--quiet</code> 仅报告错误。</li>
<li><code>-i</code> 交互式。</li>
</ul>
</li>
</ul>
<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><ul>
<li><code>git reset HEAD {file}...</code> 用版本库覆盖暂存区</li>
<li><code>git checkout {file}...</code> 用暂存区覆盖工作区</li>
<li><code>git clean -fd</code> 删除未跟踪的文件和目录</li>
<li><code>git reset [--soft|--mixed|--hard] {HEAD~|commit_id}</code> 重置头指针<ul>
<li><code>soft</code> 只回退版本库，不回退暂存区和工作区；</li>
<li><code>mixed</code> 缺省选项，回退版本库和暂存区；</li>
<li><code>hard</code> 回退版本库、暂存区和工作区</li>
</ul>
</li>
</ul>
<h1 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h1><ul>
<li><code>git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[{keyId}]] {commit}...</code><ul>
<li><code>-e</code> <code>--edit</code> 不自动提交反转，让用户先手动编辑提交信息。这是终端的默认参数。</li>
<li><code>--no-edit</code> 自动提交反转。</li>
<li><code>-n</code> <code>--no-commit</code> 反转但不自动产生提交。</li>
<li><code>-m parent-number</code> <code>--mainline parent-number</code> 用于反转合并提交。</li>
</ul>
</li>
<li><code>git revert --continue</code></li>
<li><code>git revert --quit</code></li>
<li><code>git revert --abort</code></li>
</ul>
<h1 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h1><ul>
<li><code>git mv {file_from} {file_to}</code><br>相当于依次执行下面两条命令<ul>
<li><code>git rm {file_from}</code></li>
<li><code>git add {file_to}</code></li>
</ul>
</li>
</ul>
<h1 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h1><ul>
<li><code>git stash [--keep-index] [-u] [save &#39;{message}&#39;]</code><br>储藏当前所有未提交的改动，可附加备注；<code>--keep-index</code> 表示不储藏暂存区；<code>-u</code> 表示储藏未追踪的文件</li>
<li><code>git stash list</code><br>列出储藏栈中内容</li>
<li><code>git stash apply [stash@{n}] [--index]</code><br>恢复指定某次的储藏内容中的工作区文件，缺省为最近一次的；<code>--index</code> 表示恢复工作区和暂存区文件</li>
<li><code>git stash drop [stash@{n}]</code><br>删除储藏</li>
<li><code>git stash clear</code><br>清除所有储藏</li>
<li><code>git stash pop [stash@{n}] [--index]</code><br>应用并删除储藏</li>
<li><code>git stash branch {branch_name} [stash@{n}]</code><br>新建一个分支并应用储藏内容，如果没有冲突则会自动删除该储藏</li>
<li><code>git stash show [{stash}]</code><br>查看 stash 改动内容。可以接受参数来修改展示方式（同 <code>git diff</code>）</li>
</ul>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul>
<li><code>git log -p -{n}</code><br>显示最近 n 次的提交日志，并展开每次提交的内容差异</li>
<li><code>git log --stat</code><br>仅显示简要的增改行数统计</li>
<li><code>git log --shortstat</code><br>仅显示 <code>--stat</code> 中最后的行数修改添加移除的统计</li>
<li><code>git log --name-only</code><br>仅在提交信息后显示已修改的文件清单</li>
<li><code>git log --name-status</code><br>显示新增、修改、删除的文件清单</li>
<li><code>git log --abbrev-commit</code><br>仅显示 SHA-1 的前几个字符</li>
<li><code>git log --relative-date</code><br>使用较短的相对时间显示（如：“2 weeks ago”）</li>
<li><code>git log --graph</code><br>显示 ASCII 图形表示的分支合并历史</li>
<li><code>git log --pretty</code><br>使用其他格式显示历史提交信息。可用选项包括 <code>oneline</code>、<code>short</code>、<code>full</code>、<code>fuller</code>、<code>format</code>（后跟指定格式）</li>
<li><code>git log [--left-right] {b1}...{b2}</code><br>只存在于 {b1} 和 {b2} 中的一个，而不同时存在于两者的提交；<code>--left-right</code> 会显示每个提交具体在哪个分支中</li>
</ul>
<p><code>git log [{options}] [{revision_range}] [[\\--] {path}...]</code></p>
<ul>
<li>{options}<ul>
<li><code>--follow</code> 继续显示文件被移动或重命名前的历史，只针对单个文件有效。</li>
<li><code>--no-decorate</code> <code>--decorate[=short|full|auto|no]</code></li>
<li><code>--source</code></li>
<li><code>--use-mailmap</code></li>
<li><code>--full-diff</code></li>
<li><code>--log-size</code></li>
<li><code>-L {start},{end}:{file}</code></li>
<li><code>-L:{funcname}:{file}</code></li>
</ul>
</li>
<li>{revision_range}</li>
<li>[\–] {path}</li>
<li>提交范围限制<ul>
<li><code>-{number}</code></li>
<li><code>-n {number}</code></li>
<li><code>--max-count={number}</code></li>
<li><code>--skip={number}</code></li>
<li><code>--since={date}</code></li>
<li><code>--after={date}</code></li>
<li><code>--until={date}</code></li>
<li><code>--before={date}</code></li>
<li><code>--author={pattern}</code></li>
<li><code>--committer={pattern}</code></li>
<li><code>--greg-reflog={pattern}</code></li>
<li><code>--greg={pattern}</code></li>
<li><code>--all-match</code></li>
<li><code>--invert-greg</code></li>
<li><code>-i</code> <code>--regexp-ignore-case</code></li>
<li><code>--basic-regexp</code></li>
<li><code>-E</code> <code>--extended-regexp</code></li>
<li><code>-F</code> <code>--fixed-strings</code></li>
<li><code>--perl-regexp</code></li>
<li><code>--remove-empty</code></li>
<li><code>--merges</code></li>
<li><code>--nomerges</code></li>
<li><code>--min-parents={number}</code> <code>--max-parents={number}</code> <code>--no-min-parents</code> <code>--no-max-parents</code></li>
<li><code>--first-parent</code></li>
<li><code>--not</code></li>
<li><code>--all</code></li>
<li><code>--branches[={pattern}]</code></li>
<li><code>--tags[={pattern}]</code></li>
<li><code>--remotes[={pattern}]</code></li>
<li><code>--glob={glob-pattern}</code></li>
<li><code>--exclude={glob-pattern}</code></li>
<li><code>--reflog</code></li>
<li><code>--ignore-missing</code></li>
<li><code>--bisect</code></li>
<li><code>--stdin</code></li>
<li><code>--cherry-mark</code></li>
<li><code>--cherry-pick</code></li>
<li><code>--left-only</code></li>
<li><code>--right-only</code></li>
<li><code>--cherry</code></li>
<li><code>-g</code> <code>--walk-reflogs</code></li>
<li><code>--merge</code></li>
<li><code>--boundary</code></li>
</ul>
</li>
</ul>
<h1 id="衍合"><a href="#衍合" class="headerlink" title="衍合"></a>衍合</h1><ul>
<li><code>git rebase -i {ref}</code><br>其中 {ref} 为希望重排的提交的父提交。一般只修改提交信息或合并若干提交。若重排提交顺序或修改历史提交中的提交内容，容易发生冲突而需要大量手动解决。</li>
<li><code>git rebase [-i] {branch_to}</code><br>将当前分支衍合进目标分支。完成后原本分开的两条提交线会合并成一条。</li>
</ul>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul>
<li>remote<ul>
<li><code>git remote [-v]</code><br>查看所有远程仓库，<code>-v</code> 额外查看远程仓库的地址</li>
<li><code>git remote show {remote}</code><br>查看远程仓库的详细信息</li>
<li><code>git remote add {shortName} {url}</code><br>添加一个远程仓库，并为其指定一个简称</li>
<li><code>git remote rename {oldName} {newName}</code><br>重命名远程仓库的简称</li>
<li><code>git remote rm {remote}</code><br>移除远程仓库</li>
<li><code>git remote prune {remote}</code><br>清除本地无效的跟踪分支。</li>
</ul>
</li>
<li>clone<ul>
<li><code>git clone [-b {branch}] {url} [{specifiedName}]</code><br>从服务器上克隆仓库。可自定义本地项目的名称，可指明克隆的分支。</li>
</ul>
</li>
<li>checkout<ul>
<li><code>git checkout --track {remote}/{branch}</code><br>从远程分支检出一个跟踪分支，跟踪分支的名字默认为 branch。</li>
<li><code>git checkout -b {localBranch} {remote}/{remoteBranch}</code><br>从远程分支检出一个跟踪分支，并自定义本地分支名。</li>
</ul>
</li>
<li>fetch &amp; pull<ul>
<li><code>git fetch {remote}</code><br>更新远程仓库的信息。</li>
<li><code>git pull</code><br>获取（fetch）并合并（merge）远程分支的改动至对应的跟踪分支。</li>
</ul>
</li>
<li>push<ul>
<li><code>git push [-f] {remote} {branch}</code><br>上传到远程仓库的 branchName 分支，<code>-f</code> 表示不做检查强制重写</li>
<li><code>git push {remote} :{branch}</code> <code>git push origin --delete {branch}</code><br>删除远程的 branch 分支</li>
<li><code>git push {remote} {tag}</code><br>上传标签</li>
<li><code>git push {remote} --tags</code><br>上传所有标签</li>
</ul>
</li>
<li>branch<ul>
<li><code>git branch -r</code><br>查看远程分支</li>
</ul>
</li>
</ul>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul>
<li><code>git branch</code><br>查看本地分支</li>
<li><code>git branch -a</code><br>查看所有分支</li>
<li><code>git branch -v</code><br>查看各分支最后一次提交信息</li>
<li><code>git branch -vv</code><br>查看各分支最后一次提交信息以及对应的 upstream 分支（若有的话）</li>
<li><code>git branch --merge|--no-merged</code><br>查看已/未与当前分支合并的分支</li>
<li><code>git branch {new_branch_name} [{start_point}]</code><br>创建指定名称的新分支，可以指定起始点</li>
<li><code>git checkout {new_branch_name}</code><br>切换到指定名称的分支</li>
<li><code>git checkout -b|--orphan {new_branch_name} [{start_point}]</code><br>创建并切换到指定名称的新分支或空白的新分支。可以指定创建点，通常是 commit-id。</li>
<li><code>git branch -m|-M {old_branch} {new_branch}</code><br>重命名分支。<code>-M</code> 强制覆盖已存在的 <code>{new_branch}</code>。</li>
<li><code>git branch [-d|-D] [-r|--remotes] [{remote}/]{branch_name}</code><ul>
<li><code>-d</code>：分支已经合并到主干后删除分支；</li>
<li><code>-D</code>：强制删除。</li>
<li><code>-r|--remotes</code>：删除跟踪分支。</li>
</ul>
</li>
<li><code>git branch -u {remote}/{remote_branch} [{local_branch}]</code><br><code>git branch --set-upstream-to={remote}/{remote_branch} [{local_branch}]</code><br>对已有分支绑定跟踪分支</li>
</ul>
<h1 id="差异比较"><a href="#差异比较" class="headerlink" title="差异比较"></a>差异比较</h1><ul>
<li><code>git diff {branch1} {branch2}</code><br>查看两个分支之间的详细差异<ul>
<li><code>--stat</code> 概要信息</li>
<li><code>-- {path}</code> 指定文件</li>
</ul>
</li>
<li><code>git diff {branch1}...{branch2}</code><br>查看 branch2 分支与两个分支共同祖先之间的差异</li>
<li><code>git diff</code><br>工作区到暂存区的变化</li>
<li><code>git diff --cached|--staged</code><br>暂存区到版本库的变化</li>
<li><code>git diff HEAD</code><br>工作区到版本库的变化</li>
</ul>
<p>git维护代码分为三部分：“工作区 working directory”、“暂存区 index”、“版本库 head”（分别标注为1，2，3）。</p>
<ul>
<li><code>git add</code> 完成1-&gt;2</li>
<li><code>git commit</code> 完成2-&gt;3</li>
<li><code>git commit -a</code> 两者结合</li>
<li><code>git diff</code> 2到1的变化</li>
<li><code>git diff --cached|--staged</code> 3到2的变化</li>
<li><code>git diff HEAD</code> 3到1的变化</li>
</ul>
<h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p><code>git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit] [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]] [--[no-]allow-unrelated-histories] [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;…]</code></p>
<ul>
<li><code>--stat</code> <code>--no-stat</code> <code>-n</code> 显示/不显示合并的差异数据。</li>
<li><code>--commit</code> <code>--no-commit</code> 合并后是否自动提交。</li>
<li><code>--edit</code>/<code>-e</code> <code>--no-edit</code> 合并后是否打开编辑器（来编辑提交信息）。</li>
<li><code>--ff</code> <code>--no-ff</code> 是否使用“fast-forward”合并（若可行）。</li>
<li><code>--ff-only</code> 若不能“fast-forward”则取消合并。</li>
<li><code>-S[&lt;keyid&gt;]</code> <code>--gpg-sign[=&lt;keyid&gt;]</code> 对提交做签名。</li>
<li><code>--log[=&lt;n&gt;]</code> <code>--no-log</code> 将每个被合并的提交转换为单行描述，再将这些描述添加到此次合并的提交信息中。</li>
<li><code>--squash</code> <code>--no-squash</code> 将待合并的所有提交压缩在一起合并到当前工作区，然后需要手动提交这些改动。跟 <code>--no-ff</code> 的区别在于 <code>--squash</code> 只是合并内容，不合并提交线。</li>
<li><code>-Xours|-Xtheirs</code> 若出现冲突则直接使用当前分支/对方分支的内容。</li>
<li><code>-m &lt;msg&gt;</code> 设置此次合并的提交信息（若合并产生一个新提交的话）。</li>
</ul>
<p><code>git merge --abort</code></p>
<p>当合并发生冲突且等待用户解决时即处于合并过程中间状态，此时可以 <code>git merge --abort</code> 取消合并，冲突文件会回滚至合并操作之前的状态。</p>
<p>对于合并开始时未提交的文件，若合并开始后发生了修改，那么合并取消后这些文件可能无法正常回滚。</p>
<p><code>git merge --continue</code></p>
<p>合并发生冲突后继续合并流程（通常先解决冲突）。</p>
<h1 id="版本范围表示"><a href="#版本范围表示" class="headerlink" title="版本范围表示"></a>版本范围表示</h1><ul>
<li><code>git rev-list [--oneline] {commit}</code><br>列出指定提交和它的历史，自上而下依次为自新而旧的顺序。<ul>
<li><code>{commit}</code> 有以下额外形式。<ul>
<li><code>^{commit}</code> 排除此提交及它的历史。</li>
<li><code>{commit}^@</code> 排除提交自身，只包含历史。</li>
<li><code>{commit}^!</code> 排除历史，只包含提交本身。</li>
</ul>
</li>
<li><code>--oneline</code> 单行简明模式。相当于 <code>--pretty=oneline --abbrev-commit</code>。</li>
<li><code>--objects</code> 额外列出结果列表中所有提交包含的对象 ID。</li>
</ul>
</li>
<li><code>git rev-list  {commitA} {commitB}...</code><br>指定多个提交，列出它们各自历史的并集。</li>
<li><code>git rev-list  {commitA}..{commitB}</code><br>排除 A 及它的历史。</li>
<li><code>git rev-list {commitA}...{commitB}</code><br>排除 A 和 B 共同的历史。A 和 B 的书写顺序无关。相当于 <code>A B --not $(git merge-base --all A B)</code>。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><code>ssh-keygen -C myemail -t rsa</code><br>创建 ssh 密钥</li>
<li><code>git gc</code><br>压缩松散对象</li>
<li><code>git cherry-pick {SHA-1}</code><br>将指定提交的代码引入当前分支</li>
<li><code>{ref}^[n]</code><br>引用 {ref} 的父提交，或第 n 父提交（只在合并提交时有用）</li>
<li><code>{ref}~[n]</code><br>引用 {ref} 的第一父提交，或第一父提交的第一父提交……</li>
<li><code>git blame [-C] [-L m,n] {file}</code><br>查看文件内容的最近修改者。<code>-C</code> 可查看文本行的来源文件（如果该行是复制过来的话）；<code>-L m,n</code> 将查看范围限制在第 m ~ n 行</li>
<li><code>gitk --all</code> 包括全部分支</li>
</ul>
<h1 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h1><h2 id="统计对象"><a href="#统计对象" class="headerlink" title="统计对象"></a>统计对象</h2><ul>
<li><code>git count-objects [-v|--verbose] [-H|--human-readable]</code><ul>
<li><code>-v|--verbose</code><ul>
<li><code>count</code> 松散对象数量。</li>
<li><code>size</code> 松散对象占用的空间，单位 KB。</li>
<li><code>in-pack</code> 打包的对象数量。</li>
<li><code>size-pack</code> 打包对象占用的空间，单位 KB。</li>
<li><code>prune-packable</code> 既有松散形式又有打包形式存在的对象数量。可用 <code>git prune-packed</code> 清理。</li>
<li><code>garbage</code> 既不是有效的松散对象，又不是有效的打包对象，的对象数量。</li>
<li><code>size-garbage</code> garbage 对象占用的空间，单位 KB。</li>
<li><code>alternate</code> alternate 对象数据库的绝对路径。若路径中包含不可打印字符，则会被双引号和 C 风格的转义符号替换。</li>
</ul>
</li>
<li><code>-H|--human-readable</code> 易读形式。</li>
</ul>
</li>
</ul>
<h2 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h2><p>已知文件名的话可以跳过 1 和 2。不介意遍历整个历史的话可以跳过 3。</p>
<ol>
<li>找出大文件对应的对象的 ID</li>
</ol>
<p><code>git verify-pack -v .git/objects/pack/pack-123...abc.idx | sort -k 3 -n | tail -3</code></p>
<p>显示最大的几个对象。<code>verify-pack -v</code> 按以下格式输出打包对象的信息。其中最后两列是对于被分层的对象而言的。</p>
<blockquote>
<p>SHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1</p>
</blockquote>
<ol>
<li>找出该对象对应的文件名</li>
</ol>
<p><code>git rev-list --objects --all | grep abc123</code></p>
<ol>
<li>找出哪些提交修改了该文件</li>
</ol>
<p><code>git log --pretty=oneline -- {file}</code></p>
<p>输出结果中最下面的是最早的提交。</p>
<ol>
<li>删除文件，重写历史</li>
</ol>
<p><code>git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch {file}&#39; -- abc123^..</code></p>
<p>也可以不用 <code>-- abc123^..</code>，那样的话会遍历全部历史。</p>
<ol>
<li>删除其他对该文件的引用</li>
</ol>
<p><code>reflog</code> 以及 <code>filter-branch</code> 时会在 <code>.git/refs/original</code> 中添加一些引用，其中仍包含对该文件的引用。</p>
<ul>
<li><code>rm -Rf .git/refs/original</code></li>
<li><code>rm -Rf .git/logs/</code></li>
<li><code>git gc</code></li>
</ul>
<ol>
<li>现在该文件的对象只存在于松散对象中，不会被推送出去。可以彻底删除它</li>
</ol>
<p><code>git prune --expire</code></p>
<h1 id="文件状态生命周期"><a href="#文件状态生命周期" class="headerlink" title="文件状态生命周期"></a>文件状态生命周期</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">untracked-&gt;unmodified:add the file</span><br><span class="line">unmodified-&gt;modified:edit the file</span><br><span class="line">modified-&gt;staged:stage the file</span><br><span class="line">staged-&gt;unmodified:commit</span><br><span class="line">unmodified-&gt;untracked:remove the file</span><br></pre></td></tr></table></figure>
<h1 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h1><p>3 个级别：local &gt; global &gt; system</p>
<ol>
<li>local：位于仓库下的 <code>.git/config</code></li>
<li>global：位于 <code>~/.gitconfig</code></li>
<li>system：位于 <code>{Git 安装目录}/mingw64/etc/gitconfig</code></li>
</ol>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p><code>user.name &quot;John&quot;</code><br><code>user.email John@example.com</code><br>配置用户信息。不加 <code>--global</code> 则仅对当前项目有效（.git/config），加上 <code>--global</code> 则全局有效（C:/Users/$USER/.gitconfig）。提交的时候会用到用户信息。</p>
<p><code>user.signingkey {gpg-key-id}</code><br>GPG 签署密钥，用来创建经签署的含附注的标签。</p>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p><code>core.editor emacs</code><br>配置文本编辑器。其中 emacs 可以换成其他编辑器的名字。</p>
<p><code>core.pager {pager}</code><br>运行诸如 log、diff 等所使用的分页器，可设置为 more 或任何其他分页器（缺省为 less），设置为空字符串’’则会在一页显示所有内容。</p>
<p><code>core.excludesfile {files}</code><br>无需纳入 Git 管理的文件，类似 .gitignore 文件。</p>
<p><code>core.autocrlf true|false|input</code><br>换行符转换。</p>
<ul>
<li>true：提交时 CRLF -&gt; LF；签出时 LF -&gt; CRLF</li>
<li>false：不做改变</li>
<li>input：提交时 CRLF -&gt; LF；签出时不做改变</li>
</ul>
<p><code>core.safecrlf true|false|warn</code><br>提交包含混合换行符的文件时的行为</p>
<ul>
<li>true：拒绝提交包含混合换行符的文件</li>
<li>false：允许提交包含混合换行符的文件</li>
<li>warn：提交包含混合换行符的文件时给出警告</li>
</ul>
<p><code>core.whitespace {var1,var2,...,varn}</code><br>探测和修正空白问题的选项。在某个参数前加上 <code>-</code> 表示禁用。</p>
<ul>
<li><code>blank-at-eol</code>：将行尾的空格作错误来处理（缺省开启）。</li>
<li><code>space-before-tab</code>：将位于行首缩进部分的 tab 符号前的空格作错误来处理（缺省开启）。</li>
<li><code>indent-with-non-tab</code>：将用空格来缩进而非用 tab 符号的行作为错误来处理（缺省关闭）。</li>
<li><code>tab-in-indent</code>：将行首缩进部分存在 tab 符号的行作为错误来处理（缺省关闭）。</li>
<li><code>blank-at-eof</code>：将文件末尾的空白行作为错误来处理（缺省开启）。</li>
<li><code>trailing-space</code>：包含了 <code>blank-at-eol</code> 和 <code>blank-at-eof</code>。</li>
<li><code>cr-at-eol</code>：将行尾的回车符 cr 当作行结尾的一部分，也就是说，行尾回车符前若存在空白符不会触发 <code>trailing-space</code>。</li>
<li><code>tabwidth=&lt;n&gt;</code>：设定 1 个 tab 符号占几个空格；此项与 <code>indent-with-non-tab</code> 和 <code>tab-in-indent</code> 相关。缺省为 8。允许范围为 1 到 63。</li>
</ul>
<p><code>core.quotepath</code><br>是否对文件路径中的非拉丁字符进行转义。</p>
<h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p><code>help.autocorrect {1|0}</code><br>若设成 1，则在只有一个命令被模糊匹配到的情况下，Git 会自动运行该命令。</p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p><code>merge.tool vimdiff</code><br>配置差异分析工具。可选的还有 kdiff3、tkdiff、meld、xxdiff、emerge、vimdiff、gvimdiff、ecmerge、opendiff 等。</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p><code>commit.template {file}</code><br>提交时使用的模板文件。</p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>push.default</code><br>push 时的默认行为。Git2.0 之前默认使用 <code>matching</code>，之后默认使用 <code>simple</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=&#123;remote&#125;/&#123;branch&#125; [&#123;local_branch&#125;]</span><br><span class="line">// 或者 git branch -u &#123;remote&#125;/&#123;branch&#125; [&#123;local_branch&#125;]</span><br><span class="line">// 或者 git push --set-upstream &#123;remote&#125; [&#123;local_branch&#125;:]&#123;remote_branch&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>nothing</code>：push 操作无效，除非显式指定远程分支：<code>git push origin develop</code>。</li>
<li><code>current</code>：push 当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。</li>
<li><code>upstream</code>：push 当前分支到它的 <a href="#git中的upstream和downstream">upstream</a> 分支上（这一项其实用于经常从本地分支 push/pull 到同一远程仓库的情景，这种模式叫做 central workflow）。</li>
<li><code>simple</code>：simple 和  upstream 是相似的，只有一点不同，simple 必须保证本地分支和它的远程 upstream 分支同名，否则会拒绝 push 操作。</li>
<li><code>matching</code>：push 所有本地和远程两端都存在的同名分支。</li>
</ul>
<h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p><code>branch.{branch_name}.merge</code><br>merge 时的默认操作。在 pull 的时候也会用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[branch &quot;develop&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/develop</span><br></pre></td></tr></table></figure>
<p>或者通过 bash 设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config branch.develop.merge refs/heads/develop</span><br></pre></td></tr></table></figure>
<p>为什么不是refs/remotes/develop？</p>
<blockquote>
<p>因为这里 merge 指代的是我们想要 merge 的远程分支，是站在远程仓库的角度看到的引用路径。<br> 在本地仓库来看，远程仓库的分支引用路径为 <code>refs/remotes/{branch}</code>；站在远程仓库的角度来看，这个分支引用路径自然就是 <code>refs/heads/{branch}</code>。<br> 和我们在本地直接执行 <code>git merge</code> 是不同的（本地执行 <code>git merge origin/develop</code> 则是直接 merge refs/remotes/develop）。</p>
</blockquote>
<h2 id="credential"><a href="#credential" class="headerlink" title="credential"></a>credential</h2><p>各 credential 工具都有 3 个操作：</p>
<ul>
<li><code>get</code> 查找匹配的密令。</li>
<li><code>store</code> 存储密令。</li>
<li><code>erase</code> 删除匹配的密令。</li>
</ul>
<p>以上操作需要按照特定格式输入参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git credential-&#123;helper&#125; &#123;operation&#125; (1)</span><br><span class="line">protocol=https (2)</span><br><span class="line">host=example.com</span><br><span class="line">username=tom</span><br><span class="line">password=abc (3)</span><br><span class="line">(4)</span><br></pre></td></tr></table></figure>
<ul>
<li>(1)：{helper} 是具体的 credential 工具，比如 store；{operation} 是 <code>get</code>、<code>store</code>、<code>erase</code> 之一。</li>
<li>(2)：协议、主机等参数。</li>
<li>(3)：用户名、密码参数可选，取决于是什么操作。</li>
<li>(4)：参数输入完毕后连续两个换行表示录入完成。</li>
</ul>
<p>windows 默认用的是 <code>manager</code>（见 <code>C:\Program Files\Git\mingw64\etc\gitconfig</code>）。改用其他工具后仍然会从 <code>manager</code> 中取密令，要用 <code>erase</code> 操作先移除。不知道是不是 bug。</p>
<h3 id="静态配置用户名"><a href="#静态配置用户名" class="headerlink" title="静态配置用户名"></a>静态配置用户名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential &quot;https://example.com&quot;]</span><br><span class="line">  username = tom</span><br></pre></td></tr></table></figure>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p><code>git config credential.helper &#39;cache [{opts}]&#39;</code></p>
<ul>
<li><code>--timeout {seconds}</code> 默认 900.</li>
<li><code>--socket {path}</code><br>通过 {path} 来跟负责缓存的守护进程交互。默认是 <code>$XDG_CACHE_HOME/git/credential/socket</code>，除非 <code>~/.git-credential-cache/</code> 存在，那就用 <code>~/.git-credential-cache/socket</code></li>
</ul>
<p><code>git credential-cache exit</code> 手动退出，缓存的密码会消失。</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><code>git config credential.helper &#39;store [{opts}]&#39;</code></p>
<p>明文存储在磁盘上。形如 <code>http://{user}:{pwd}@example.com/</code>。</p>
<ul>
<li><code>--file={path}</code><br>指定文件。默认查找 <code>~/.git-credentials</code> 和 <code>$XDG_COFNIG_HOME/git/credentials</code>。</li>
</ul>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p><code>git config --list</code><br>查看配置信息。其中重复的变量来自不同的配置文件，Git 会采用最后一个。</p>
<p><code>git config user.name</code><br>查看特定变量。</p>
<h1 id="git-help"><a href="#git-help" class="headerlink" title="git help"></a>git help</h1><p><code>git help {verb}</code><br><code>git {verb} --help</code><br><code>man git-{verb}</code><br>查看特定命令 <code>{verb}</code> 的帮助信息。</p>
<h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><p><em>查看标签</em></p>
<ul>
<li><code>git tag [-n[{num}]] -l [--contains {commit}] [--points-at {object}] [--column[={options}] | --no-column] [--create-reflog] [--sort={key}] [--format={format}] [--[no-]merged [{commit}]] [{pattern}…]</code><ul>
<li><code>无参数</code> 查看当前版本库的标签列表。</li>
<li><code>-n{num}</code> 查看所有标签及对应的注释。通过 {num} 来指定显示多少行注释；缺省只显示注释的第一行。若某标签无注释，则显示其对应的提交信息。</li>
<li><code>-l {pattern}</code> 利用通配符对标签名进行过滤。若未给出通配符，则显示所有标签；若给出多个通配符，则标签只要匹配其中之一就会显示。</li>
<li><code>--contains {commit}</code> 只列出指定提交上的标签，缺省为 HEAD。</li>
<li><code>--points-at {object}</code> 只列出指定对象上的标签。</li>
<li><code>--column[={options}]</code> <code>--no-column</code> 分别表示“总是”、“总不”以列形式展示标签。只在显示不带注释的标签时有效。其中 {options} 包括：<ul>
<li>以下选项控制开关<ul>
<li><code>always</code> 总是以列形式显示。</li>
<li><code>never</code> 总不以列形式显示。</li>
<li><code>auto</code> 若输出到终端，则以列形式显示。</li>
</ul>
</li>
<li>以下选项控制布局，缺省为<code>column</code>。若出现以下任一选项，而上述3个选项未出现，则默认为<code>always</code>。<ul>
<li><code>column</code> 先填充列，后填充行。</li>
<li><code>row</code> 先填充行，后填充列。</li>
<li><code>plain</code> 显示在一列。</li>
</ul>
</li>
<li>以下选项可与上述布局选项混合使用，缺省为<code>nodense</code>。<ul>
<li><code>dense</code> 列宽不相等。</li>
<li><code>nodense</code> 列宽相等。</li>
</ul>
</li>
</ul>
</li>
<li><code>--create-reflog</code> 为标签创建操作记录。</li>
<li><code>--sort={key}</code> 按照 {key} 对显示结果进行升序排列。通过添加<code>-</code>前缀来进行降序排列。若指定多个 {key}，则最后一个 {key} 将作为主键。缺省为<code>tag.sort</code>的值，否则就按字典顺序。</li>
<li><code>--format={format}</code> A string that interpolates %(fieldname) from the object pointed at by a ref being shown. The format is the same as that of git-for-each-ref(1). When unspecified, defaults to %(refname:strip=2).</li>
<li><code>--[no-]merged [{commit}]</code> Only list tags whose tips are reachable, or not reachable if –no-merged is used, from the specified commit (HEAD if not specified).</li>
</ul>
</li>
</ul>
<p><strong>创建标签</strong></p>
<ul>
<li><code>git tag [-a | -s | -u {keyid}] [-f] [-m {msg} | -F {file}] {tagname} [{commit} | {object}]</code><ul>
<li><code>无参数</code> 创建轻量级标签。该标签指向一个提交，无标签创建过程记录。</li>
<li><code>-a</code> 创建一个无签名的、带注释的标签。带注释的标签指向一个标签对象（而不是一个提交），该对象中包含了创建标签时的说明、对应的提交 ID 等信息。</li>
<li><code>-s</code> 创建一个 GnuPG 签名的、带注释的标签，使用默认 e-mail 地址作为公钥/私钥对。</li>
<li><code>-u {keyid}</code> 创建一个 GnuPG 签名的、带注释的标签，使用指定的 {keyid} 作为公钥/私钥对。</li>
<li><code>-m {msg}</code> 若创建的是带注释的标签，则必须使用 <code>-m {msg}</code> 参数来创建该标签的注释。若使用了 <code>-m {msg}</code> 而未使用 <code>-a</code>、<code>-s</code> 或 <code>-u {keyid}</code>，则会隐含使用 <code>-a</code>。</li>
<li><code>-F {file}</code> 读取指定文件的内容作为标签注释。<code>-F -</code> 表示从标准输入中读取注释。若使用了 <code>-F {file}</code> 而未使用 <code>-a</code>、<code>-s</code> 或 <code>-u {keyid}</code>，则会隐含使用 <code>-a</code>。</li>
</ul>
</li>
</ul>
<p><strong>删除标签</strong></p>
<ul>
<li><code>git tag -d {tagname}...</code></li>
</ul>
<p><strong>校验标签</strong></p>
<ul>
<li><code>git tag -v {tagname}...</code> 校验指定标签的 GnuPG 签名。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>git show {tagname}</code> 查看指定标签的详细信息。</li>
<li><code>git log --decorate</code> 在查看日志时显示提交对应的标签及其他引用。</li>
<li><code>git describe [{commit}]</code> 将提交显示为一个易记的名字。该名字来自于建立于该提交之上的标签。<ul>
<li>若该提交存在标签，则显示该标签的名字。</li>
<li>若该提交没有标签，则显示其最近一个存在标签的历史版本的标签名，并以 <code>{tag}-{num}-g{commit}</code> 的格式显示。其中 {tag} 是该历史版本的标签名，{num} 是该历史提交与所查提交之间的距离，{commit} 是所查提交的精简 ID。</li>
<li><code>--dirty</code> 加上该参数后，若工作区的文件被修改过，则会在标签名后面显示“-dirty”。</li>
</ul>
</li>
</ul>
<h1 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h1><p>在 <code>.git</code> 同级目录下，手动创建 <code>.gitignore</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> # 井号表示注释</span><br><span class="line"> # 文件名/目录名中可用正则表达式</span><br><span class="line"></span><br><span class="line"> # 指定忽略某个文件</span><br><span class="line">abc.txt</span><br><span class="line"></span><br><span class="line"> # 指定忽略某个目录</span><br><span class="line">abc/</span><br><span class="line"></span><br><span class="line"> # 指定不忽略某个文件/目录</span><br><span class="line">!def.txt</span><br><span class="line">!def/</span><br><span class="line"></span><br><span class="line"> # 指定忽略某一类文件</span><br><span class="line">*.doc</span><br><span class="line"> # 使用标准的 glob 模式匹配</span><br><span class="line">*.[ch]</span><br></pre></td></tr></table></figure>
<h1 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h1><p><strong>乱码情景1</strong></p>
<p>在 cygwin 中，使用 <code>git add</code> 添加要提交的文件的时候，如果文件名是中文，会显示形如 <code>\274\232\350\256\256\346\200\273\347\273\223.png</code> 的内部码点形式。</p>
<p>解决方案：</p>
<p>在 bash 提示符下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure></p>
<p>core.quotepath 设为 false 的话，就不会对 0x80 以上的字符进行 quote。中文显示正常。</p>
<p><strong>乱码情景2</strong></p>
<p>在 MsysGit 中，使用 <code>git log</code> 显示提交的中文 log 乱码。</p>
<p>解决方案：</p>
<ul>
<li><p>设置 git gui 的界面编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 commit log 提交时使用 utf-8 编码，可避免服务器上乱码，同时与 linux上 的提交保持一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config –global i18n.commitencoding utf-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>使得在 <code>git log</code> 时将 utf-8 编码转换成 gbk 编码，解决Msys bash中 <code>git log</code> 乱码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config –global i18n.logoutputencoding gbk</span><br></pre></td></tr></table></figure>
</li>
<li><p>使得 <code>git log</code> 可以正常显示中文（配合 <code>i18n.logoutputencoding = gbk</code>)，在 <code>/etc/profile</code> 中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>乱码情景3</strong></p>
<p>在 MsysGit 自带的 bash 中，使用 <code>ls</code> 命令查看中文文件名乱码。cygwin 没有这个问题。</p>
<p>解决方案：</p>
<p>使用 <code>ls --show-control-chars</code> 命令来强制使用控制台字符编码显示文件名，即可查看中文文件名。<br>为了方便使用，可以编辑 <code>/etc/git-completion.bash</code>，新增一行 <code>alias ls=&quot;ls --show-control-chars&quot;</code></p>
<p><strong>乱码情景4</strong></p>
<p>使用 <code>$GIT_HOME/bin/bash.exe</code> 和 <code>$GIT_HOME/git-cmd.exe</code> 执行 <code>git log</code> 中文呈乱码，而在 <code>git-bash.exe</code> 中不会。</p>
<p>解决方案：</p>
<ol>
<li>添加环境变量 <code>LESSCHARSET=utf-8</code></li>
<li>若是在 IDEA 的控制台功能使用上述两个终端软件，则需要在 <code>设置-Tools-Terminal-Environment Variables</code> 中添加上述变量。</li>
</ol>
<p><strong>终极解决方案</strong></p>
<p>终极的解决方案是通过修改 git 和 TortoiseGit 源码实现，有网友这么做了：[让Windows下Git和TortoiseGit支持中文文件名/UTF-8][3] ，也可以直接访问这个开源的 Google 项目：[utf8-git-on-windows][4] 。<br>如果不抗拒命令行的话，直接用 Cygwin 来提交Git库。因为 Cygwin 其实是一个在 Windows 平台上的模拟器，它完全模拟 GNU/Linux 的方式运行，所以 Cygwin 中的 Git 是采用 UTF-8 编码来保存中文的。</p>
<h1 id="git-中的-upstream-和-downstream"><a href="#git-中的-upstream-和-downstream" class="headerlink" title="git 中的 upstream 和 downstream"></a>git 中的 upstream 和 downstream</h1><p>git 中存在 upstream 和 downstream，简言之，当我们把仓库 A 中某分支 x 的代码 push 到仓库 B 分支 y，此时仓库 B 的这个分支 y 就叫做 A 中 x 分支的 upstream，而 x 则被称作 y 的 downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的 upstream 分支（注意这个 upstream 分支可以不同名，但通常我们都会使用同名分支作为 upstream）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zeerho</p>
              <p class="site-description motion-element" itemprop="description">Just a repo for documents</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZephyrHuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zephyrhuang21@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeerho</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
