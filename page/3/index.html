<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Just a repo for documents">
<meta property="og:type" content="website">
<meta property="og:title" content="Tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="zeerho">
<meta property="og:description" content="Just a repo for documents">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-05T02:37:10.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tags">
<meta name="twitter:description" content="Just a repo for documents">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/"/>





  <title>zeerho</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zeerho</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/Java/由HashMap和HashTable说开/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/Java/由HashMap和HashTable说开/" itemprop="url">由HashMap和HashTable说开</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T22:55:16+08:00">2018-03-14</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h1><ul>
<li>父类不同，不过这点不重要。</li>
<li>HashMap 的键、值可为 null，HashTable 都不行。</li>
<li>HashMap 非线程安全，HashTable 通过在所有闭包方法上加上 synchronized 关键词来实现线程安全。</li>
<li>基于上一点，HashMap 的速度要明显更快。</li>
</ul>
<p>除了这些区别外，还有一些细节的但是重要的区别。</p>
<p>两者都是立足在哈希的基础上实现快速查找。两者的哈希方法有所不同。</p>
<p><strong>HashMap</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// java8 之前多做了几次混淆</span></span><br><span class="line">    <span class="comment">// h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span></span><br><span class="line">    <span class="comment">// return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashTable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>
<p>HashTable 做了一次模运算，略慢一点。</p>
<p>HashMap 混淆了高低位的信息之后对低位进行掩码，而 HashTable 的散列程度直接取决于整体的哈希值的散列程度。也就是说，要实现相同的散列程度，HashTable 对于 key 对象本身的  hashCode() 方法要求更高。</p>
<h1 id="对象的-hashCode-方法"><a href="#对象的-hashCode-方法" class="headerlink" title="对象的 hashCode() 方法"></a>对象的 hashCode() 方法</h1><h2 id="hashCode-的抽象定义"><a href="#hashCode-的抽象定义" class="headerlink" title="hashCode() 的抽象定义"></a>hashCode() 的抽象定义</h2><p>hashCode() 方法是散列算法的一个实现。散列算法的本质是在两个集合之间建立映射关系。之所以可以通过散列实现快速搜索定位，是因为：</p>
<ol>
<li><p>原象集的空间往往是非常大，甚至是无穷的，但实际应用中可以通过某种途径（比如经验、推算）认为只会用到原象集的一个有限子集，这样将原象集映射到一个子集，缩小搜索空间。</p>
</li>
<li><p>有时候因为当前技术的限制，无法快速对原象集中的元素进行信息抽取，因此寻找一个方便抽取信息的象集，并在两者之间建立映射。</p>
</li>
</ol>
<p>以上两点典型的应用就是 Java 中对象跟整数之间的映射。</p>
<p>最理想的散列算法是在原象集和象集之间建立满射，这样实际上只用到了上述第 2 点，但这种理想情况很少（至少我还没注意到过）。</p>
<p>次理想的算法有两种：满射非单射、单射非满射。前者是用时间换空间，后者是用空间换时间。这两种设计方式并不互斥，Java 中的 HashMap 和 HashTable 就是这种设计（当然可能还有其他类）。</p>
<p>Java 根类 <code>Object</code> 中对 hashCode() 方法的设计有详细描述。关键点有：</p>
<ol>
<li>此方法建立的是非满射非单射关系——业务上相同的对象应该映射到相同的整数，业务上不同的对象有可能映射到相同的整数。此外还有一个隐含的但是比较显而易见的点——并没有强制要求完全利用整个 Java 整数空间，因为业务对象的枚举完全可能没那么多。</li>
<li>对于没有重写此方法的类，用的是 Java 默认的逻辑——将对象的内存地址映射成一个整数。也就是说业务上相同的两个对象会映射到不同的整数。</li>
</ol>
<h2 id="常用的散列算法"><a href="#常用的散列算法" class="headerlink" title="常用的散列算法"></a>常用的散列算法</h2><h3 id="除法散列算法"><a href="#除法散列算法" class="headerlink" title="除法散列算法"></a>除法散列算法</h3><blockquote>
<p>index = value % divisor</p>
</blockquote>
<h3 id="平方散列算法"><a href="#平方散列算法" class="headerlink" title="平方散列算法"></a>平方散列算法</h3><blockquote>
<p>index = (value * value) &gt;&gt; num</p>
</blockquote>
<h2 id="String-的-hashCode"><a href="#String-的-hashCode" class="headerlink" title="String 的 hashCode()"></a>String 的 hashCode()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>容易理解的一点就是每个字符都参与了运算，因此最后结果包含了每个字符的信息。</p>
<p>这里的乘数 31 是个关键点。之所以选 31 有几个明显的原因：</p>
<ol>
<li>会被 Java 底层优化成 (h &lt;&lt; 5) - h。</li>
<li>质数作为乘数减小乘积冲突的概率。（最后散列值是否冲突很大程度上取决于散列算法，而乘积是否冲突只是一个前置因素，很难简单地推测乘积冲突对于散列结果的影响，因此这一点原因不是很重要，基本上只是出于习惯）</li>
<li>31 大小适中：若乘数较大，则更多字符串的乘积会大于整数上限，截取低 31 位相当于在一个大集合中选中一个真子集，因而导致信息丢失，继而增大冲突概率；若乘数较小，则更多字符串的乘积挤在整数空间里，不利于均匀分摊。</li>
</ol>
<p>关于上述第 3 点，这里只是定性描述。实际上选取 31 是经过了对一批数字进行筛选评估之后的结果。</p>
<p><strong>从 String 的例子可以总结几点设计 hashCode() 方法的要点：</strong></p>
<ul>
<li>运算简单；</li>
<li>每一个影响两个对象是否相同的成员都要参与散列运算；</li>
<li>综合评估对象所处集合的规模，既要充分利用整数空间，又要尽量避免数位溢出导致信息丢失。</li>
</ul>
<h2 id="Effective-Java-中的指导性建议"><a href="#Effective-Java-中的指导性建议" class="headerlink" title="Effective Java 中的指导性建议"></a>Effective Java 中的指导性建议</h2><ol>
<li>把某个非零的常数值保存在一个名为 result 的 int 型变量中。</li>
<li>对于对象中每个关键域 f（指 equals 方法中涉及的每个域），完成以下步骤：<ol>
<li>为该域计算 int 型的散列码 c：<ol>
<li>如果该域是 boolean 类型，则计算 <code>(f ? 1 : 0)</code>。</li>
<li>如果该域是 byte、char、short 或者 int 类型，则计算 <code>(int)f</code>。</li>
<li>如果该域是 long 类型，则计算 <code>(int)(f ^ (f &gt;&gt;&gt; 32))</code>。</li>
<li>如果该域是 float 类型，则计算 <code>Float.floatToIntBits(f)</code>。</li>
<li>如果该域是 double 类型，则计算 <code>Double.doubleToLongBits(f)</code>，然后按照步骤 2.1.3，为 long 类型计算散列值。</li>
<li>如果该域是一个对象引用，并且该类的 equals 方法通过递归地调用 equals 的方式来比较这个域，则同样为这个域递归地调用 hashCode。如果需要更复杂的比较，则为这个域计算一个“范式（canonical representation）”，然后针对这个范式调用 hashCode。如果这个域的值为 null，则返回一个常数（通常是 0）。</li>
<li>如果该域是一个数组，则要把每一个元素当作单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据 2.2 中的做法把这些散列值组合起来。如果数组域中的每个元素都很重要，可以利用 Java 1.5 新增的 <code>Arrays.hashCode</code> 方法。</li>
<li>把 2.1 中计算得到的散列码 c 合并到 result 中 <code>result = 31 * result + c</code>。</li>
<li>检查“相等的实例是否都具有相等的散列码”。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="关于设计-hashCode-方法的一点补充"><a href="#关于设计-hashCode-方法的一点补充" class="headerlink" title="关于设计 hashCode() 方法的一点补充"></a>关于设计 hashCode() 方法的一点补充</h2><p>优秀的散列算法不光要完成两个集合的映射，还要尽量在映射的过程中均摊每个元素的出现概率，也就是调整每个元素提供的信息量。</p>
<p>拿英文字母举个例子。ASCII 码中，对应的两个大小写字母之间只有第 6 位比特存在区别（比如A=0100 0001，a=0110 0001）。在实际应用中，小写字母出现的概率要明显大于大写字母。因此第 6 位比特携带的信息量就较小，需要在映射过程中从其他比特均摊一部分信息量过来。</p>
<p>除此之外，如果只考虑大写（或小写）字母，每个字母出现的概率也是不同的。总之基本思路就是要将原象集中概率不同的元素尽量映射成象集中概率接近的元素。</p>
<h1 id="散列冲突的解决办法"><a href="#散列冲突的解决办法" class="headerlink" title="散列冲突的解决办法"></a>散列冲突的解决办法</h1><p>绝大多数情况下，散列空间中的元素冲突只是概率大小的问题，无法完全避免。解决冲突的办法主要有几种：</p>
<ul>
<li>线性再散列法</li>
<li>非线性再散列法</li>
<li>外部拉链法</li>
</ul>
<h2 id="线性再散列法（开放定址法）"><a href="#线性再散列法（开放定址法）" class="headerlink" title="线性再散列法（开放定址法）"></a>线性再散列法（开放定址法）</h2><p>主体思路就是当遇到冲突时，按照某个移动步长在集合中搜索下一个位置，一直到找到空位。</p>
<p>根据所定的步长的不同，又分为</p>
<ul>
<li>线性探查法：步长固定为 1。</li>
<li>线性补偿探查法：步长为 Q，要求 Q 与集合长度 m 互质（为了最终能遍历所有元素）。</li>
<li>随机探查法：步长随机。</li>
</ul>
<p>3 种方法半斤八两，没有本质区别，都会导致以下问题：</p>
<ul>
<li>在散列程度差的元素附近形成堆聚。</li>
<li>劣币驱逐良币：散列程度差的元素挤占了原本属于散列程度好的元素的位置，导致后者不得不去挤占别人的位置，进而也变成了“坏元素”。</li>
<li>删除元素的时候不能物理删除，只能逻辑删除，因为后面进来的元素的位置取决于前面“占坑”的元素。若物理删除了前面某个“占坑”的元素，则显然没法正确找到后面想找的元素。</li>
<li>随着冲突概率的增大、空间占用的增多，在集合中遍历所花费的时间迅速增长。</li>
</ul>
<h2 id="非线性再散列法"><a href="#非线性再散列法" class="headerlink" title="非线性再散列法"></a>非线性再散列法</h2><p>遇到冲突时就对当前散列值再做一次散列，直到找到空位。其实就是用非线性的运算计算步长。跟线性再散列法没有本质区别。除了拥有线性再散列法的缺点外，还隐性地把性能依赖于散列算法本身的性能。</p>
<h2 id="外部拉链法"><a href="#外部拉链法" class="headerlink" title="外部拉链法"></a>外部拉链法</h2><p>比较常用的办法，也是 HashMap 和 HashTable 使用的办法。</p>
<p>每个元素保存的不是单个业务对象，而是一个由若干个具有相同散列值的业务对象组成的列表（一般都是用单链表，方便频繁的增删操作）。</p>
<p>外部拉链法的缺点是需要更多的空间。不过现在内存空间很充裕，反而时间成本越来越高，所以绝大部分情况下都算不上问题。</p>
<p>另外，我注意到 HashMap 和 HashTable 在插入新元素的时候都是插到链表头部。可是在实际插入新元素之前肯定是已经遍历了整个链表，确定没有 equals 的对象，这时已经拿到了尾端节点的引用，只要做一次引用赋值就能插到链表尾端，为什么还要在链表头部做两次引用赋值？初步猜测是因为设计者觉得多一次引用赋值的开销可以忽略，而新插入的元素往往具有更高的访问概率，插在头部减小链表遍历的期望值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/01/Java/Spring任务调度和异步执行器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/Java/Spring任务调度和异步执行器/" itemprop="url">Spring任务调度和异步执行器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T09:00:00+08:00">2018-03-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-5-0-的-Executor"><a href="#Java-5-0-的-Executor" class="headerlink" title="Java 5.0 的 Executor"></a>Java 5.0 的 Executor</h1><p><code>java.util.concurrent.Executor</code> 接口将“任务提交”和“任务执行”分离解耦。</p>
<p>它有两个子接口：</p>
<ul>
<li><code>ExecutorService</code>：添加了结束任务的管理方法，在提交任务时还可以获取一个 <code>Future</code> 实例，通过该实例跟踪异步任务的情况。<ul>
<li><code>TreadPoolExecutor</code> 实现了 <code>Executor</code> 和 <code>ExecutorService</code> 两个接口，它使用一个线程池对任务进行调度。</li>
</ul>
</li>
<li><code>ScheduledExecutorService</code>：可以进行任务调度，比如指定延迟时间和执行周期。<ul>
<li><code>ScheduledThreadPoolExecutor</code> 是 <code>ThreadPoolExecutor</code> 的子类，实现了 <code>ScheduledExecutorService</code> 接口，对任务添加了调度功能。</li>
</ul>
</li>
</ul>
<p><code>java.util.concurrent</code> 中为创建上述接口实例提供了一个工厂类 <code>Executors</code>：</p>
<ul>
<li><code>ExecutorService newFixedThreadPool(in nThreads)</code>：创建一个线程池；</li>
<li><code>ExecutorService newCachedThreadPool()</code>：动态线程池，不够用时创建新线程，长时间闲置的线程被回收；</li>
<li><code>ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code>：创建一个线程池，可指定延迟和周期。</li>
</ul>
<p>Spring 的 <code>TaskExecutor</code> 接口等同于 <code>java.util.concurrent.Executor</code> 接口。Spring 提供了一些实现类：</p>
<ul>
<li><code>SyncTaskExecutor</code>：直接在主线程中执行。</li>
<li><code>SchedulingTaskExecutor</code>：子接口，提供了调度功能。<ul>
<li><code>SimpleAsyncTaskExecutor</code>：每次执行创建新线程，但支持对并发总数的限制，超出部分会被阻塞。</li>
<li><code>ConcurrentTaskExecutor</code>：是 Java 5.0 的 <code>Executor</code> 的适配器。</li>
<li><code>SimpleThreadPoolTaskExecutor</code>：是 Quartz 的 <code>SimpleThreadPool</code> 的子类，负责监听 Spring 的生命周期回调。当需要在 Quartz 和非 Quartz 组件中共享线程池时使用。</li>
<li><code>ThreadPoolTaskExecutor</code>：只能在 Java 5.0 中使用。它暴露了一些属性，方便在 Spring 中配置一个 <code>java.util.concurrent.ThreadPoolExecutor</code>，并包装成 <code>TaskExecutor</code>。</li>
<li><code>TimerTaskExecutor</code>：使用一个 Timer 作为后台实现。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/Java/Java 核心/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/Java/Java 核心/" itemprop="url">Java 核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T09:00:00+08:00">2018-02-25</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>基本类型直接存储值，并置于堆栈中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
<th style="text-align:left">包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">Boolean</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">16</td>
<td style="text-align:left">Unicode 0</td>
<td style="text-align:left">Unicode 2^16-1</td>
<td style="text-align:left">Character</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">8</td>
<td style="text-align:left">-128</td>
<td style="text-align:left">+127</td>
<td style="text-align:left">Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">16</td>
<td style="text-align:left">-2^15</td>
<td style="text-align:left">+2^15-1</td>
<td style="text-align:left">Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">32</td>
<td style="text-align:left">-2^31</td>
<td style="text-align:left">+2^31-1</td>
<td style="text-align:left">Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">64</td>
<td style="text-align:left">-2^63</td>
<td style="text-align:left">+2^63-1</td>
<td style="text-align:left">Long</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">32</td>
<td style="text-align:left">IEEE 754</td>
<td style="text-align:left">IEEE 754</td>
<td style="text-align:left">Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">64</td>
<td style="text-align:left">IEEE 754</td>
<td style="text-align:left">IEEE 754</td>
<td style="text-align:left">Double</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">–</td>
<td style="text-align:left">Void</td>
</tr>
</tbody>
</table>
<h1 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h1><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>类的成员若未在定义的时候初始化，则 Java 会给其赋默认值。而局部变量必须显式赋予初始值。</p>
<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ol>
<li>当类的静态方法/静态域首次被访问时（构造方法也是静态方法），类加载器会查找类路径，定位 xx.class 文件。</li>
<li>载入 xx.class 文件，创建一个 Class 对象。执行所有有关静态初始化的动作（包括静态子句）。</li>
<li>当用 new 创建对象时，现在堆上为对象分配足够的空间。</li>
<li>这块空间会被清零，也就是将对象的成员赋予了默认初始值。</li>
<li>执行所有出现于字段定义处的初始化动作，以及非静态子句。</li>
<li>执行构造方法。</li>
</ol>
<h1 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h1><h1 id="JNI-字段描述符"><a href="#JNI-字段描述符" class="headerlink" title="JNI 字段描述符"></a>JNI 字段描述符</h1><p>JNI（JavaNative Interface FieldDescriptors) 字段描述符是一种对函数返回值和参数的编码。</p>
<p>Boolean：Z<br>Byte：B<br>Char：C<br>Short：S<br>Int：I<br>Long：J<br>Float：F<br>Double：D<br>Void：V<br>对象：以”L”开头，以”;”结尾，中间是用”/“ 隔开的包及类名。比如：“Ljava/lang/String;”。如果是嵌套类，则用“$”来表示嵌套。例如 “(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z”。<br>数组：在上述描述符前面加上”[“，有多少级数组就加多少个”[“。</p>
<h1 id="fork-join"><a href="#fork-join" class="headerlink" title="fork-join"></a>fork-join</h1><h2 id="fork-join-最佳实践"><a href="#fork-join-最佳实践" class="headerlink" title="fork-join 最佳实践"></a>fork-join 最佳实践</h2><ul>
<li>调用 <code>join</code> 方法会阻塞调用方，务必在两个子任务都开始后再调用。</li>
<li>不应该在 <code>RecursiveTask</code> 内部调用 <code>ForkJoinPool.invoke()</code> 方法，而是应该调用 <code>compute</code> 或 <code>fork</code> 方法。只有顺序代码才应该调用 <code>invoke</code> 来启动并行计算。</li>
<li>只对一个子任务调用 <code>fork</code> 方法，让另一个子任务在当前线程执行。</li>
<li>如果条件允许的话，最好将任务划分为大量小任务而不是少量大任务，因为 fork-join 框架会使用“工作窃取”机制来实现负载均衡。</li>
</ul>
<p>//TODO</p>
<h1 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h1><table>
<thead>
<tr>
<th style="text-align:left">警告取值类型</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:left">all warnings</td>
</tr>
<tr>
<td style="text-align:left">boxing</td>
<td style="text-align:left">boxing/unboxing operations</td>
</tr>
<tr>
<td style="text-align:left">cast</td>
<td style="text-align:left">cast operations</td>
</tr>
<tr>
<td style="text-align:left">dep-ann</td>
<td style="text-align:left">deprecated annotation</td>
</tr>
<tr>
<td style="text-align:left">deprecation</td>
<td style="text-align:left">deprecation</td>
</tr>
<tr>
<td style="text-align:left">fallthrough</td>
<td style="text-align:left">missing breaks in switch statements</td>
</tr>
<tr>
<td style="text-align:left">finally</td>
<td style="text-align:left">finally block that don’t return</td>
</tr>
<tr>
<td style="text-align:left">hiding</td>
<td style="text-align:left">locals that hide variable</td>
</tr>
<tr>
<td style="text-align:left">incomplete-switch</td>
<td style="text-align:left">missing entries in a switch statement (enum case)</td>
</tr>
<tr>
<td style="text-align:left">nls</td>
<td style="text-align:left">non-nls(National Language Support) string literals</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">null analysis</td>
</tr>
<tr>
<td style="text-align:left">rawtypes</td>
<td style="text-align:left">un-specific types when using generics on class params</td>
</tr>
<tr>
<td style="text-align:left">restriction</td>
<td style="text-align:left">usage of discouraged or forbidden references</td>
</tr>
<tr>
<td style="text-align:left">serial</td>
<td style="text-align:left">missing serialVersionUID field for a serializable class</td>
</tr>
<tr>
<td style="text-align:left">static-access</td>
<td style="text-align:left">incorrect static access</td>
</tr>
<tr>
<td style="text-align:left">synthetic-access</td>
<td style="text-align:left">unoptimized access from inner classes</td>
</tr>
<tr>
<td style="text-align:left">unchecked</td>
<td style="text-align:left">unchecked operations</td>
</tr>
<tr>
<td style="text-align:left">unqualified-field-access</td>
<td style="text-align:left">field access unqualified</td>
</tr>
<tr>
<td style="text-align:left">unused</td>
<td style="text-align:left">unused code</td>
</tr>
</tbody>
</table>
<h1 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h1><table>
<thead>
<tr>
<th style="text-align:left">option</th>
<th style="text-align:left">meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">输出类中各方法的未解析的代码，即构成java字节码的指令</td>
</tr>
<tr>
<td style="text-align:left">-classpath {pathlist}</td>
<td style="text-align:left">指定javap用来查找类的路径。目录用：分隔</td>
</tr>
<tr>
<td style="text-align:left">-extdirs {dirs}</td>
<td style="text-align:left">覆盖搜索安装方式扩展的位置，扩展的缺省位置为jre/lib/ext</td>
</tr>
<tr>
<td style="text-align:left">-help</td>
<td style="text-align:left">输出帮助信息</td>
</tr>
<tr>
<td style="text-align:left">-J{flag}</td>
<td style="text-align:left">直接将flag传给运行时系统</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">输出行及局部变量表</td>
</tr>
<tr>
<td style="text-align:left">-public</td>
<td style="text-align:left">只显示public类及成员</td>
</tr>
<tr>
<td style="text-align:left">-protected</td>
<td style="text-align:left">只显示protected和public类及成员。</td>
</tr>
<tr>
<td style="text-align:left">-package</td>
<td style="text-align:left">只显示包、protected和public类及成员，这是缺省设置</td>
</tr>
<tr>
<td style="text-align:left">-private</td>
<td style="text-align:left">显示所有的类和成员</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td style="text-align:left">输出内部类型签名</td>
</tr>
<tr>
<td style="text-align:left">-bootclasspath {pathlist}</td>
<td style="text-align:left">指定加载自举类所用的路径，如jre/lib/rt.jar或i18n.jar</td>
</tr>
<tr>
<td style="text-align:left">-verbose</td>
<td style="text-align:left">打印堆栈大小、各方法的locals及args参数，以及class文件的编译版本</td>
</tr>
</tbody>
</table>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><code>Entry</code> 继承自 <code>WeakReference</code>，key 是弱引用。</p>
<p>以下方法中会调用 <code>expungeStaleEntries()</code> 来清理 key 被 gc 了的 entry：</p>
<ul>
<li><code>getTable()</code></li>
<li><code>size()</code></li>
<li><code>resize()</code></li>
</ul>
<p>这几个方法都很基础，几乎所有对 Map 的操作都会调用到。如果 Map 长时间不被访问的话依然可能因为 value 不被释放而发生内存泄漏。</p>
<h1 id="ClassValue"><a href="#ClassValue" class="headerlink" title="ClassValue"></a>ClassValue</h1><p>业务代码中经常需要使用 <code>Map&lt;Class, Object&gt;</code> 作为缓存来 //TODO</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/12/工具/AutoHotKey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/工具/AutoHotKey/" itemprop="url">AutoHotKey</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T16:55:00+08:00">2018-01-12</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="向后台窗口输出"><a href="#向后台窗口输出" class="headerlink" title="向后台窗口输出"></a>向后台窗口输出</h1><p><code>ControlSend, , {key}, ahk_class GxWindowClass</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/01/工具/Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/工具/Hexo/" itemprop="url">Hexo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-01T22:00:00+08:00">2018-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>本文根据网上各处的教程和自身的实践，记录了用 Hexo 搭建博客的各方面信息。</p>
<h1 id="搭建过程概述"><a href="#搭建过程概述" class="headerlink" title="搭建过程概述"></a>搭建过程概述</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>Git</li>
<li>Node.js</li>
<li>Hexo</li>
<li>Hexo 主题</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/01/01/工具/Hexo/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/01/算法/国密算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/算法/国密算法/" itemprop="url">国密算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-01T09:00:00+08:00">2018-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SM3-杂凑算法（摘要算法）"><a href="#SM3-杂凑算法（摘要算法）" class="headerlink" title="SM3 杂凑算法（摘要算法）"></a>SM3 杂凑算法（摘要算法）</h1><blockquote>
<p>对长度为 l（$l &lt; 2^{64}$）比特的消息 m，经过填充和迭代压缩，生成 256 比特的杂凑值。</p>
</blockquote>
<h2 id="术语和定义"><a href="#术语和定义" class="headerlink" title="术语和定义"></a>术语和定义</h2><ul>
<li>ABCDEFGH：8 个字寄存器或它们的值的串联</li>
<li>∧：32 比特与运算</li>
<li>∨：32 比特或运算</li>
<li>⊕：32 比特异或运算</li>
<li>﹁：32 比特非运算</li>
<li>+：$mod2^{32}$ 算数加运算</li>
<li>&lt;&lt;&lt;：循环左移</li>
<li>CF：压缩函数（见 2.3 节）</li>
<li>IV：压缩函数寄存器的初始值<br>  7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e</li>
<li>$FF_{j}$：布尔函数，随 j 的变化取不同的表达式<br>$ FF_j(X,Y,Z)=\begin{cases} X \oplus Y \oplus Z, &amp; 0 \le j \le 15 \ (X \wedge Y)\vee(X \wedge Z)\vee(Y \wedge Z), &amp; 16 \le j \le 63 \end{cases} $</li>
<li>$GG_{j}$：布尔函数，随 j 的变化取不同的表达式<br>$ GG_j(X,Y,Z)=\begin{cases} X \oplus Y \oplus Z, &amp; 0 \le j \le 15 \ (X \wedge Y)\vee(\neg X \wedge Z), &amp; 16 \le j \le 63 \end{cases} $</li>
<li>$P_{0}$：压缩函数中的置换函数<br>$ P_0(X)=X \oplus (X \lll 9) \oplus (X \lll 17) $</li>
<li>$P_{1}$：消息扩展中的置换函数<br>$ P_1(X)=X \oplus (X \lll 15) \oplus (X \lll 23) $</li>
<li>$T_{j}$：常量，随 j 的变化取不同的值<br>$ T_j = \begin{cases} 79cc4519, &amp; 0 \le j \le 15 \ 7a879d8a, &amp; 16 \le j \le 63 \end{cases} $</li>
</ul>
<h2 id="1-填充"><a href="#1-填充" class="headerlink" title="1. 填充"></a>1. 填充</h2><p>设消息 m 的长度为 l 比特。</p>
<ol>
<li>将比特值“1”添加到消息的末尾；</li>
<li><p>再在末尾添加 k 个“0”，其中 k 是满足 <em>l + 1 + k = 448 mod 512</em> 的最小的非负整数；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int k = 448 - (8 * inputStr.length + 1) % 512;</span><br><span class="line">if (k &lt; 0) &#123;</span><br><span class="line">    k = k + 512;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再在末尾添加一个 64 位比特串，该比特串为 l 的二进制表示；</p>
</li>
<li>填充后的消息 m’ 的比特长度为 512 的倍数。</li>
</ol>
<h2 id="2-迭代压缩"><a href="#2-迭代压缩" class="headerlink" title="2. 迭代压缩"></a>2. 迭代压缩</h2><h3 id="2-1-迭代过程"><a href="#2-1-迭代过程" class="headerlink" title="2.1 迭代过程"></a>2.1 迭代过程</h3><ol>
<li>将填充后的消息 m’ 按 512 比特进行分组：<br>$m’ = B^{(0)}B^{(1)}…B^{(n-1)}$</li>
<li>对 m’ 按以下方式迭代：<br>$ for\;i\;=\;0\;to\;n-1 $<br>$ \qquad V^{(i+1)} = CF(V^{(i)}, B^{(i)}) $<br>$ endfor $</li>
</ol>
<h3 id="2-2-消息扩展"><a href="#2-2-消息扩展" class="headerlink" title="2.2 消息扩展"></a>2.2 消息扩展</h3><p>将消息分组 $B^{(i)}$ 按以下方法扩展成 132 个字 $W<em>{0}$, $W</em>{1}$, …, $W<em>{67}$， $W’</em>{0}$, $W’<em>{1}$, …, $W’</em>{63}$，用于压缩函数 CF。</p>
<ol>
<li>将消息分组 $B^{(i)}$ 划分为 16 个字 $W<em>{0}$, $W</em>{1}$, …, $W_{15}$</li>
<li>$ for\;j\;=\;16\;to\;67 \<br>\qquad W_j \leftarrow P<em>1(W</em>{j-16} \oplus W<em>{j-9} \oplus (W</em>{j-3} \lll 15)) \oplus (W<em>{j-13} \lll 7) \oplus W</em>{j-6} \<br>endfor $</li>
<li>$ for\;j=0\;to\;63 \<br>\qquad W’_j = W<em>j \oplus W</em>{j+4} \<br>endfor $</li>
</ol>
<h3 id="2-3-压缩函数"><a href="#2-3-压缩函数" class="headerlink" title="2.3 压缩函数"></a>2.3 压缩函数</h3><p>令 A，B，C，D，E，F，G，H 为字寄存器，SS1，SS2，TT1，TT2 为中间变量，压缩函数<br>$ V^{i+1}=CF(V^{(i)},B^{(i)}), 0 \le i \le n-1 $<br>计算过程描述如下：</p>
<p>$ ABCDEFGH \leftarrow V^{(i)} \<br>for\;j=0\;to\;63 \<br>\qquad SS1 \leftarrow ((A \lll 12)+E+(T_j \lll j)) \lll 7 \<br>\qquad SS2 \leftarrow SS1 \oplus (A \lll 12) \<br>\qquad TT1 \leftarrow FF_j(A,B,C)+D+SS2+W’_j \<br>\qquad TT2 \leftarrow GG_j(E,F,G)+H+SS1+W_j \<br>\qquad D \leftarrow C \<br>\qquad C \leftarrow B \lll 9 \<br>\qquad B \leftarrow A \<br>\qquad A \leftarrow TT1 \<br>\qquad H \leftarrow G \<br>\qquad G \leftarrow F \lll 19 \<br>\qquad F \leftarrow E \<br>\qquad E \leftarrow P_0(TT2) \<br>endfor \<br>V^{(i+1)} \leftarrow ABCDEFGH \oplus V^{(i)} $</p>
<p>其中，字的存储为大端（big-endian）格式。</p>
<h2 id="3-输出杂凑值"><a href="#3-输出杂凑值" class="headerlink" title="3. 输出杂凑值"></a>3. 输出杂凑值</h2><p>输出 256 比特的杂凑值 $y = ABCDEFGH = V^{(n)}$。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/Java/Apache Commons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/Java/Apache Commons/" itemprop="url">Apache Commons</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T10:00:00+08:00">2017-10-13</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Apache-Commons"><a href="#Apache-Commons" class="headerlink" title="Apache Commons"></a>Apache Commons</h1>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/10/13/Java/Apache Commons/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/Java/Spring/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:05+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>大部分内容整理自《Spring实战（第4版）》</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/01/Java/Spring/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/XML/SAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/XML/SAX/" itemprop="url">SAX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h1><blockquote>
<p>Simple API for XML</p>
</blockquote>
<ul>
<li>是基于事件的 API。</li>
<li>在一个比 DOM 低的级别上操作。</li>
<li>提供比 DOM 更多的控制。</li>
<li>几乎总是比 DOM 更有效率。</li>
<li>需要比 DOM 更多的工作。</li>
</ul>
<h1 id="常用的-SAX-接口和类"><a href="#常用的-SAX-接口和类" class="headerlink" title="常用的 SAX 接口和类"></a>常用的 SAX 接口和类</h1><p>SAX 将其事件分为几个接口：</p>
<ul>
<li><strong>ContentHandler</strong> 定义与文档本身关联的事件（例如，开始和结束标记）。大多数应用程序都注册这些事件。</li>
<li><strong>DTDHandler</strong> 定义与 DTD 关联的事件。然而，它不定义足够的事件来完整地报告 DTD。如果需要对 DTD 进行语法分析，请使用可选的 DeclHandler。DeclHandler 是 SAX 的扩展，并且不是所有的语法分析器都支持它。</li>
<li><strong>EntityResolver</strong> 定义与装入实体关联的事件。只有少数几个应用程序注册这些事件。</li>
<li><strong>ErrorHandler</strong> 定义错误事件。许多应用程序注册这些事件以便用它们自己的方式报错。</li>
</ul>
<p>为简化工作，SAX 在 DefaultHandler 类中提供了这些接口的缺省实现。在大多数情况下，为应用程序扩展 DefaultHandler 并覆盖相关的方法要比直接实现一个接口更容易。</p>
<h1 id="XMLReader"><a href="#XMLReader" class="headerlink" title="XMLReader"></a>XMLReader</h1><p>为注册事件处理器并启动语法分析器，应用程序使用 XMLReader 接口中的相关方法，启动语法分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.parse(args[0]);</span><br></pre></td></tr></table></figure></p>
<p><strong>XMLReader 的主要方法是：</strong></p>
<ul>
<li><strong>parse()</strong> 对 XML 文档进行语法分析。 parse() 有两个版本；一个接受文件名或 URL，另一个接受 InputSource 对象。</li>
<li><strong>setContentHandler() 、 setDTDHandler() 、 setEntityResolver() 和 setErrorHandler()</strong> 让应用程序注册事件处理器。</li>
<li><strong>setFeature() 和 setProperty()</strong> 控制语法分析器如何工作。它们采用一个特性或功能标识（一个类似于名称空间的 URI 和值）。功能采用 Boolean 值，而特性采用“对象”。</li>
</ul>
<p><strong>最常用的 XMLReaderFactory 功能是：</strong></p>
<ul>
<li><strong><a href="http://xml.org/sax/features/namespaces" target="_blank" rel="noopener">http://xml.org/sax/features/namespaces</a></strong>，所有 SAX 语法分析器都能识别它。如果将它设置为 true（缺省值），则在调用 ContentHandler 的方法时，语法分析器将识别出名称空间并解析前缀。</li>
<li><strong><a href="http://xml.org/sax/features/validation" target="_blank" rel="noopener">http://xml.org/sax/features/validation</a></strong>，它是可选的。如果将它设置为 true，则验证语法分析器将验证该文档。非验证语法分析器忽略该功能。</li>
</ul>
<h1 id="XMLReaderFactory"><a href="#XMLReaderFactory" class="headerlink" title="XMLReaderFactory"></a>XMLReaderFactory</h1><p>XMLReaderFactory 创建语法分析器对象。它定义 createXMLReader() 的两个版本：一个采用语法分析器的类名作为参数，另一个从 org.xml.sax.driver 系统特性中获得类名称。<br>对于 Xerces，类是 org.apache.xerces.parsers.SAXParser 。应该使用 XMLReaderFactory ，因为它易于切换至另一种 SAX 语法分析器。实际上，只需要更改一行然后重新编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLReader parser = XMLReaderFactory.createXMLReader(</span><br><span class="line">                       &quot;org.apache.xerces.parsers.SAXParser&quot;);</span><br></pre></td></tr></table></figure></p>
<p>为获得更大的灵活性，应用程序可以从命令行读取类名或使用不带参数的 createXMLReader() 。因此，甚至可以不重新编译就更改语法分析器。</p>
<h1 id="InputSource"><a href="#InputSource" class="headerlink" title="InputSource"></a>InputSource</h1><p>InputSource 控制语法分析器如何读取文件，包括 XML 文档和实体。<br>在大多数情况下，文档是从 URL 装入的。但是，有特殊需求的应用程序可以覆盖 InputSource 。例如，这可以用来从数据库中装入文档。</p>
<h1 id="ContentHandler"><a href="#ContentHandler" class="headerlink" title="ContentHandler"></a>ContentHandler</h1><p>ContentHandler 是最常用的 SAX 接口，因为它定义 XML 文档的事件。</p>
<p>ContentHandler 声明下列事件：</p>
<ul>
<li><strong>startDocument() / endDocument()</strong> 通知应用程序文档的开始或结束。</li>
<li><strong>startElement() / endElement()</strong> 通知应用程序标记的开始或结束。属性作为 Attributes 参数传递。即使只有一个标记，“空”元素（例如， <code>&lt;img href=&quot;logo.gif&quot;/&gt;</code>）也生成 startElement() 和 endElement() 。</li>
<li><strong>startPrefixMapping() / endPrefixMapping()</strong> 通知应用程序命名空间作用域。通常不需要该信息，因为当 <a href="http://xml.org/sax/features/namespaces" target="_blank" rel="noopener">http://xml.org/sax/features/namespaces</a> 为 true 时，语法分析器已经解析了名称空间。</li>
<li>当语法分析器在元素中发现文本（已经过语法分析的字符数据）时， <strong>characters() / ignorableWhitespace()</strong> 会通知应用程序。要知道，语法分析器负责将文本分配到几个事件（更好地管理其缓冲区）。 ignorableWhitespace 事件用于由 XML 标准定义的可忽略空格。</li>
<li><strong>processingInstruction()</strong> 将处理指令通知应用程序。</li>
<li><strong>skippedEntity()</strong> 通知应用程序已经跳过了一个实体（即，当语法分析器未在 DTD/schema 中发现实体声明时）。</li>
<li><strong>setDocumentLocator()</strong> 将 Locator 对象传递到应用程序。请注意，不需要 SAX 语法分析器提供 Locator ，但是如果它提供了，则必须在任何其它事件之前激活该事件。</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>在 startElement() 事件中，应用程序在 Attributes 参数中接收属性列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String attribute = attributes.getValue(&quot;&quot;,&quot;price&quot;);</span><br></pre></td></tr></table></figure></p>
<p>Attributes 参数仅在 startElement() 事件期间可用。如果在事件之间需要它，则用 AttributesImpl 复制一个。</p>
<p>Attributes 定义下列方法：</p>
<ul>
<li><strong>getValue(i) / getValue(qName) /getValue(uri,localName)</strong> 返回第 i 个属性值或给定名称的属性值。</li>
<li><strong>getLength()</strong> 返回属性数目。</li>
<li><strong>getQName(i) / getLocalName(i) /getURI(i)</strong> 返回限定名（带前缀）、本地名（不带前缀）和第 i 个属性的名称空间 URI。</li>
<li><strong>getType(i) / getType(qName) / getType(uri,localName)</strong> 返回第 i 个属性的类型或者给定名称的属性类型。类型为字符串，即在 DTD 所使用的： “CDATA”、“ID”、“IDREF”、“IDREFS”、“NMTOKEN”、“NMTOKENS”、“ENTITY”、“ENTITIES” 或 “NOTATION”。</li>
</ul>
<h1 id="定位器"><a href="#定位器" class="headerlink" title="定位器"></a>定位器</h1><p>Locator 为应用程序提供行和列的位置。不需要语法分析器来提供 Locator 对象。</p>
<p>Locator 定义下列方法：</p>
<ul>
<li><strong>getColumnNumber()</strong> 返回当前事件结束时所在的那一列。在 endElement() 事件中，它将返回结束标记所在的最后一列。</li>
<li><strong>getLineNumber()</strong> 返回当前事件结束时所在的行。在 endElement() 事件中，它将返回结束标记所在的行。</li>
<li><strong>getPublicId()</strong> 返回当前文档事件的公共标识。</li>
<li><strong>getSystemId()</strong> 返回当前文档事件的系统标识。</li>
</ul>
<h1 id="DTDHandler"><a href="#DTDHandler" class="headerlink" title="DTDHandler"></a>DTDHandler</h1><p>DTDHandler 声明两个与 DTD 语法分析器相关的事件。</p>
<ul>
<li><strong>notationDecl()</strong> 通知应用程序已经声明了一个标记。</li>
<li><strong>nparsedEntityDecl()</strong> 通知应用程序已经发现了一个未经过语法分析的实体声明。</li>
</ul>
<h1 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h1><p>EntityResolver 接口仅定义一个事件 resolveEntity() ，它返回 InputSource。<br>因为 SAX 语法分析器已经可以解析大多数 URL，所以很少应用程序实现 EntityResolver 。例外情况是目录文件，它将公共标识解析成系统标识。如果在应用程序中需要目录文件，请下载 Norman Walsh 的目录软件包。</p>
<h1 id="ErrorHandler"><a href="#ErrorHandler" class="headerlink" title="ErrorHandler"></a>ErrorHandler</h1><p>ErrorHandler 接口定义错误事件。处理这些事件的应用程序可以提供定制错误处理。<br>安装了定制错误处理器后，语法分析器不再抛出异常。抛出异常是事件处理器的责任。<br>接口定义了与错误的三个级别或严重性对应的三个方法：</p>
<ul>
<li><strong>warning()</strong> 警示那些不是由 XML 规范定义的错误。例如，当没有 XML 声明时，某些语法分析器发出警告。它不是错误（因为声明是可选的），但是它可能值得注意。</li>
<li><strong>error()</strong> 警示那些由 XML 规范定义的错误。</li>
<li><strong>fatalError()</strong> 警示那些由 XML 规范定义的致命错误。</li>
</ul>
<h1 id="SAXException"><a href="#SAXException" class="headerlink" title="SAXException"></a>SAXException</h1><p>SAX 定义的大多数方法都可以抛出 SAXException 。当对 XML 文档进行语法分析时， SAXException 通知一个错误。<br>错误可以是语法分析错误也可以是事件处理器中的错误。要报告来自事件处理器的其它异常，可以将异常封装在 SAXException 中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/UML类图/设计模式及设计方法——UML类图几种关系的总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/UML类图/设计模式及设计方法——UML类图几种关系的总结/" itemprop="url">设计模式及设计方法——UML类图几种关系的总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:00+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在UML类图中，常见的有以下几种关系:<strong>泛化</strong>（Generalization）,  <strong>实现</strong>（Realization）,<strong>关联</strong>（Association）,<strong>聚合</strong>（Aggregation）,<strong>组合</strong>(Composition)，<strong>依赖</strong>(Dependency)</p>
<h1 id="1-泛化-Generalization"><a href="#1-泛化-Generalization" class="headerlink" title="1. 泛化(Generalization)"></a>1. <strong>泛化</strong>(Generalization)</h1><p>【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为例如：老虎是动物的一种.<br>【箭头指向】：带三角箭头的实线，箭头指向父类<br><img src="http://hi.csdn.net/attachment/201104/22/0_1303436788Qi60.gif" alt="泛化关系"></p>
<h1 id="2-实现（Realization"><a href="#2-实现（Realization" class="headerlink" title="2. 实现（Realization)"></a>2. <strong>实现</strong>（Realization)</h1><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现<br>【箭头指向】：带三角箭头的虚线，箭头指向接口<br><img src="http://hi.csdn.net/attachment/201104/22/0_13034367939K49.gif" alt="实现关系"></p>
<h1 id="3-关联（Association）"><a href="#3-关联（Association）" class="headerlink" title="3. 关联（Association）"></a>3. <strong>关联</strong>（Association）</h1><p>【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子<br>关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>【代码体现】：成员变量<br>【箭头及指向】：带普通箭头的实心线，指向被拥有者<br><img src="http://hi.csdn.net/attachment/201104/22/0_1303436801W1kf.gif" alt="关联关系"></p>
<p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。<br><img src="http://hi.csdn.net/attachment/201104/22/0_13034368062Ka3.gif" alt="自身关联"><br> 上图为自身关联</p>
<h1 id="4-聚合（Aggregation）"><a href="#4-聚合（Aggregation）" class="headerlink" title="4. 聚合（Aggregation）"></a>4. <strong>聚合</strong>（Aggregation）</h1><p>【聚合关系】：是整体与部分的关系.如车和轮胎是整体和部分的关系.<br>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>【代码体现】：成员变量<br>【箭头及指向】：带空心菱形的实心线，菱形指向整体<br><img src="http://hi.csdn.net/attachment/201104/22/0_1303436811y36B.gif" alt="聚合关系"></p>
<h1 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5. 组合(Composition)"></a>5. <strong>组合</strong>(Composition)</h1><p>【组合关系】：是整体与部分的关系.,没有公司就不存在部门      组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期<br>【代码体现】：成员变量<br>【箭头及指向】：带实心菱形的实线，菱形指向整体<br><img src="http://hi.csdn.net/attachment/201104/22/0_1303436817mqXK.gif" alt="组合关系"></p>
<h1 id="6-依赖-Dependency"><a href="#6-依赖-Dependency" class="headerlink" title="6. 依赖(Dependency)"></a>6. <strong>依赖</strong>(Dependency)</h1><p>【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。<br>【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>【箭头及指向】：带箭头的虚线，指向被使用者<br> <img src="http://hi.csdn.net/attachment/201104/22/0_130343682580L6.gif" alt="依赖关系"></p>
<p>各种关系的强弱顺序：<br><strong>泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</strong></p>
<p>下面这张UML图，比较形象地展示了各种类图关系：<br><img src="http://hi.csdn.net/attachment/201202/29/0_1330497855hqk2.gif" alt="各种类图关系"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zeerho</p>
              <p class="site-description motion-element" itemprop="description">Just a repo for documents</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZephyrHuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zephyrhuang21@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeerho</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
