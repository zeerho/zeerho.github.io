<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Just a repo for documents">
<meta property="og:type" content="website">
<meta property="og:title" content="Tags">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="zeerho">
<meta property="og:description" content="Just a repo for documents">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-05T02:37:10.245Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tags">
<meta name="twitter:description" content="Just a repo for documents">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/"/>





  <title>Spring | zeerho</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zeerho</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Java/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zeerho">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zeerho">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T09:00:05+08:00">2017-01-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>大部分内容整理自《Spring实战（第4版）》</p>
<a id="more"></a>
<h1 id="第-1-章-Spring-之旅"><a href="#第-1-章-Spring-之旅" class="headerlink" title="第 1 章 Spring 之旅"></a>第 1 章 Spring 之旅</h1><h2 id="xml-扫描的大致流程"><a href="#xml-扫描的大致流程" class="headerlink" title="xml 扫描的大致流程"></a>xml 扫描的大致流程</h2><p><strong>精简版</strong></p>
<ol>
<li><code>BeanDefinitionReader#loadBeanDefinitions</code><ol>
<li><code>DocumentLoader#loadDocument</code> 得到 <code>Document</code> 对象</li>
<li><code>BeanDefinitionDocumentReader#registerBeanDefinitions</code></li>
</ol>
</li>
<li>对于每一层 <code>beans</code> 标签，都创建一个 <code>BeanDefinitionParserDelegate</code>，因而这个 delegate 也可以形成嵌套结构</li>
<li>解析这层 <code>beans</code> 标签下的配置内容<ol>
<li>对于当前命名空间下的元素，直接用当前的 delegate 来解析</li>
<li>对于其他命名空间下的元素，调用 <code>NamespaceHanlderResolver#resolve</code> 来获取命名空间对应的 <code>NamespaceHandler</code>。然后调用 <code>NamespaceHandler#parse</code> 来解析这个命名空间下的所有元素<br>有两种方式来实现命名空间的解析逻辑：<ol>
<li>直接实现 <code>NamespaceHandler</code> 接口</li>
<li>实现 <code>NamespaceHandlerSupport</code> 抽象类，在 <code>init</code> 方法中注册自定义的 <code>BeanDefinitionParser</code> 和 <code>BeanDefinitionDecorator</code>，具体的解析逻辑会被委托给这些解析类。命名空间下的每一个元素对应一个解析类。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>详细版</strong></p>
<ol>
<li><code>BeanDefinitionReader#loadBeanDefinitions</code> 从指定资源或位置加载 bean 定义。<code>XmlBeanDefinitionReader</code> 是 xml 对应的实现。<ol>
<li>使用 <code>DocumentLoader</code> 把 xml 资源加载成 <code>org.w3c.dom.Document</code>。<code>DocumentLoader</code> 是加载 xml 的策略接口，默认实现为 <code>DefaultDocumentLoader</code>。</li>
<li>调用 <code>BeanDefinitionDocumentReader#registerBeanDefinitions</code> 注册 bean 定义。<ul>
<li>调用这个方法的时候，会传入 <code>XmlReaderContext</code>，其中包含了 <code>Resource</code>、<code>ProblemReporter</code>、<code>ReaderEventListener</code>、<code>SourceExtractor</code>、<code>XmlBeanDefinitionReader</code>、<code>NamespaceHandlerResolver</code>。</li>
</ul>
</li>
</ol>
</li>
<li><code>BeanDefinitionDocumentReader</code> 是用来注册 bean 定义的 SPI，默认实现为 <code>DefaultBeanDefinitionDocumentReader</code>。<ol>
<li>调用 <code>BeanDefinitionParserDelegate#isDefaultNamespace</code> 判断当前节点是否为默认的命名空间（无命名空间或命名空间为 <code>beans</code>），若是的话，判断 <code>profile</code> 属性是否符合。</li>
<li>使用 <code>BeanDefinitionParserDelegate</code> 来负责解析 bean 定义。<ul>
<li>此类保存了 <code>beans</code> 标签中定义的一些属性，供后续的 bean 解析器来使用。</li>
<li>因为 <code>beans</code> 标签是可嵌套的，所以 <code>BeanDefinitionParserDelegate</code> 也是可嵌套的，对于子节点未配置的属性，缺省为父节点的属性。</li>
<li>此类还对外提供了众多解析用的方法，这些方法一方面提供了统一的 API，另一方面也共用了解析过程中的模板代码。</li>
<li>此类的每一个对象都代表一个命名空间，所以可以继承子类来表示自定义的命名空间，并提供该命名空间下自定义的解析方法。</li>
</ul>
</li>
<li>递归解析根节点下的配置。<ul>
<li>解析默认命名空间下的配置，调用 <code>BeanDefinitionParserDelegate#parseDefaultElement</code>。其中包括 <code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code>，后续可能会扩展。</li>
<li>解析其他命名空间下的配置，调用 <code>BeanDefinitionParserDelegate#parseCustomElement</code>。</li>
</ul>
<ol>
<li>取 <code>XmlReaderContext</code> 中的 <code>NamespaceHandlerResolver</code>，默认实现为 <code>DefaultNamespaceHandlerResolver</code>。<ul>
<li><code>NamespaceHandlerResolver</code> 中维护了一个配置文件的地址（默认为 META-INF/spring.handlers，查找范围包括类加载器下的所有包），该文件中保存了命名空间和 <code>NamespaceHandler</code> 实现类的对应关系。</li>
</ul>
</li>
<li>调用 <code>NamespaceHandlerResolver#resolve</code> 找到当前命名空间对应的 <code>NamespaceHandler</code>。</li>
<li>调用 <code>NamespaceHandler#parse</code> 来做进一步的解析。</li>
</ol>
</li>
</ol>
</li>
<li><code>NamespaceHandler</code> 有一个抽象实现类 <code>NamespaceHandlerSupport</code>，一般通过实现此类来自定义一个 <code>NamespaceHandler</code>。<ul>
<li><code>NamespaceHandlerSupport</code> 维护了三个 Map，保存了 <code>BeanDefinitionParser</code> / <code>BeanDefinitionDecorator</code>，分别用来解析直接挂在 <code>beans</code> 下的 <code>bean</code>、挂在 <code>bean</code> 下的 <code>bean</code>、<code>bean</code> 中的 attribute;<ul>
<li><code>BeanDefinitionParser</code>：实际的 bean 解析类，负责解析直接挂在 <code>beans</code> 标签下的 bean；</li>
<li><code>BeanDefinitionDecorator</code>：实际的 bean 解析类，负责解析挂在 <code>bean</code> 标签下的 bean；</li>
</ul>
</li>
<li><code>NamespaceHandlerSupport</code> 提供了三个抽象方法，分别用来在上述三个 Map 中注册解析类。</li>
<li>当 <code>parse</code> 方法被调用时，根据当前 xml 元素的名称从上述 Map 中找到对应的 <code>BeanDefinitionParser</code>，然后调用其 <code>parse</code> 方法。</li>
<li><code>BeanDefinitionParser</code> 根据自己的需要，可以调用 <code>BeanDefinitionParserDelegate#decorateBeanDefinitionIfRequired</code> 方法，此方法又会调用 <code>NamespaceHandlerResolver#resolve</code> -&gt; <code>NamespaceHandler#decorate</code>。</li>
</ul>
</li>
</ol>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><strong>Spring 自带了几种容器实现，可归为两种类型：</strong></p>
<ol>
<li>bean 工厂<br>由 <code>org.springframework.beans.factory.BeanFactory</code> 接口定义。</li>
<li>应用上下文<br>由 <code>org.springframework.context.ApplicationContext</code> 接口定义，基于 BeanFactory 之上构建，并提供面向应用的服务。</li>
</ol>
<p><strong>bean 工厂太低级，通常选用应用上下文。</strong></p>
<p><strong>几种最常用的应用上下文：</strong></p>
<ul>
<li><code>AnnotationConfigApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring 应用上下文。</li>
<li><code>AnnotationConfigWebApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文。</li>
<li><code>ClassPathXmlApplicationContext</code> 从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文定义文件当作类资源。</li>
<li><code>FileSystemXmlApplicationContext</code> 读取文件系统下的一个或多个 XML 配置文件并加载上下文定义。</li>
<li><code>XmlWebApplicationContext</code> 读取 Web 应用下的一个或多个 XML 配置文件并装载上下文定义。</li>
</ul>
<p><strong><code>AbstractRefreshableWebApplicationContext</code> 和 <code>GenericWebApplicationContext</code></strong></p>
<p>前者是传统的 web 上下文，通过 web.xml 与 ServletContext 沟通，支持指定“contextClass”和“contextConfigLocation”参数。</p>
<p>后者供 Spring 3.1 的 <code>WebApplicationInitializer</code> 使用，通过 Servlet 3.0 新增的 <code>ServletContext#addServlet</code> 方法与 ServletContext 沟通，不允许存在 web.xml。</p>
<h3 id="ApplicationContext-主要继承结构及重要方法"><a href="#ApplicationContext-主要继承结构及重要方法" class="headerlink" title="ApplicationContext 主要继承结构及重要方法"></a>ApplicationContext 主要继承结构及重要方法</h3><pre><code>                                        ApplicationContext
                  /-----------------------------^---------------------------------\
             Configurable                                                        Web
       /---------/\-----------------------------------------------------------+---/
   Abstract                                                            ConfigurableWeb
/-----^------------------------------------------------\            /---------^-----+-----\
</code></pre><p>   AbstractRefreshable                                             Generic    StaticWeb           |     |<br>              |                      /————-+————+—–^——-+———-+——–+     |<br>   AbstractRefreshableConfig AnnotationConfig GenericGroovy GenericXml ResourceAdapter Static GenericWeb|<br>           /–^—————————————————————————————–+<br>       AbstractXml                                                                            AbstractRefreshableWeb<br>     /—–^—–\                                                                       /————–^-+——\<br>ClassPathXml FileSystemXml                                                        AnnotationConfigWeb GroovyWeb XmlWeb</p>
<hr>
<p><code>ApplicationContext</code> –&gt; <code>EnvironmentCapable</code> <code>ListableBeanFactory</code> <code>HierarchicalBeanFactory</code> <code>MessageSource</code> <code>ApplicationEventPublisher</code> <code>ResourcePatternResolver</code></p>
<ul>
<li><code>getParent()</code>：获取父上下文。</li>
<li><code>EnvironmentCapable#getEnvironment()</code>：获取环境信息。</li>
<li><code>ListableBeanFactory</code><ul>
<li><code>containsBeanDefinition()</code>：是否存在某个 bean 定义。</li>
<li><code>getBeanNamesForType()</code>、<code>getBeansOfType()</code>：获取指定类型的所有 bean。</li>
<li><code>getBeanNamesForAnnotation()</code>、<code>getBeansWithAnnotation()</code>：获取被指定注解标注的 bean。</li>
<li><code>findAnnotationOnBean()</code>：在指定 bean 上查找指定注解。</li>
</ul>
</li>
<li><code>ApplicationEventPublisher#publishEvent()</code>：发布事件。<ul>
<li><code>ResourcePatternResolver#getResources()</code> <code>#getResource()</code>：获取资源。</li>
</ul>
</li>
</ul>
<hr>
<p><code>ConfigurableApplicationContext</code> –&gt; <code>ApplicationContext</code> <code>Lifecycle</code> <code>closeable</code></p>
<ul>
<li><code>setEnvironment()</code> <code>addBeanFactoryPostProcessor()</code> <code>addApplicationListener</code>：加了几个 setter 方法，这是比较重要的三个。</li>
<li><code>refresh()</code>：加载或刷新上下文。</li>
</ul>
<hr>
<p><code>WebApplicationContext</code></p>
<ul>
<li><code>getServletContext()</code>：获取标准 Servlet API 上下文。</li>
</ul>
<hr>
<p><code>ConfigurableWebApplicationContext</code> –&gt; <code>ConfigurableApplicationContext</code> <code>WebAppliationContext</code></p>
<p>加了一些 getter setter 方法。</p>
<hr>
<p><code>AbstractRefreshableWebApplicationContext</code> –&gt; <code>ConfigurableWebApplicationContext</code> <code>ThemeSource</code> <code>AbstractRefreshableConfigApplicationContext</code></p>
<p>在 <code>AbstractRefreshableConfigApplicationContext</code> 的基础上增加了 Web 相关的配置。子类需要实现 <code>AbstractRefreshableAppliationContext#loadBeanDefinitions()</code> 来加载 bean 定义。理论上应从 <code>getConfigLocations()</code> 返回的路径中加载配置。</p>
<p>向 <code>ContextLoader</code> 或 <code>FrameworkServlet</code> 传入“contextClass”参数来指明实现类，然后这两个类会自动从“contextConfigLocation`参数中得知配置所在路径。</p>
<ul>
<li><code>XmlWebApplicationContext</code>：这是 Web 版本的 <code>GenericXmlApplicationContext</code>。从 xml 文件中加载配置。默认路径是 <code>/WEB-INF/applicationContext.xml</code>（根上下文）和 <code>/WEB-INF/test-servlet.xml</code>（各 servlet 上下文）。可用“contextConfigLocation”参数指定配置路径，支持 Ant 风格的匹配符。</li>
<li><code>AnnotationConfigWebApplicationContext</code>：这是 Web 版本的 <code>AnnotationConfigApplicationContext</code>。需要用“contextConfigLocation”参数来指明配置类或要扫描的包。</li>
<li><code>GroovyWebApplicationContext</code>：这是 Web 版本的 <code>GenericGroovyApplicationContext</code>。从 groovy 脚本和/或 xml 文件中加载配置。</li>
</ul>
<h3 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h3><p>ConfigurableApplicationContext#refresh()</p>
<ol>
<li><code>prepareRefresh()</code>：<ol>
<li><code>initPropertyResources()</code>：将 <code>StubPropertySource</code> 替换。</li>
<li><code>ConfigurableEnvironment#validateRequiredProperties()</code>：校验必需的属性。</li>
</ol>
</li>
<li><code>obtainFreshBeanFactory()</code>：<code>refreshBeanFactory()</code>、<code>getBeanFacotry()</code> 子类实现这两个方法，刷新并获取工厂。</li>
<li><code>prepareBeanFactory()</code>：在 BeanFactory 中做一些标准配置。</li>
<li><code>postProcessBeanFactory()</code>：留给子类的钩子。</li>
<li><code>invokeBeanFactoryPostProcessors()</code>：调用 <code>BeanFactoryPostProcessor</code>。</li>
<li><code>registerBeanPostProcessors()</code>：注册 <code>BeanPostProcessor</code>。</li>
<li><code>initMessageSource()</code>：初始化消息源。优先取已有的 “messageSource” bean，否则取 <code>DelegatingMessageSource</code>。</li>
<li><code>initApplicationEventMulticaster()</code>：初始化消息广播器。优先取已有的 <code>applicationEventMulticaster</code> bean，否则取 <code>SimpleApplicationEventMulticaster</code>。</li>
<li><code>onRefresh()</code>：留给子类的钩子，初始化其他特定的 bean。</li>
<li><code>registerListeners()</code>：向事件广播器注册监听器，并将之前囤积的事件广播出去。</li>
<li><code>finishBeanFactoryInitialization()</code>：初始化剩余的单例 bean，除了懒加载的 bean。</li>
<li><code>finishRefresh()</code>：完成刷新，调用 <code>LifecycleProcessor#onRefresh()</code>，发布 <code>ContextRefreshedEvent</code>。</li>
</ol>
<h2 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h2><p>以下内容基于 v5.0.8.RELEASE</p>
<p>实例化过程发生在 BeanFactory 中。</p>
<ol>
<li><code>BeanFactoryPostProcessor#postProcessBeanFactory()</code>。</li>
<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation()</code>。若返回非 null 则跳到 23.。</li>
<li>实例化 bean。<ol>
<li>若 bean 为单例，从 <code>FactoryBean</code> 缓存中查找实例。</li>
<li>若上一步无结果，则进行实例化：<ol>
<li>判断类的访问权限。</li>
<li>若 bean 定义了 supplier，则从 supplier 获取实例。</li>
<li>若 bean 定义了工厂方法，则从工厂方法获取实例。</li>
<li><code>SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors()</code> 确定构造方法。</li>
<li>若上一步得到了构造方法，则执行注入并利用该构造方法实例化。否则使用默认构造方法实例化。</li>
</ol>
</li>
</ol>
</li>
<li><code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition()</code>。</li>
<li>根据一些条件尝试解决循环引用的问题。</li>
<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()</code>。</li>
<li>解析待注入的属性，保存至 <code>MutablePropertyValues</code>。</li>
<li><code>InstantiationAwareBeanPostProcessor#postProcessPropertyValues()</code>。</li>
<li>进行实际的属性注入。</li>
<li>AwareLike 回调<ol>
<li><code>BeanNameAware#setBeanName()</code>。</li>
<li><code>BeanClassLoaderAware#setBeanClassLoader()</code>。</li>
<li><code>BeanFactoryAware#setBeanFactory()</code>。</li>
<li><code>EnvironmentAware#setEnvironment()</code>。</li>
<li><code>EmbeddedValueResolverAware#setEmbeddedValueResolverAware()</code>。</li>
<li><code>ResourceLoaderAware#setResourceLoader()</code>（仅当运行在 application context 中时）。</li>
<li><code>ApplicationEventPublisherAware#setApplicationEventPublisher()</code>（仅当运行在 application context 中时）。</li>
<li><code>MessageSourceAware#setMessageSource()</code>（仅当运行在 application context 中时）。</li>
<li><code>ApplicationContextAware#setApplicationContext()</code>（仅当运行在 application context 中时）。</li>
<li><code>ServletContextAware#setServletContext()</code>（仅当运行在 web application context 中时）。</li>
</ol>
</li>
<li><code>BeanPostProcessor#postProcessBeforeInitialization()</code>。</li>
<li><code>InitializingBean#afterPropertiesSet()</code>。</li>
<li>init-method</li>
<li><code>BeanPostProcessor#postProcessAfterInitialization()</code>。</li>
</ol>
<p>BeanFactory 关闭时：</p>
<ol>
<li><code>DestructionAwareBeanPostProcessors#postProcessBeforeDestruction</code>。</li>
<li><code>DisposableBean#destroy()</code>。</li>
<li>destroy-method</li>
</ol>
<h2 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h2><p><strong>模块分类</strong></p>
<ul>
<li>Spring 核心容器<ul>
<li>Beans</li>
<li>Core</li>
<li>Context</li>
<li>Expression</li>
<li>Context support</li>
</ul>
</li>
<li>数据访问与集成<ul>
<li>JDBC</li>
<li>Transaction</li>
<li>ORM</li>
<li>OXM</li>
<li>Messaging</li>
<li>JMS</li>
</ul>
</li>
<li>Web 与远程调用<ul>
<li>Web</li>
<li>Web servlet</li>
<li>Web portlet</li>
<li>WebSocket</li>
</ul>
</li>
<li>面向切面编程<ul>
<li>AOP</li>
<li>Aspects</li>
</ul>
</li>
<li>Instrumentation<ul>
<li>Instrument</li>
<li>Instrument Tomcat</li>
</ul>
</li>
<li>测试<ul>
<li>Test</li>
</ul>
</li>
</ul>
<ol>
<li>Spring 核心容器<br>容器是 Spring 框架最核心的部分，管理着 Spring 应用中 bean 的创建、配置和管理。除了 bean 工厂和应用上下文，也提供了许多企业服务，如 E-mail、JNDI 访问、EJB 集成和调度。</li>
<li>Spring 的 AOP 模块<br>Spring 应用系统中开发切面的基础。</li>
<li>数据访问与集成</li>
<li>Web 与远程调用<br>自带一个强大的 MVC 框架；提供多种远程调用方案。</li>
<li>Instrumentation<br>提供了为 JVM 添加代理（agent）的功能。</li>
<li>测试</li>
</ol>
<h2 id="Spring-的新功能"><a href="#Spring-的新功能" class="headerlink" title="Spring 的新功能"></a>Spring 的新功能</h2><p><strong>3.1</strong></p>
<p>3.1 很大程度上聚焦于配置改善和其他一些增强。</p>
<ul>
<li>为了解决各种环境下选择不同配置的问题，引入了环境 profile 功能，从而能根据部署环境来自动切换不同的数据源 bean；</li>
<li>在 3.0 基于 Java 的配置之上，3.1 添加了多个 enable 注解，这样就能使用这个注解启用 Spring 的特定功能；</li>
<li>添加了对声明式缓存的支持；</li>
<li>新添加的用于构造器注入的 c 命名空间，类似于 2.0 所提供的面向属性的 p 命名空间；</li>
<li>开始支持 Servlet 3.0，包括在基于 Java 的配置中声明 Servlet 和 Filter，而不再借助于 web.xml；</li>
<li>改善对 JPA 的支持，不必再使用 persistence.xml 文件。</li>
</ul>
<p>以及针对 Spring MVC 的功能增强</p>
<ul>
<li>自动绑定路径变量到模型属性中；</li>
<li>提供了 <code>@RequestMappingproduces</code> 和 <code>consumes</code> 属性，用于匹配请求中的 <code>Accept</code> 和 <code>Content-Type</code> 头部消息；</li>
<li>提供了 <code>@RequestPart</code> 注解，用于将 multipart 请求中的某些部分绑定到处理器的方法参数中；</li>
<li>支持 flash 属性（在 redirect 请求之后依然能够存活的属性）以及用于在请求间存放 flash 属性的 <code>RedirectAttributes</code> 类型。</li>
</ul>
<p>废弃的功能</p>
<ul>
<li>为了支持原生的 EntityManager，<code>JpaTemplate</code> 和 <code>JpaDaoSupport</code> 类被废弃掉了。直到 3.2 版本依然可用，4.0 版本中移除。</li>
</ul>
<p><strong>3.2</strong></p>
<p>3.2 主要关注 Spring MVC 的一个发布版本。</p>
<ul>
<li>3.2 的控制器（Controller）可以使用 Servlet 3.0 的异步请求，允许在一个独立的线程中处理请求，从而将 Servlet 线程解放出来处理更多的请求；</li>
<li>引入了 Spring MVC 测试框架，用于为控制器编写更为丰富的测试，而且在使用的过程中不需要 Servlet 容器；</li>
<li>包含了基于 <code>RestTemplate</code> 的客户端的测试支持，测试过程中不需要往真正的 REST 端点上发送请求；</li>
<li><code>ControllerAdvice</code> 注解能将通用的 <code>@ExceptionHandler</code>、<code>@InitBinder</code> 和 <code>@ModelAttributes</code> 方法收集到一个类中，并应用到所有控制器上；</li>
<li>3.2 之前，只能通过 <code>ContentNegotiatingViewResolver</code> 使用完整的内容协商（full content negotiating）功能。但在 3.2 中，完整的内容协商功能可以在整个 Spring MVC 中使用，即便是依赖于消息转换器使用和产生内容的控制器方法也能使用该功能；</li>
<li>3.2 包含了一个新的 <code>@MatrixVariable</code> 注解，能够将请求中的矩阵变量绑定到处理器的方法参数中；</li>
<li>基础的抽象类 <code>AbstractDispatcherServletInitializer</code> 能够非常便利地配置 <code>DispatcherServlet</code>，而不必再使用 web.xml。与之类似，当希望通过基于 Java 的方式来配置 Spring 时，可以使用 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 的子类；</li>
<li>新增了 <code>ResponseEntityExceptionHandler</code>，可以用来替代 <code>DefaultHandlerException Resolver</code>。<code>ResponseEntityExceptionHandler</code> 方法会返回 <code>ResponseEntity&lt;Object&gt;</code>，而不是 <code>ModelAndView</code>；</li>
<li><code>RestTemplate</code> 和 <code>@RequestBody</code> 的参数可以支持泛型；</li>
<li><code>RestTemplate</code> 和 <code>@RequestMapping</code> 可以支持 HTTP <code>PATCH</code> 方法；</li>
<li>在拦截器匹配时，支持使用 URL 模式将其排除在拦截器的处理功能之外。</li>
</ul>
<p>3.2 也增加了多项非 MVC 的功能改善。</p>
<ul>
<li><code>@Autowired</code>、<code>@Value</code> 和 <code>@Bean</code> 注解能够作为元注解，用于创建自定义的注入和 bean 声明注解；</li>
<li><code>@DateTimeFormat</code> 注解不再强依赖 JodaTime。如果提供了 JodaTime，就会使用它，否则会使用 SimpleDateFormat；</li>
<li>Spring 的声明式缓存提供了对 JCache 0.5 的支持；</li>
<li>支持定义全局的格式来解析和渲染日期与时间；</li>
<li>在集成测试中，能够配置和加载 <code>WebApplicationContext</code>；</li>
<li>在集成测试中，能够针对 request 和 session 作用域的 bean 进行测试。</li>
</ul>
<p><strong>4.0</strong></p>
<ul>
<li>对 WebSocket 编程的支持，包括支持 JSR-356——Java API for WebSocket；</li>
<li>鉴于 WebSocket 仅仅提供了一种低层次的 API，急需高层次的抽象，因此 4.0 在 WebSocket 之上提供了一个高层次的面向消息的编程类型，该模型基于 SockJS，并且包含了对 STOMP 协议的支持；</li>
<li>新的消息（messaging）模块，很多的类型来源于 Spring Integration 项目。这个消息模块支持 Spring 的 SockJS/STOMP 功能，同时提供了基于模板的方式发布消息；</li>
<li>支持 Java 8 特性；</li>
<li>支持 JSR-310——Date 与 Time API，比 <code>java.util.Date</code> 或 <code>java.util.Calendar</code> 更丰富的 API；</li>
<li>为 Groovy 开发的应用程序提供了更加顺畅的编程体验；</li>
<li>添加了条件化创建 bean 的功能；</li>
<li>包含了 <code>RestTemplate</code> 的一个新的异步实现；</li>
<li>添加了对多项 JEE 规范的支持，包括 JMS 2.0、JTA 1.2、JPA 2.1 和 Bean Validation 1.1。</li>
</ul>
<h1 id="第-2-章-装配-bean"><a href="#第-2-章-装配-bean" class="headerlink" title="第 2 章 装配 bean"></a>第 2 章 装配 bean</h1><h2 id="配置的可选方案"><a href="#配置的可选方案" class="headerlink" title="配置的可选方案"></a>配置的可选方案</h2><p>3 种主要的装配机制：</p>
<ul>
<li>在 XML 中进行显式配置；</li>
<li>在 Java 中进行显式配置；</li>
<li>隐式的 bean 发现机制和自动装配。</li>
</ul>
<h2 id="通过-XML-装配-bean"><a href="#通过-XML-装配-bean" class="headerlink" title="通过 XML 装配 bean"></a>通过 XML 装配 bean</h2><p><strong>创建 XML 配置规范</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- configuration details --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>声明 <bean></bean></strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myClass"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyClass"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>若不指明 ID，则默认为类名首字母小写 + “#0”。后续声明的同类型实例就是类名首字母小写 + “#1”。</p>
<p><strong>构造器注入 bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myOutterClass"</span> <span class="attr">class</span>=<span class="string">"com.demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"myClass"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或使用 c- 命名空间（3.0 中引入）。<br>首先在顶部声明命名空间模式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myOutterClass"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyOutterClass"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:myClass-ref</span>=<span class="string">"myClass"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该属性名的结构：</p>
<ul>
<li><code>c:</code> c-命名空间前缀</li>
<li><code>myClass</code> 构造器参数名</li>
<li><code>-ref</code> 注入 bean 引用。去掉此项则注入字面量。</li>
<li><code>&quot;myClass&quot;</code> 要注入的 bean ID</li>
</ul>
<p>由于引用了构造器参数名，所以如果移除构建过程中的调试标志（debug symbol）就无法正常执行了。</p>
<p>替代方案是使用参数在参数列表中的位置信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myOutterClass"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyOutterClass"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_0-ref</span>=<span class="string">"myClass"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为 XML 中不允许数字作为属性的第一个字符，所以要添加一个下划线。</p>
<p>若只有一个构造器参数，则可以不用标示参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myOutterClass"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyOutterClass"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">c:_-ref</span>=<span class="string">"myClass"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>构造器注入字面量</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myClass"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyClass"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"abc"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>构造器装配集合</strong></p>
<h2 id="通过-Java-代码装配-bean"><a href="#通过-Java-代码装配-bean" class="headerlink" title="通过 Java 代码装配 bean"></a>通过 Java 代码装配 bean</h2><p><strong>创建配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 web 环境下还需要做以下配置来让 spring 知道配置类的位置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.example.MyConfiguration<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>声明 bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyClass <span class="title">myClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Bean</code> 告诉 Spring 将该方法返回的对象注册为 bean，ID 默认为方法名，也可指定 ID：<code>@Bean(name=&quot;myClass&quot;)</code>。</p>
<p><strong>借助 JavaConfig 实现注入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyOutterClass <span class="title">myOutterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyOutterClass(myClass())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种通过调用方法来引用 bean 的方式有时候可能引起误解，让人以为每次都拿到一个新的对象，而实际上 Spring 的 bean 默认是单例的。</p>
<p>可以换一种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyOutterClass <span class="title">myOutterClass</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyOutterClass(myClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式一方面不易引起误解，另一方面允许 <code>myClass</code> 声明于其他地方。</p>
<h2 id="隐式的-bean-发现机制和自动装配"><a href="#隐式的-bean-发现机制和自动装配" class="headerlink" title="隐式的 bean 发现机制和自动装配"></a>隐式的 bean 发现机制和自动装配</h2><p><strong>创建可被发现的 bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"myFirstClass"</span>) <span class="comment">// 不指定 ID 的话默认会将类名首字母小写作为 ID</span></span><br><span class="line"><span class="comment">//@Named("myFirstClass") // Spring 支持 Java 依赖注入规范，大多数场景中两者可互相替换</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启用组件扫描</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=<span class="string">"com.demo"</span>) <span class="comment">// 不指定基础包的话会以此配置类所在包为基础包</span></span><br><span class="line"><span class="comment">//@ComponentScan(basePackages=&#123;"com.demo","com.demo1"&#125;) // 支持指定多个基础包</span></span><br><span class="line"><span class="comment">//@ComponentScan(basePackageClasses=&#123;MyClass.class, MyClass1.class&#125;)</span></span><br><span class="line"><span class="comment">// 通过类型安全的方式指定基础包，即指定类所在的包。</span></span><br><span class="line"><span class="comment">// 推荐在基础包中创建一个用来进行扫描的空标记接口，方便在修改业务代码的时候不影响组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有其他配置的话，<code>@ComponentScan</code> 默认会扫描与配置类相同的包以及子包，查找带有 <code>@Component</code> 注解的类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:Context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.demo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>通过注解实现自动装配</strong></p>
<p>在任何方法上使用 <code>@Autowired</code>，Spring 会根据方法参数类型传入适当的 bean。</p>
<p>若没有匹配的 bean，Spring 会抛出一个异常。可将 <code>@Autowired</code> 的 <code>required</code> 属性设置为 <code>false</code>，从而在匹配不到的时候传入 null，且避免抛出异常。</p>
<p>可替换为 Java 依赖注入规范中的 <code>@Inject</code>。</p>
<h2 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h2><p>javaConfig 导入 javaConfig 和 xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;SubConfig1.class, SubConfig2.class&#125;)</span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:test.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml 导入 javaConfig 和 xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"me.example.BasicConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"cdplayer-config.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="第-3-章-高级装配"><a href="#第-3-章-高级装配" class="headerlink" title="第 3 章 高级装配"></a>第 3 章 高级装配</h1><h2 id="环境与-profile"><a href="#环境与-profile" class="headerlink" title="环境与 profile"></a>环境与 profile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">//作用于类中所有 bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileBeanConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">//作用于单个 bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XHLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>＞</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">  &lt;beans profile="dev"&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyBean"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"prod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"com.demo.MyBean"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring 在确定激活的 profile 时，依赖两个独立的属性：<code>spring.profiles.active</code> 和 <code>spring.profiles.default</code>。</p>
<p>有多种方式来设置：</p>
<ul>
<li>作为 <code>DispatcherServlet</code> 的初始化参数</li>
<li>作为 Web 应用的上下文参数</li>
<li>作为 JNDI 条目</li>
<li>作为环境变量</li>
<li>作为 JVM 的系统属性</li>
<li>在集成测试类上，使用 <code>@ActiveProfiles</code> 注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 为上下文设置默认的 profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以设置多个 profile --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;param-value&gt;dev1,dev2&lt;/param-value&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 为 Servlet 设置默认的 profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="条件化的-bean"><a href="#条件化的-bean" class="headerlink" title="条件化的 bean"></a>条件化的 bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MagicExistsCondition.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MagicBean <span class="title">magicBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    AnnotatedTypedMetadata metadata)</span> </span>&#123;</span><br><span class="line">    Environment env = context.getEnvironment();</span><br><span class="line">    <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>ConditionContext</code>：</p>
<ul>
<li>借助 <code>getRegistry()</code> 返回的 <code>BeanDefinitionRegistry</code> 检查 bean 定义；</li>
<li>借助 <code>getBeanFactory()</code> 返回的 <code>ConfigurableListableBeanFactory</code> 检查 bean 是否存在，甚至探查 bean 的属性；</li>
<li>借助 <code>getEnvironment()</code> 返回的 <code>Environment</code> 检查环境变量是否存在以及值；</li>
<li>读取并探查 <code>getResourceLoader()</code> 返回的 <code>ResourceLoader</code> 所加载的资源；</li>
<li>借助 <code>getClassLoader()</code> 返回的 <code>ClassLoader</code> 加载并检查类是否存在。</li>
</ul>
<p>其中的 <code>AnnotatedTypeMetadata</code> 能检查 <code>@Bean</code> 注解的方法上还有什么其他的注解以及它们的属性。</p>
<h2 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h2><h3 id="标示首选的-bean"><a href="#标示首选的-bean" class="headerlink" title="标示首选的 bean"></a>标示首选的 bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123;<span class="comment">/*bla*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dessert <span class="title">iceCream</span><span class="params">()</span> </span>&#123;<span class="comment">/*bla*/</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"iceCream"</span> <span class="attr">class</span>=<span class="string">"com.demo.IceCream"</span> <span class="attr">primary</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="限定自动装配的-bean"><a href="#限定自动装配的-bean" class="headerlink" title="限定自动装配的 bean"></a>限定自动装配的 bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>) <span class="comment">//指定 bean 的限定符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dessert = dessert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean 的限定符和 ID 本质上是独立的。bean 创建时若不指定限定符，则默认用 ID 作为限定符。</p>
<p>若使用默认限定符的话，当重命名类名之后，之前使用 <code>@Qualifier</code> 注入的地方就会报错了。可以在 bean 声明上也添加 <code>@Qualifier</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>有时需要用多个限定符来确定唯一的 bean，但是又不能用多个 <code>@Qualifier</code> （Java 8 开始允许出现重复的注解，只要该注解本身带有 <code>@Repeatable</code> 注解，但是 <code>@Qualifier</code> 没有 <code>@Repeatable</code> 注解）。此时可以使用 <code>@Qualifier</code> 来实现自定义的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,</span><br><span class="line">         ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Creamy &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以用多个自定义的注解来确定唯一的 bean。</p>
<h2 id="bean-的作用域"><a href="#bean-的作用域" class="headerlink" title="bean 的作用域"></a>bean 的作用域</h2><ul>
<li>单例（Singleton）：整个应用中，只创建 bean 的一个实例。（默认）</li>
<li>原型（Prototype）：每次注入或通过 Spring 上下文获取时都会创建一个新的 bean 实例。</li>
<li>会话（Session）：在 Web 应用中，为每个会话创建一个 bean 实例。</li>
<li>请求（Request）：在 Web 应用中，为每个请求创建一个 bean 实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Notepad <span class="title">notepad</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"notepad"</span> <span class="attr">class</span>=<span class="string">"com.myapp.Notepad"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">       proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShoppingCart <span class="title">cart</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cart"</span> <span class="attr">class</span>=<span class="string">"com.demo.ShoppingCart"</span> <span class="attr">scope</span>=<span class="string">"session"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 默认使用 CGLib 创建目标类的代理 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置成基于接口的代理 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于会话和请求作用域的 bean 是跟随着会话和请求而创建的，因此在初始化 Spring 上下文的时候没法注入到其他 bean 里去。</p>
<p>通过 <code>proxyMode</code> 属性来解决这个问题。{@link ScopedProxyMode}<br>Spring 会将代理类注入到其他 bean 中。在运行期，代理类会负责将方法调用转发给作用域内真正的 bean。</p>
<ul>
<li>INTERFACES：创建一个 JDK 动态代理，该代理实现了目标接口；</li>
<li>TARGET_CLASS：使用 CGLib 创建目标类的代理；</li>
<li>NO：不创建作用域代理（对于作用域 bean 没用）</li>
<li>DEFAULT：通常默认值为 <code>NO</code>，也可以在 component-scan 层进行自定义配置。</li>
</ul>
<h2 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h2><p>Spring 提供了两种运行时求值的方式：</p>
<ul>
<li>属性占位符（Property placeholder）</li>
<li>Spring 表达式语言（SpEL）</li>
</ul>
<h3 id="注入外部的值"><a href="#注入外部的值" class="headerlink" title="注入外部的值"></a>注入外部的值</h3><p>为了使用占位符，需要配置一个 <code>PropertyPlaceholderConfigurer</code> bean 或 <code>PropertySourcesPlaceholderConfigurer</code> bean。</p>
<p>从 Spring 3.1 开始，推荐 <code>PropertySourcesPlaceholderConfigurer</code>，它能基于 <code>Environment</code> 及其属性源来解析占位符。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ignore-resource-not-found</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">location</span>=<span class="string">"classpath:/com/soundsystem/app.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/soundsystem/app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  Environment env;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeHolderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BlankDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">      env.getProperty(<span class="string">"disc.title"</span>),</span><br><span class="line">      env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖自动装配时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @Value(<span class="string">"$&#123;disc.title&#125;"</span>)</span> String title,</span></span><br><span class="line"><span class="function">  @<span class="title">Value</span><span class="params">(<span class="string">"$&#123;disc.artist&#125;"</span>)</span> String artist) </span>&#123;</span><br><span class="line">  <span class="comment">//blabla</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getProperty</code> 有 4 个重载方法：</p>
<ul>
<li><code>String getPropety(String key)</code></li>
<li><code>String getProperty(String key, String defaultValue)</code></li>
<li><code>T getProperty(String key, Class&lt;T&gt; type)</code></li>
<li><code>T getProperty(String key, Class&lt;T&gt; type, T defaultValue)</code></li>
</ul>
<p><code>Environment</code> 的其他方法：</p>
<ul>
<li><code>getRequiredProperty()</code> 获取到 null 会抛出 <code>IllegalStateException</code></li>
<li><code>containsProperty()</code></li>
<li><code>getPropertyAsClass()</code></li>
<li><code>String[] getActiveProfiles()</code></li>
<li><code>String[] getDefaultProfiles()</code></li>
<li><code>boolean acceptsProfiles(String... profiles)</code></li>
</ul>
<p><strong>关于 <code>@PropertySource</code> 的解析</strong></p>
<p><code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code></p>
<h3 id="使用-Spring-表达式进行装配"><a href="#使用-Spring-表达式进行装配" class="headerlink" title="使用 Spring 表达式进行装配"></a>使用 Spring 表达式进行装配</h3><p>SpEL 的特性包括：</p>
<ul>
<li>使用 bean 的 ID 来引用 bean；</li>
<li>调用方法和访问对象的属性；</li>
<li>对值进行算术、关系和逻辑运算；</li>
<li>正则表达式匹配；</li>
<li>集合操作。</li>
</ul>
<p><strong>表示字面量</strong></p>
<p><code>#{3.14}</code> <code>#{1.23E4}</code> 浮点值<br><code>#{&#39;Hello&#39;}</code> 字符串<br><code>#{false}</code> 布尔值</p>
<p><strong>引用 bean、属性和方法</strong></p>
<p><code>#{sgtPeppers}</code> 引用一个 bean<br><code>#{sgtPeppers.fieldA}</code> bean 的属性<br><code>#{artistSelector.selectArtist()}</code> 调用 bean 的方法<br><code>#{artistSelector.selectArtist()?.toUpperCase()}</code> 调用返回值的方法。<code>?</code> 会进行判空，为空则直接返回 null，因而不会空指针异常</p>
<p><strong>在表达式中使用类型</strong></p>
<p><code>#{T(java.lang.Math).PI}</code> 访问类的静态成员<br><code>#{T(java.lang.Math).random()}</code> 访问类的静态方法</p>
<p><strong>SpEL 运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符类型</th>
<th style="text-align:left">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">算术运算</td>
<td style="text-align:left">+、-、*、/、%、^</td>
</tr>
<tr>
<td style="text-align:left">比较运算</td>
<td style="text-align:left">&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge</td>
</tr>
<tr>
<td style="text-align:left">逻辑运算</td>
<td style="text-align:left">and、or、not、\</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">条件运算</td>
<td style="text-align:left">?: (ternary)、?: (Elvis)</td>
</tr>
<tr>
<td style="text-align:left">正则表达式</td>
<td style="text-align:left">matches</td>
</tr>
</tbody>
</table>
<p><code>#{scoreboard.score &gt; 1000 ? &quot;Winner&quot; : &quot;Loser&quot;}</code> 三元运算<br><code>#{disc.title ?: &#39;Default Title&#39;}</code> 为 null 的话取默认值；<code>?:</code> 也可以简写成 <code>:</code></p>
<p><strong>计算正则表达式</strong></p>
<p><code>#{user.email matches &#39;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com}</code></p>
<p><strong>计算集合</strong></p>
<p><code>#{jukebox.songs[4].title}</code> 引用第 5 个元素的属性（索引从 0 开始）<br><code>#{jukebox.songs.?[artist eq &#39;Aerosmith&#39;]}</code> 对集合进行过滤。除此之外，<code>.^[]</code> 和 <code>.$[]</code> 分别查询第一个和最后一个匹配项；<code>.![]</code> 取每个元素的某个字段，并组成一个新的集合</p>
<h1 id="第-4-章-面向切面的-Spring"><a href="#第-4-章-面向切面的-Spring" class="headerlink" title="第 4 章 面向切面的 Spring"></a>第 4 章 面向切面的 Spring</h1><h3 id="定义-AOP-术语"><a href="#定义-AOP-术语" class="headerlink" title="定义 AOP 术语"></a>定义 AOP 术语</h3><p><strong>通知（Advice）</strong></p>
<p>切面的工作被称为通知。通知定义了“何时”、“何事”。</p>
<p>Spring 切面可以应用 5 种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法调用之前</li>
<li>后置通知（After）：在目标方法完成之后，此时不关心方法的输出是什么</li>
<li>返回通知（After-returning）：在目标方法成功执行之后</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后</li>
<li>环绕通知（Around）：在目标方法调用之前和之后</li>
</ul>
<p><strong>连接点（Join point）</strong></p>
<p>连接点是在应用执行过程中能够插入切面的一个点。比如调用方法时、抛出异常时等等。</p>
<p><strong>切点（Pointcut）</strong></p>
<p>切点定义了“何处”。</p>
<p><strong>切面（Aspect）</strong></p>
<p>切面是通知和切点的结合。</p>
<p><strong>引入（Introduction）</strong></p>
<p>引入允许我们向现有的类添加新方法或属性。</p>
<p><strong>织入（Weaving）</strong></p>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多个点可以进行织入：</p>
<ul>
<li>编译期：这种方式需要特殊的编译器。AspectJ 的织入编译器就是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到 JVM 时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5 的加载时织入（load-time weaving,LTW）就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入，一般在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。</li>
</ul>
<h3 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h3><p>Spring 提供了 4 种类型的 AOP 支持：</p>
<ul>
<li>基于代理的经典 Spring AOP；</li>
<li>纯 POJO 切面；</li>
<li><code>@AspectJ</code> 注解驱动的切面；</li>
<li>注入式 AspectJ 切面（适用于 Spring 各版本）</li>
</ul>
<h2 id="通过切点来选择连接点"><a href="#通过切点来选择连接点" class="headerlink" title="通过切点来选择连接点"></a>通过切点来选择连接点</h2><table>
<thead>
<tr>
<th style="text-align:left">AspectJ 指示器</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">arg()</td>
<td style="text-align:left">限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr>
<td style="text-align:left">@args()</td>
<td style="text-align:left">限制连接点匹配参数由指定注解标注的执行方法</td>
</tr>
<tr>
<td style="text-align:left">execution()</td>
<td style="text-align:left">用于匹配是连接点的执行方法</td>
</tr>
<tr>
<td style="text-align:left">this()</td>
<td style="text-align:left">限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:left">限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr>
<td style="text-align:left">@target()</td>
<td style="text-align:left">限制连接点匹配特定的执行对象，这些对象对应的类要具有特定类型的注解</td>
</tr>
<tr>
<td style="text-align:left">within()</td>
<td style="text-align:left">限制连接点匹配指定的类型</td>
</tr>
<tr>
<td style="text-align:left">@within()</td>
<td style="text-align:left">限制连接点匹配指定注解所标注的类型（当使用 Spring AOP 时，方法定义在由指定的注解所标注的类里）</td>
</tr>
<tr>
<td style="text-align:left">@annotation</td>
<td style="text-align:left">限定匹配带有指定注解的连接点</td>
</tr>
</tbody>
</table>
<h3 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)</span><br><span class="line">|----1----|2|---------3---------|---4---|-5-|-6-|--------7-------|</span><br></pre></td></tr></table></figure>
<ol>
<li>在方法执行时触发</li>
<li>返回任意类型</li>
<li>方法所属的类</li>
<li>方法名</li>
<li>使用任意参数</li>
<li>通过操作符连接多个指示器。操作符包括 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code>，也可以用 <code>and</code>、<code>or</code>、<code>not</code> 代替</li>
</ol>
<h3 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h3><p>Spring 还引入了一个新的 <code>bean()</code> 指示器，用来通过 bean ID 来标识 bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..)) and bean(&apos;woodstock&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="使用注解创建切面"><a href="#使用注解创建切面" class="headerlink" title="使用注解创建切面"></a>使用注解创建切面</h2><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">通知</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@After</td>
<td style="text-align:left">通知方法会在目标方法返回或抛出异常后调用</td>
</tr>
<tr>
<td style="text-align:left">@AfterReturning</td>
<td style="text-align:left">通知方法会在目标方法返回后调用</td>
</tr>
<tr>
<td style="text-align:left">@AfterThrowing</td>
<td style="text-align:left">通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr>
<td style="text-align:left">@Around</td>
<td style="text-align:left">通知方法会将目标方法封装起来</td>
</tr>
<tr>
<td style="text-align:left">@Before</td>
<td style="text-align:left">通知方法会在目标方法调用之前执行</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明这个类是一个切面，但不表明会启用切面功能。</span></span><br><span class="line"><span class="comment">//而且依然是用 Spring 基于代理的切面，而不是 AspectJ 的切面。</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这个方法的内容不重要，只是为了给 <span class="doctag">@Pointcut</span> 提供一个附着点。</span></span><br><span class="line"><span class="comment">   * 方法名会作为切点的标识符。这样就可以重用同一个切点。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * args() 中的参数名要与切点方法中的参数名相匹配</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(</span><br><span class="line">    <span class="string">"execution(** concert.Performance.performAfterEncore(String)"</span></span><br><span class="line">    + <span class="string">"and args(encoreContent)"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encore</span><span class="params">(String encoreContent)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Wow!"</span> + encoreContent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//blabla</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//blabla</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//blabla</span></span><br><span class="line">      jp.proceed();<span class="comment">// 需要手动调用切点方法</span></span><br><span class="line">      <span class="comment">//blabla</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">      <span class="comment">//blabla</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启用切面</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//启用 AspectJ 自动代理</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"concert"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启用 AspectJ 自动代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"concert.Audience"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过注解引入新功能"><a href="#通过注解引入新功能" class="headerlink" title="通过注解引入新功能"></a>通过注解引入新功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoreableIntroducer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@DeclareParents</span>(value=<span class="string">"concert.Performance+"</span>, defaultImpl=DefaultEncoreable.class)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@DeclareParents</code> 注解由三部分组成：</p>
<ul>
<li><code>value</code> 属性指定了哪种类型的 bean 要引入该接口。加号表示是它的所有子类型而不是它本身。</li>
<li><code>defaultImpl</code> 属性指定了为引入功能提供实现的类。</li>
<li><code>@DeclareParents</code> 所标注的静态属性指明了要引入的接口。</li>
</ul>
<p>此外要将切面声明为 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"concert.EncoreableIntroducer"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="在-XML-中声明切面"><a href="#在-XML-中声明切面" class="headerlink" title="在 XML 中声明切面"></a>在 XML 中声明切面</h2><table>
<thead>
<tr>
<th style="text-align:left">AOP 配置元素</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;aop:advisor&gt;</code></td>
<td style="text-align:left">定义 AOP 通知器</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:after&gt;</code></td>
<td style="text-align:left">定义 AOP 后置通知（不管被通知方法是否执行成功）</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:after-returning&gt;</code></td>
<td style="text-align:left">定义 AOP 返回通知</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:after-throwing&gt;</code></td>
<td style="text-align:left">定义 AOP 异常通知</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:around&gt;</code></td>
<td style="text-align:left">定义 AOP 环绕通知</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:aspect&gt;</code></td>
<td style="text-align:left">定义一个切面</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:aspectj-autoproxy&gt;</code></td>
<td style="text-align:left">启用 <code>@AspectJ</code> 注解驱动的切面</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:before&gt;</code></td>
<td style="text-align:left">定义一个 AOP 前置通知</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:config&gt;</code></td>
<td style="text-align:left">顶层的 AOP 配置元素。大多数的 <code>&lt;aop:*&gt;</code> 元素必须包含在此元素内。</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:declare-parents&gt;</code></td>
<td style="text-align:left">以透明的方式为被通知的对象引入额外的接口</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;aop:pointcut&gt;</code></td>
<td style="text-align:left">定义一个切点</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"performance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">expression</span>=<span class="string">"execution(** concert.Performance.perform(..))"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"takeSeats"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引入 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- default-impl 也可以换成 delegate-ref="&#123;beanId&#125;" --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">      <span class="attr">types-matching</span>=<span class="string">"concert.Performance+"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">implement-interface</span>=<span class="string">"concert.Encoreable"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-impl</span>=<span class="string">"concert.DefaultEncoreable"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>proxy-target-class=&quot;true&quot;</code>：使用 CGLIB 创建子类来实现代理（否则使用 java dynamic proxy 基于接口来创建）。具体用哪种方法的判断见 <code>DefaultAopProxyFactory</code>。</p>
<h2 id="切面的一些实践细节"><a href="#切面的一些实践细节" class="headerlink" title="切面的一些实践细节"></a>切面的一些实践细节</h2><h3 id="连接点对象-ProceedingJoinPoint"><a href="#连接点对象-ProceedingJoinPoint" class="headerlink" title="连接点对象 ProceedingJoinPoint"></a>连接点对象 ProceedingJoinPoint</h3><p>假设被切面包裹的类如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">ExampleTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// blabla</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>jp.getKind()</code></p>
<p>method-execution（应该还有其他枚举值）</p>
<p><code>jp.getSignature().getDeclaringTypeName()</code></p>
<p>com.example.ExampleTarget</p>
<p><code>jp.getSignature().getName()</code></p>
<p>test</p>
<p><code>jp.getTarget().toString()</code></p>
<p>com.example.ExampleTarget@15a3d5a</p>
<p>后面的十六进制代码是 Object 类默认的基于对象内存地址计算出的 hashCode。</p>
<p><code>jp.getTarget().getClass().toString()</code> <code>jp.getSignature().getDeclaringType().toString()</code></p>
<p>class com.example.ExampleTarget</p>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h2><p>Spring 的事务管理器都是 <code>PlatformTransactionManager</code> 的实现。</p>
<h3 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事务管理器通过调用 <code>java.sql.connection</code> 来管理事务。</p>
<h3 id="Hibernate-事务"><a href="#Hibernate-事务" class="headerlink" title="Hibernate 事务"></a>Hibernate 事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事务管理器通过调用 <code>org.hibernate.Transaction</code> 对象来管理事务。</p>
<h3 id="JPA-事务"><a href="#JPA-事务" class="headerlink" title="JPA 事务"></a>JPA 事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">ref</span>=<span class="string">"entityManagerFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JTA-事务"><a href="#JTA-事务" class="headerlink" title="JTA 事务"></a>JTA 事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManagerName"</span> <span class="attr">value</span>=<span class="string">"java:/TransactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="在-Spring-中的编码事务"><a href="#在-Spring-中的编码事务" class="headerlink" title="在 Spring 中的编码事务"></a>在 Spring 中的编码事务</h2><p>调用 <code>TransactionTemplate.execute()</code> 方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="定义事务属性"><a href="#定义事务属性" class="headerlink" title="定义事务属性"></a>定义事务属性</h3><p>事务属性描述了事务策略，包括 5 个方面。</p>
<p><strong>传播行为</strong></p>
<p><code>PROPAGATION_MANDATORY</code></p>
<p>表示该方法必须在事务中运行。如果当前事务不存在，则会抛出异常。</p>
<p><code>PROPAGATION_NESTED</code></p>
<p>表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，则其行为与 <code>PROPAGATION_REQUIRED</code> 一样。各厂商对这种行为的支持有所差异。</p>
<p><code>PROPAGATION_NEVER</code></p>
<p>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</p>
<p><code>PROPAGATION_NOT_SUPPORTED</code></p>
<p>表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用 <code>JTATransactionManager</code> 的话，则需要访问 <code>TransactionManager</code>。</p>
<p><code>PROPAGATION_REQUIRED</code></p>
<p>表示当前方法必须运行在事务中。如果不存在当前事务，则会启动一个新事务。</p>
<p><code>PROPAGATION_REQUIRES_NEW</code></p>
<p>表示当前方法必须运行在它自己的事务中。如果不存在当前事务，则会启动一个新事务。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 <code>JTATransactionManager</code> 的话，则需要访问 <code>TransactionManager</code>。</p>
<p><code>PROPAGATION_SUPPORTS</code></p>
<p>表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。</p>
<p><strong>隔离级别</strong></p>
<p>并发事务可能产生的问题：</p>
<ul>
<li>脏读：A 读取了 B 改写的但未提交的数据，然后 B 回滚了，因此 A 读取的数据是无效的。</li>
<li>不可重复读：A 先后执行两次相同的查询，但两次数据不同，因为 B 在之间修改了数据。</li>
<li>幻读：A 读取了几行数据，然后 B 插入了一些数据，接着 A 在查询时发现多了一些原本不存在的记录。</li>
</ul>
<p>不同的隔离级别：</p>
<p><code>ISOLATION_DEFAULT</code> 使用后端数据库默认的隔离级别。</p>
<p><code>ISOLATION_READ_UNCOMMITTED</code> 允许读取尚未提交的数据变更。可能会导致脏读、幻读和不可重复读。</p>
<p><code>ISOLATION_READ_COMMITTED</code> 允许读取并发事务已经提交的数据。可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<p><code>ISOLATION_REPEATABLE_READ</code> 对同一字段的多次读取结果是一致的。除非数据是被本事务自己所修改。可以阻止脏读和不可重复读，但幻读仍有可能。</p>
<p><code>ISOLATION_SERIALIZABLE</code> 完全服从 ACID 的隔离级别，确保阻止脏读、不可重复读以及幻读。这是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的。</p>
<p><strong>只读</strong></p>
<p>若事务只对后端的数据库进行读操作，数据库可以利用事务的只读特性来进行一些特定的优化。因为只读优化实在事务启动时由数据库实施的，所以只对那些具备启动新事务的传播行为有效。</p>
<p><strong>事务超时</strong></p>
<p>因为超时时钟在事务创建时启动，所以只对那些具备启动新事务的传播行为有效。</p>
<p><strong>回滚规则</strong></p>
<p>默认情况下，事务只有在遇到运行期异常时才会回滚，遇到检查型异常时不会。</p>
<h3 id="在-XML-中声明事务"><a href="#在-XML-中声明事务" class="headerlink" title="在 XML 中声明事务"></a>在 XML 中声明事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动注解驱动的事务管理 @Transactional --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认为 id="transactionManager" 的 bean，若不是这个 id 则需写明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- transaction-manager 默认为 id="transactionManager" 的 bean，若不是这个 id 则需写明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5 个事务属性对应的 xml 属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">isolation</td>
<td style="text-align:left">指定事务的隔离级别</td>
</tr>
<tr>
<td style="text-align:left">propagation</td>
<td style="text-align:left">定义事务的传播规则</td>
</tr>
<tr>
<td style="text-align:left">read-only</td>
<td style="text-align:left">指定事务为只读</td>
</tr>
<tr>
<td style="text-align:left">rollback-for, no-rollback-for</td>
<td style="text-align:left">rollback-for 指定事务对于哪些检查型异常应当回滚而不提交；no-rollback-for 指定事务对于哪些异常应当继续执行而不回滚。</td>
</tr>
<tr>
<td style="text-align:left">timeout</td>
<td style="text-align:left">对于长时间运行的事务定义超时时间</td>
</tr>
</tbody>
</table>
<h1 id="第-5-章-构建-Spring-Web-应用程序"><a href="#第-5-章-构建-Spring-Web-应用程序" class="headerlink" title="第 5 章 构建 Spring Web 应用程序"></a>第 5 章 构建 Spring Web 应用程序</h1><h1 id="第-6-章-渲染-Web-视图"><a href="#第-6-章-渲染-Web-视图" class="headerlink" title="第 6 章 渲染 Web 视图"></a>第 6 章 渲染 Web 视图</h1><h1 id="第-7-章-Spring-MVC-的高级技术"><a href="#第-7-章-Spring-MVC-的高级技术" class="headerlink" title="第 7 章 Spring MVC 的高级技术"></a>第 7 章 Spring MVC 的高级技术</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>Web 应用服务器收到 HTTP 请求，根据 web.xml 中的配置，交给 DispatcherServlet 处理；</li>
<li>DispatcherServlet 根据请求中的信息以及配置的 HandlerMapping 搜索具体的处理器 handler。</li>
<li>用 HandlerAdapter 对 Handler 进行封装。DispatcherServlet 调用 HandlerAdapter.handle()，而 adapter 根据 handler 的不同采用不同的方法调用具体的方法；</li>
<li>处理器返回一个 ModelAndView 给 DispatcherServlet，其中包含了视图/视图名以及数据模型；</li>
<li>根据视图名解析得到实际的 View 对象（若上一步得到的是视图名而不是视图对象）；</li>
<li>用数据模型对视图对象进行渲染；</li>
<li>向客户端返回渲染结果。</li>
</ol>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h3><p>Spring 的 Resource 接口用于访问各类资源。</p>
<p>继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Resource</span><br><span class="line">|- WritableResource</span><br><span class="line">\- | AbstractResource</span><br><span class="line">   | |- ByteArrayResource</span><br><span class="line">   | |- InputStreamResource</span><br><span class="line">   | |- ClassPathResource</span><br><span class="line">   | |- PortletContextResource</span><br><span class="line">   | |- ServletContextResource</span><br><span class="line">   | |- DescriptiveResource</span><br><span class="line">   | |- UrlResource</span><br><span class="line">   +-+- PathResource</span><br><span class="line">   \-+- FileSystemResource</span><br></pre></td></tr></table></figure>
<p>可使用 PathMatchingResourcePatternResolver 通过资源前缀和 Ant 风格的通配符来自动加载 Resource。</p>
<p>资源地址前缀：</p>
<ul>
<li><code>classpath:</code> 类路径。<ul>
<li><code>classpath:</code> 和 <code>classpath:/</code> 等价。</li>
<li><code>classpath:</code> 加载第一个匹配的资源，<code>classpath*:</code> 加载所有匹配的资源。</li>
</ul>
</li>
<li><code>file:</code> 使用 UrlResource 从文件系统目录中加载，可使用绝对或相对路径。</li>
<li><code>http://</code> 使用 UrlResource 从 Web 服务器中装载资源。</li>
<li><code>ftp://</code> 使用 UrlResource 从 FTP 服务器中装载资源。</li>
<li><code>没前缀</code> 根据 ApplicationContext 的具体实现类采用对应类型的 Resource。</li>
</ul>
<p>Ant 风格的资源地址：</p>
<ul>
<li><code>?</code> 匹配文件名中的一个字符。</li>
<li><code>*</code> 匹配文件名中的任意字符。</li>
<li><code>**</code> 匹配多层路径。</li>
</ul>
<p>项目部署后没法通过 Resource#getFile() 操作文件，要使用 Resource#getInputStream()。</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>DispatcherServlet 可通过 <code>&lt;servlet&gt;</code> 的 <code>&lt;init-param&gt;</code> 配置参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/webApplicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>namespace：DispatcherServlet 的命名空间，默认为 <code>{servlet-name}-servlet</code>，用以构造 servlet 配置文件的路径。完整路径是“WEB-INF/{namespace}.xml”；</li>
<li>contextConfigLocation：指定 servlet 配置文件的路径，可为多个，逗号分隔；</li>
<li>publishContext：boolean 类型，默认为 true。DispatcherServlet 根据此属性决定是否将 WebApplicationContext 发布到 ServletContext 属性列表中，以便可以从 ServletContext 找到 WebApplicationContext 实例，对应的属性名为 DispatcherServlet#getServletContextAttributeName() 返回的值；</li>
<li>publishEvents：boolean 类型，默认为 true。当 DispatcherServlet 处理完一个请求后，是否需要向容器发布一个 ServletRequestHandledEvent 事件。如果容器中没有任何时间监听器，可设为 false，以提高性能。</li>
</ul>
<h3 id="内部逻辑"><a href="#内部逻辑" class="headerlink" title="内部逻辑"></a>内部逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);<span class="comment">//多部分请求解析器</span></span><br><span class="line">    initLocaleResolver(context);<span class="comment">//本地化解析器</span></span><br><span class="line">    initThemeResolver(context);<span class="comment">//主题解析器</span></span><br><span class="line">    initHandlerMappings(context);<span class="comment">//处理器映射器</span></span><br><span class="line">    initHandlerAdapters(context);<span class="comment">//处理器适配器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);<span class="comment">//处理器异常解析器</span></span><br><span class="line">    initRequestToViewNameTranslator(context);<span class="comment">//请求到视图名翻译器</span></span><br><span class="line">    initViewResolvers(context);<span class="comment">//视图解析器</span></span><br><span class="line">    initFlashMapManager(context);<span class="comment">//FlashMap 管理器，用于在不同请求间共享数据</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>org/springframework/web/servlet/DispatcherServlet.properties 中指定了默认组件。</p>
<p>这些组件都实现了 <code>org.springframework.core.Ordered</code> 接口，order 值越小优先级越高。</p>
<h4 id="消息转换器-HttpMessageConverter"><a href="#消息转换器-HttpMessageConverter" class="headerlink" title="消息转换器 HttpMessageConverter"></a>消息转换器 HttpMessageConverter</h4><p>DispatcherServlet 默认安装了 AnnotationMethodHandlerAdapter 作为 HandlerAdapter 的实现。该实现使用 HttpMessageConverter 将请求信息转换为对象。</p>
<ul>
<li><code>Boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType)</code>：指定转换器可以将请求信息转换为 clazz 类型对象，同时指定支持的 MIME 类型；</li>
<li><code>Boolean canWrite(Class&lt;?&gt; clazz, MedaiType mediaType)</code>：指定转换器可以将 clazz 类型对象写入响应流，同时指定响应流支持的 MIME 类型；</li>
<li><code>List&lt;MediaType&gt; getSupportedMediaTypes()</code>：转换器支持的媒体类型；</li>
<li><code>T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</code>：将请求信息转换为对象；</li>
<li><code>void write(T t, MediaType contentType, HttpOutputMessage outputMessage)</code>：将对象写到响应流，同时指定响应的媒体类型。</li>
</ul>
<p>HttpMessageConverter 的实现类：</p>
<ul>
<li>StringHttpMessageConverter：将请求信息转换为字符串；<ul>
<li>可读取所有媒体类型（<em>/</em>），可通过设置 `supportedMediaTypes 属性指定媒体类型；</li>
<li>响应的媒体类型为 text/plain；</li>
</ul>
</li>
<li>FormHttpMessageConverter：将表单数据读取到 MutiValueMap 中；<ul>
<li>可读取 application/x-www-form-urlencoded 的媒体类型，但不支持 multipart/form-data 类型；</li>
<li>可写 application/x-www-form-urlencoded 和 multipart/form-data 类型的响应；</li>
</ul>
</li>
<li>XmlAwareFormHttpMessageConverter：扩展自 FormHttpMessageConverter，如果部分表单数据是 xml，可用此转换器读取；</li>
<li>ResourceHttpMessageConverter：读写 <code>org.springframework.core.io.Resource</code> 对象；<ul>
<li>可读所有媒体类型；</li>
<li>若类路径下提供了 JAF（Java Activation Framework），则根据 Resource 的类型指定响应的媒体类型，否则响应的类型为 application/octet-stream；</li>
</ul>
</li>
<li>BufferedImageHttpMessageConverter：读写 <code>BufferedImage</code> 对象；<ul>
<li>可读所有媒体类型；</li>
<li>返回 <code>BufferedImage</code> 相应的媒体类型，也可通过 contentType 显式指定；</li>
</ul>
</li>
<li>ByteArrayHttpMessageConverter：读写二进制数据；<ul>
<li>可读所有媒体类型，可通过 <code>supportedMediaTypes</code> 属性指定媒体类型；</li>
<li>响应类型为 application/octet-stream；</li>
</ul>
</li>
<li>SourceHttpMessageConverter：读写 <code>javax.xml.transform.Source</code> 类型的数据；<ul>
<li>可读 text/xml 和 application/xml 类型；</li>
<li>响应类型为 text/xml 或 application/xml；</li>
</ul>
</li>
<li>MarshallingHttpMessageConverter：通过 Spring 的 <code>org.springframework.oxm.Marshaller</code> 和 <code>Unmarshaller</code> 读写 xml 消息；<ul>
<li>可读 text/xml 和 application/xml 类型；</li>
<li>响应类型为 text/xml 或 application/xml；</li>
</ul>
</li>
<li>Jaxb2RootElementHttpMessageConverter：通过 JAXB2 读写 xml 消息，将请求信息转换到注解 <code>@XmlRootElement</code> 或 <code>@XmlType</code> 的类中；<ul>
<li>可读 text/xml 和 application/xml 类型；</li>
<li>响应类型为 text/xml 或 application/xml；</li>
</ul>
</li>
<li>MappingJacksonHttpMessageConverter：利用 Jackson 开源类包的 <code>ObjectWrapper</code> 读写 JSON 数据；<ul>
<li>可读 application/json 类型；</li>
<li>响应类型为 application/json；</li>
</ul>
</li>
<li>RssChannelHttpMessageConverter：能读写 RSS 种子消息；<ul>
<li>可读 application/rss+xml 类型，转换为 <code>com.sun.syndication.feed.rss.Channel</code> 类型；</li>
<li>响应类型为 application/rss+xml；</li>
</ul>
</li>
<li>AtomFeedHttpMessageConverter：和 RssChannelHttpMessageConverter 能够读写 RSS 种子消息；<ul>
<li>可读 application/atom+xml 类型，转换为 <code>com.sun.syndication.feed.atom.Feed</code> 类型；</li>
<li>响应类型为 application/atom+xml。</li>
</ul>
</li>
</ul>
<p>AnnotationMethodHandlerAdapter 默认装配了以下转换器：</p>
<ul>
<li>ByteArrayHttpMessageConverter</li>
<li>StringHttpMessageConverter</li>
<li>SourceHttpMessageConverter</li>
<li>org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter</li>
</ul>
<h1 id="第-8-章-使用-Spring-Web-Flow"><a href="#第-8-章-使用-Spring-Web-Flow" class="headerlink" title="第 8 章 使用 Spring Web Flow"></a>第 8 章 使用 Spring Web Flow</h1><h1 id="第-9-章-保护-Web-应用"><a href="#第-9-章-保护-Web-应用" class="headerlink" title="第 9 章 保护 Web 应用"></a>第 9 章 保护 Web 应用</h1><h2 id="Spring-Security-的模块"><a href="#Spring-Security-的模块" class="headerlink" title="Spring Security 的模块"></a>Spring Security 的模块</h2><table>
<thead>
<tr>
<th style="text-align:left">模块</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACL</td>
<td style="text-align:left">支持通过访问控制列表（access control list,ACL）为域对象提供安全性</td>
</tr>
<tr>
<td style="text-align:left">切面（Aspects）</td>
<td style="text-align:left">一个很小的模块，当使用 Spring Security 注解时，会使用基于 AspectJ 的切面，而不是使用标准的 Spring AOP</td>
</tr>
<tr>
<td style="text-align:left">CAS 客户端（CAS Client）</td>
<td style="text-align:left">提供与 Jasig 的中心认证服务（Central Authentication Service, CAS）进行集成的功能</td>
</tr>
<tr>
<td style="text-align:left">配置（Configuration）</td>
<td style="text-align:left">包含通过 XML 和 Java 配置 Spring Security 的功能支持</td>
</tr>
<tr>
<td style="text-align:left">核心（core）</td>
<td style="text-align:left">提供 Spring Security 基本库</td>
</tr>
<tr>
<td style="text-align:left">加密（Cryptography）</td>
<td style="text-align:left">提供了加密和密码编码功能</td>
</tr>
<tr>
<td style="text-align:left">LDAP</td>
<td style="text-align:left">支持基于 LDAP 进行认证</td>
</tr>
<tr>
<td style="text-align:left">OpenID</td>
<td style="text-align:left">支持使用 OpenID 进行集中式认证</td>
</tr>
<tr>
<td style="text-align:left">Remoting</td>
<td style="text-align:left">提供了对 Spring Remoting 的支持</td>
</tr>
<tr>
<td style="text-align:left">标签库（Tag Library）</td>
<td style="text-align:left">Spring Security 的 JSP 标签库</td>
</tr>
<tr>
<td style="text-align:left">Web</td>
<td style="text-align:left">提供了 Spring Security 基于 Filter 的 Web 安全性支持</td>
</tr>
</tbody>
</table>
<h1 id="第-10-章-通过-Spring-和-JDBC-征服数据库"><a href="#第-10-章-通过-Spring-和-JDBC-征服数据库" class="headerlink" title="第 10 章 通过 Spring 和 JDBC 征服数据库"></a>第 10 章 通过 Spring 和 JDBC 征服数据库</h1><h1 id="第-11-章-使用对象-关系映射持久化数据"><a href="#第-11-章-使用对象-关系映射持久化数据" class="headerlink" title="第 11 章 使用对象-关系映射持久化数据"></a>第 11 章 使用对象-关系映射持久化数据</h1><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>基于 JPA 的应用需要使用 <code>EntityManagerFactory</code> 的实现类来获取 <code>EntityManager</code> 实例。JPA 定义了两种类型的实体管理器：</p>
<ul>
<li>应用程序管理类型：程序负责打开和关闭实体管理器并在事务中进行控制。</li>
<li>容器管理类型：Java EE 负责创建和管理实体管理器，程序通过注入或 JNDI 来获取。</li>
</ul>
<p>分别对应的 Spring 工厂 bean：</p>
<ul>
<li><code>LocalEntityManagerFactoryBean</code></li>
<li><code>LocalContainerEntityManagerFactoryBean</code></li>
</ul>
<p>对于基于 Spring 的应用程序来说两者的区别只在于在 Spring 上下文中如何配置。</p>
<h3 id="配置应用程序管理类型的-JPA"><a href="#配置应用程序管理类型的-JPA" class="headerlink" title="配置应用程序管理类型的 JPA"></a>配置应用程序管理类型的 JPA</h3><p>首先定义一个持久化单元文件 persistence.xml，然后用它作为参数创建 <code>LocalEntityManagerFactoryBean</code>。</p>
<h3 id="配置容器管理类型的-JPA"><a href="#配置容器管理类型的-JPA" class="headerlink" title="配置容器管理类型的 JPA"></a>配置容器管理类型的 JPA</h3><p><code>jpaVendorAdapter</code> 属性指定 JPA 实现。</p>
<ul>
<li><code>EclipseLinkJpaVendorAdapter</code></li>
<li><code>HibernateJpaVendorAdapter</code></li>
<li><code>OpenJpaVendorAdapter</code></li>
<li><code>TopLinkJpaVendorAdapter</code> <em>Spring 3.1 中已废弃</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span><br><span class="line">    LocalContainerEntityManagerFactoryBean emfb =</span><br><span class="line">        <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    emfb.setDataSource(dataSource);</span><br><span class="line">    emfb.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class="line">    emfb.setPackagesToScan(<span class="string">"com.example"</span>);</span><br><span class="line">    <span class="keyword">return</span> emfb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-data-JPA"><a href="#Spring-data-JPA" class="headerlink" title="Spring-data JPA"></a>Spring-data JPA</h3><p>启动 Spring Data JPA 自动扩展 <code>Repository</code> 接口的功能。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">"com.example"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">transaction-manager-ref</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">entity-manager-factory-ref</span>=<span class="string">"entityManagerFactory"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="第-12-章-使用-NoSQL-数据库"><a href="#第-12-章-使用-NoSQL-数据库" class="headerlink" title="第 12 章 使用 NoSQL 数据库"></a>第 12 章 使用 NoSQL 数据库</h1><h2 id="使用-Redis-操作-key-value-数据"><a href="#使用-Redis-操作-key-value-数据" class="headerlink" title="使用 Redis 操作 key-value 数据"></a>使用 Redis 操作 key-value 数据</h2><h3 id="连接到-Redis"><a href="#连接到-Redis" class="headerlink" title="连接到 Redis"></a>连接到 Redis</h3><p>Spring Data Redis 提供四种客户端连接工厂：</p>
<ul>
<li><code>JedisConnectionFactory</code></li>
<li><code>JredisConnectionFactory</code></li>
<li><code>LettuceConnectionFactory</code></li>
<li><code>SrpConnectionFactory</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisCF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  JedisConnectionFactory cf = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">  cf.setHostName(<span class="string">"redis-server"</span>); <span class="comment">// 默认 localhost</span></span><br><span class="line">  cf.setPort(<span class="number">7379</span>); <span class="comment">// 默认 6379</span></span><br><span class="line">  cf.setPassword(<span class="string">"abc"</span>); <span class="comment">// 默认无密码</span></span><br><span class="line">  <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 apache 的 common-pool 中的 <code>GenericObjectPoolConfig</code> 来配置连接池。也可以用它的子类，来自 jedis 的 <code>JedisPoolConfig</code>，里面有一些默认配置。</p>
<ul>
<li><code>MaxTotal</code>: 最大连接数。</li>
<li><code>MaxIdle</code>: 最大空闲连接数。</li>
<li><code>MinIdle</code>: 最小空闲连接数。</li>
<li><code>blockWhenExhausted</code>: 连接用尽时调用者是否要等待。</li>
<li><code>MaxWaitMillis</code>: 连接耗尽时调用者最大等待时间。<code>blockWhenExhausted</code> 为 true 时此项才生效。</li>
<li><code>jmxEnabled</code>: jmx 监控。用来通过 jconsole 或 jvisualvm 观察连接池的情况。</li>
<li><code>minEvictableIdleTimeMillis</code>: 连接的空闲时间到达此值时会被移除。</li>
<li><code>numTestsPerEvictionRun</code>: 做空闲连接检测时每次的采样数。</li>
<li><code>testOnBorrow</code>: 从连接池获取连接时是否做有效性检测（ping），无效连接会被移除。</li>
<li><code>testOnReturn</code>: 向连接池归还连接时是否做有效性检测（ping），无效连接会被移除。</li>
<li><code>testWhileIdle</code>: 从连接池获取连接时是否做空闲检测，空闲超时的连接会被移除。</li>
<li><code>timeBetweenEvictionRunsMillis</code>: 空闲连接的检测周期，单位毫秒。</li>
</ul>
<h3 id="使用-RedisTemplate"><a href="#使用-RedisTemplate" class="headerlink" title="使用 RedisTemplate"></a>使用 RedisTemplate</h3><ul>
<li><code>RedisTemplate</code></li>
<li><p><code>StringRedisTemplate</code>: 键值都是 String。</p>
</li>
<li><p><code>opsForValue()</code>: 操作 String 值。</p>
</li>
<li><code>opsForList()</code>: 操作 list 值。</li>
<li><code>opsForSet()</code>: 操作 set 值。</li>
<li><code>opsForZSet()</code>: 操作 zset 值。</li>
<li><code>opsForHash()</code>: 操作 hash 值。</li>
<li><code>boundValueOps()</code>: 绑定 key 然后操作 String 值。</li>
<li><code>boundListOps()</code>: 绑定 key 然后操作 list 值。</li>
<li><code>boundSetOps()</code>: 绑定 key 然后操作 set 值。</li>
<li><code>boundZSetOps()</code>: 绑定 key 然后操作 zset 值。</li>
<li><code>boundHashOps()</code>: 绑定 key 然后操作 hash 值。</li>
</ul>
<h3 id="使用-key-和-value-的序列化器"><a href="#使用-key-和-value-的序列化器" class="headerlink" title="使用 key 和 value 的序列化器"></a>使用 key 和 value 的序列化器</h3><ul>
<li><code>GenericToStringSerializer</code>: 使用 Spring 转换服务。它本身做 <code>byte[]</code> 跟 <code>String</code> 的转换。可以设置 <code>ConversionService</code> 或 <code>TypeConverter</code> 来完成 <code>String</code> 跟对象的转换。</li>
<li><code>JacksonJsonRedisSerializer</code>: 使用 Jackson1，将对象序列化为 JSON。</li>
<li><code>Jackson2JsonRedisSerializer</code>: 使用 Jackson2，将对象序列化为 JSON。</li>
<li><code>JdkSerializationRedisSerializer</code>: 使用 Java 序列化。</li>
<li><code>OxmSerializer</code>: 使用 Spring O/X 映射的编排器（marshaler）和解排器（unmarshaler）实现序列化，用于 xml 序列化。</li>
<li><code>StringRedisSerializer</code>: 序列化 String 类型。</li>
</ul>
<p>效果概览</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a.b</span><br><span class="line"></span><br><span class="line"><span class="meta">@RedisHash</span>(<span class="string">"Test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEO</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constructor and getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JdkSerializationRedisSerializer</span><br><span class="line">&quot;\xac\xed...&quot;</span><br><span class="line">序列化对象的话必须实现 `Serializable` 接口，序列化结果可读性差，一般不用。</span><br><span class="line"></span><br><span class="line">// GenericJackson2JsonRedisSerializer</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;a.b.TestEO\&quot;,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;age\&quot;:22&#125;&quot;</span><br><span class="line"></span><br><span class="line">// Jackson2JsonRedisSerializer</span><br><span class="line">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;age\&quot;:22&#125;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Redis-Repositories"><a href="#Redis-Repositories" class="headerlink" title="Redis Repositories"></a>Redis Repositories</h3><p><code>EnableRedisRepositories</code> 开启和配置</p>
<p><code>RepositoryComponentProvider</code> 扫描 <code>Repository</code> 的继承或实现。</p>
<p>大致流程</p>
<ol>
<li><code>EnableRedisRepositories</code></li>
<li><code>RepositoryBeanDefinitionRegistrarSupport</code><ol>
<li>将 <code>EnableRedisRepositories</code> 里的配置信息包装进 <code>AnnotationRepositoryConfigurationSource</code>。</li>
<li>由子类负责创建 <code>RepositoryConfigurationExtension</code>，里面包含注册仓库过程中的所有自定义的步骤。</li>
<li>将上述两个对象交给 <code>RepositoryConfigurationDelegate</code>，其中是注册仓库的公共步骤。</li>
</ol>
</li>
<li>给每个 <code>Repository</code> 创建对应的 <code>RedisRepositoryFactoryBean</code>，负责创建和缓存 <code>Repository</code> 实例。</li>
<li><code>RedisRepositoryFactoryBean</code> 把具体的创建动作委托给 <code>RedisRepositoryFactory</code>。</li>
<li><code>RedisRepositoryFactory</code> 继承自 <code>RepositoryFactorySupport</code>。其中的 <code>getRepository</code> 方法负责创建实例和代理。</li>
<li><code>getRepository</code>：<ol>
<li>创建 <code>RepositoryInformation</code>。其中包含仓库的所有信息，包括用户继承的那个 <code>xxRepository</code> 接口、用户的实现类、最后创建 <code>Repository</code> 实例所基于的类（一般是 <code>SimpleKeyValueRepository</code>）。</li>
</ol>
</li>
<li>切面代理：<ol>
<li>Java8 以上会加入 <code>DefaultMethodInvokingMethodInterceptor</code> 负责调用接口中的默认方法。</li>
<li>加入 <code>QueryExecutorMethodInterceptor</code> 负责把方法调用转发给用户自定义的方法或者 spring 自动生成的方法。它的构造方法中使用 <code>QueryLookupStrategy</code> 来查找各方法对应的 <code>RepositoryQuery</code>。<ol>
<li><code>QueryLookupStrategy</code> 默认实现是 <code>KeyValueQueryLookupStrategy</code>，它返回的 <code>RepositoryQuery</code> 的实现是 <code>KeyValuePartTreeQuery</code>。</li>
<li><code>KeyValuePartTreeQuery</code></li>
<li>创建完 <code>PartTree</code> 后使用 <code>QueryCreator</code> 创建 <code>KeyValueQuery</code>。<code>KeyValueQuery</code> 中包含了查询条件、排序、偏移量等等稍后查询所需的信息。</li>
<li>将 <code>KeyValueQuery</code> 和查询方法的实参传给 <code>doExecute</code> 方法。该方法用 <code>keyValueOperations</code> 执行具体的查询，它又会把执行委托给 <code>KeyValueAdapter</code>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第-13-章-缓存数据"><a href="#第-13-章-缓存数据" class="headerlink" title="第 13 章 缓存数据"></a>第 13 章 缓存数据</h1><h1 id="第-14-章-保护方法应用"><a href="#第-14-章-保护方法应用" class="headerlink" title="第 14 章 保护方法应用"></a>第 14 章 保护方法应用</h1><h1 id="第-15-章-使用远程服务"><a href="#第-15-章-使用远程服务" class="headerlink" title="第 15 章 使用远程服务"></a>第 15 章 使用远程服务</h1><h1 id="第-16-章-使用-Spring-MVC-创建-REST-API"><a href="#第-16-章-使用-Spring-MVC-创建-REST-API" class="headerlink" title="第 16 章 使用 Spring MVC 创建 REST API"></a>第 16 章 使用 Spring MVC 创建 REST API</h1><h1 id="第-17-章-Spring-消息"><a href="#第-17-章-Spring-消息" class="headerlink" title="第 17 章 Spring 消息"></a>第 17 章 Spring 消息</h1><h2 id="使用-JMS-发送消息"><a href="#使用-JMS-发送消息" class="headerlink" title="使用 JMS 发送消息"></a>使用 JMS 发送消息</h2><h3 id="在-Spring-中搭建消息代理"><a href="#在-Spring-中搭建消息代理" class="headerlink" title="在 Spring 中搭建消息代理"></a>在 Spring 中搭建消息代理</h3><p><strong>创建连接工厂</strong></p>
<ol>
<li>创建连接工厂。`<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory"></bean></li>
<li>默认假设 ActiveMQ 代理监听 61616 端口。也可以指定代理的 URL。`<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory" p:brokerurl="tcp://localhost:61616"></bean></li>
</ol>
<p>也可以使用 ActiveMQ 的命名空间来配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:shemaLocation:</span>"<span class="attr">http:</span>//<span class="attr">activemq.apache.org</span>/<span class="attr">schema</span>/<span class="attr">core</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">http:</span>//<span class="attr">activemq.apache.org</span>/<span class="attr">schema</span>/<span class="attr">core</span>/<span class="attr">activemq-core.xsd</span>"&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>声明消息目的地</strong></p>
<p>使用特定消息代理实现类在 Spring 中声明一个 bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 队列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queue"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span> <span class="attr">c:_</span>=<span class="string">"&#123;queueName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 主题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topic"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span> <span class="attr">c:_</span>=<span class="string">"&#123;topicName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 ActiveMQ 的命名空间来配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">amq:queue</span> <span class="attr">id</span>=<span class="string">"queue"</span> <span class="attr">physicalName</span>=<span class="string">"&#123;queueName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">amq:topic</span> <span class="attr">id</span>=<span class="string">"topic"</span> <span class="attr">physicalName</span>=<span class="string">"&#123;topicNmae&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 JMS 模板</strong></p>
<p>将 JmsTemplate 声明为 bean。其中默认的目的地配置是可选的。也可以把目的地对象装配进来：<code>p:defaultDestination-ref=&quot;{destBean}&quot;</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:defaultDestinationName</span>=<span class="string">"&#123;destName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsOperations jmsOperations; <span class="comment">// JmsTemplate 实现了此接口</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送的时候定义消息的创建逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MyObj obj)</span> </span>&#123;</span><br><span class="line">        jmsOperations.send(<span class="string">"dest.name"</span>,</span><br><span class="line">            <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> session.createObjectMessage(obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送的时候使用转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageWithAutoConversion</span><span class="params">(MyObj obj)</span> </span>&#123;</span><br><span class="line">        jmsOperations.convertAndSend(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 Spring 预置的转换器，也可以实现 MessageConverter 接口自定义一个转换器。</p>
<ul>
<li>MappingJacksonMessageConverter：使用 Jackson JSON 库实现消息与 JSON 格式之间的相互转换。</li>
<li>MappingJackson2MessageConverter：使用 Jackson2 JSON 库实现消息与 JSON 格式之间的相互转换。</li>
<li>MarshallingMessageConverter：使用 JAXB 库实现消息与 XML 格式之间的转换。</li>
<li>SimpleMessageConverter：实现 String 与 TextMessage，字节数组与 ByteMessage，Map 与 MapMessage，Serializable 与 ObjectMessage 之间的转换。</li>
</ul>
<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MyObj <span class="title">receiveMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// receive() 会以阻塞的方式收取消息</span></span><br><span class="line">        ObjectMessage message = (ObjectMessage) jmsOperations.receive();</span><br><span class="line">        <span class="keyword">return</span> (MyObj) message.getObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyObj <span class="title">receiveMessageWithAutoConversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MyObj) jmsOperations.receiveAndConvert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建消息驱动的-POJO"><a href="#创建消息驱动的-POJO" class="headerlink" title="创建消息驱动的 POJO"></a>创建消息驱动的 POJO</h3><p><strong>配置消息监听器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 首先把 POJO 注册为 bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pojoHandler"</span> <span class="attr">class</span>=<span class="string">"me.example.PojoHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 把 POJO 声明为消息监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"&#123;destName&#125;"</span> <span class="attr">ref</span>=<span class="string">"pojoHandler"</span> <span class="attr">method</span>=<span class="string">"&#123;methodName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用基于消息的-RPC"><a href="#使用基于消息的-RPC" class="headerlink" title="使用基于消息的 RPC"></a>使用基于消息的 RPC</h3><p><strong>服务端</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"me.example.MyServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myServiceExporter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.remoting.JmsInvokerServiceExporter"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"myService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span> <span class="attr">value</span>=<span class="string">"me.example.MyService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"&#123;destName&#125;"</span> <span class="attr">ref</span>=<span class="string">"myServiceExporter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueName"</span> <span class="attr">value</span>=<span class="string">"&#123;destName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span> <span class="attr">value</span>=<span class="string">"me.example.MyService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-AMQP-实现消息功能"><a href="#使用-AMQP-实现消息功能" class="headerlink" title="使用 AMQP 实现消息功能"></a>使用 AMQP 实现消息功能</h2><h3 id="配置-Spring-支持-AMQP-消息"><a href="#配置-Spring-支持-AMQP-消息" class="headerlink" title="配置 Spring 支持 AMQP 消息"></a>配置 Spring 支持 AMQP 消息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:rabbit</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 默认 5672 端口，用户名密码均为 guest --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">host</span>=<span class="string">"&#123;host&#125;"</span> <span class="attr">port</span>=<span class="string">"&#123;port&#125;"</span> <span class="attr">username</span>=<span class="string">"&#123;user&#125;"</span> <span class="attr">password</span>=<span class="string">"&#123;pwd&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>rabbit 命名空间里用来声明队列、exchange 和 binding 的元素：</p>
<table>
<thead>
<tr>
<th style="text-align:left">元素</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;queue&gt;</code></td>
<td style="text-align:left">队列</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;fanout-exchange&gt;</code></td>
<td style="text-align:left">fanout 类型的 exchange</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;header-exchange&gt;</code></td>
<td style="text-align:left">header 类型的 exchange</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;topic-exchange&gt;</code></td>
<td style="text-align:left">topic 类型的 exchange</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;direct-exchange&gt;</code></td>
<td style="text-align:left">direct 类型的 exchange</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;bindings&gt;&lt;binding/&gt;&lt;/bindings&gt;</code></td>
<td style="text-align:left">exchange 和队列之间的 binding</td>
</tr>
</tbody>
</table>
<p>以上配置元素要与 <code>&lt;admin&gt;</code> 一起使用，它会创建一个 RabbitMQ 管理组件，用来自动创建上述元素声明的对象。</p>
<h3 id="使用-RabbitTemplate-发送消息"><a href="#使用-RabbitTemplate-发送消息" class="headerlink" title="使用 RabbitTemplate 发送消息"></a>使用 RabbitTemplate 发送消息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- exchange 和 routing-key 可为空 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">exchange</span>=<span class="string">"$&#123;exchangeName&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">routing-key</span>=<span class="string">"$&#123;routingKey&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitMQClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(MyObj obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//exchangeName 和 routingKey 缺省为上面配置的值</span></span><br><span class="line">        rabbit.convertAndSend(<span class="string">"&#123;exchangeName&#125;"</span>, <span class="string">"&#123;routingKey&#125;"</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接受-AMQP-消息"><a href="#接受-AMQP-消息" class="headerlink" title="接受 AMQP 消息"></a>接受 AMQP 消息</h3><h4 id="使用-RabbitTemplate-来接受消息"><a href="#使用-RabbitTemplate-来接受消息" class="headerlink" title="使用 RabbitTemplate 来接受消息"></a>使用 RabbitTemplate 来接受消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message msg = rabbit.receive(<span class="string">"&#123;queueName&#125;"</span>);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">MyObj obj = rabbit.receiveAndConvert(<span class="string">"&#123;queueName&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>其中 {queueName} 也可以在 rabbitTemplate 中注入默认值。</p>
<p>队列中无消息时会立即返回 null，所以要自行管理轮询的频率等细节。</p>
<h4 id="定义消息驱动的-AMQP-POJO"><a href="#定义消息驱动的-AMQP-POJO" class="headerlink" title="定义消息驱动的 AMQP POJO"></a>定义消息驱动的 AMQP POJO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMyObj</span><span class="params">(MyObj obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以下元素都来自 rabbit 命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多个 queueName 用逗号分隔 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span> <span class="attr">ref</span>=<span class="string">"myObjListener"</span> <span class="attr">method</span>=<span class="string">"handleMyObj"</span> <span class="attr">queueNames</span>=<span class="string">"$&#123;queueName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也可以用 queue 的 beanId 来引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span> <span class="attr">ref</span>=<span class="string">"myObjListener"</span> <span class="attr">method</span>=<span class="string">"handleMyObj"</span> <span class="attr">queues</span>=<span class="string">"$&#123;queueId&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="第-18-章-使用-WebSocket-和-STOMP-实现消息功能"><a href="#第-18-章-使用-WebSocket-和-STOMP-实现消息功能" class="headerlink" title="第 18 章 使用 WebSocket 和 STOMP 实现消息功能"></a>第 18 章 使用 WebSocket 和 STOMP 实现消息功能</h1><h2 id="使用-Spring-的低层级-WebSocket-API"><a href="#使用-Spring-的低层级-WebSocket-API" class="headerlink" title="使用 Spring 的低层级 WebSocket API"></a>使用 Spring 的低层级 WebSocket API</h2><p>需要引入 spring-websocket 模块。</p>
<p>需要继承 <code>WebSocketHandler</code> 接口，或继承 <code>AbstractWebSocketHandler</code> 类。</p>
<p>进行配置，让 Spring 把消息转发给处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(exampleHandler(), <span class="string">"/example"</span>)</span><br><span class="line">        <span class="comment">//.setHandshakeHandler(null); //可以自定义握手处理类</span></span><br><span class="line">        <span class="comment">//.addInterceptors(null);     //可以自定义拦截器</span></span><br><span class="line">          .setAllowedOrigins(<span class="string">"*"</span>);    <span class="comment">//若不配置来源白名单的话，默认只允许来自当前域的连接</span></span><br><span class="line">        <span class="comment">//.withSockJS();              //用 sockJS 在不支持 websocket 环境下的模拟 websocket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleHandler <span class="title">exampleHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">handler</span>=<span class="string">"macroHandler"</span> <span class="attr">path</span>=<span class="string">"/marco"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleHandler"</span> <span class="attr">class</span>=<span class="string">"me.example.ExampleHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="启用-STOMP-消息功能"><a href="#启用-STOMP-消息功能" class="headerlink" title="启用 STOMP 消息功能"></a>启用 STOMP 消息功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketStompConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端在发布或订阅消息前要连接到此端点</span></span><br><span class="line">    registry.addEndpoint(<span class="string">"/example"</span>).withSockJS();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以下前缀会路由到 &#123;@link SimpleBrokerMessageHandler&#125;，这是一个模拟了 STOMP 消息代理的、基于内存的消息代理</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">"/queue"</span>, <span class="string">"/topic"</span>);</span><br><span class="line">    <span class="comment">//以下前缀会路由到 &#123;@link @MessageMapping&#125; 注解的方法中</span></span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);</span><br><span class="line">    <span class="comment">//以下前缀会路由到 STOMP 代理中</span></span><br><span class="line">    <span class="comment">//STOMP 代理中继默认会假设代理监听的是 localhost:61613</span></span><br><span class="line">    registry.enableStompBrokerRelay(<span class="string">"/topic"</span>, <span class="string">"/queue"</span>);</span><br><span class="line">    <span class="comment">//.setRelayHost("");//也可以额外设置一些参数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理来自客户端的-STOMP-消息"><a href="#处理来自客户端的-STOMP-消息" class="headerlink" title="处理来自客户端的 STOMP 消息"></a>处理来自客户端的 STOMP 消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MessageMapping</span>(<span class="string">"/example"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExample</span><span class="params">(Example example)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 4.0 提供了几个消息转换器</p>
<ul>
<li><code>ByteArrayMessageConverter</code>：application/octet-stream &lt;-&gt; byte[]</li>
<li><code>MappingJackson2MessageConverter</code>：application/json &lt;-&gt; Java 对象</li>
<li><code>StringMessageConverter</code>：text/plain &lt;-&gt; String</li>
</ul>
<p><strong>处理订阅</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeMapping</span>(&#123;<span class="string">"/subs"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Example <span class="title">handleSubscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Example();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Javascript 客户端</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://host:port/contextpath/endpoint'</span>;</span><br><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(url);</span><br><span class="line"><span class="keyword">var</span> stomp = Stomp.over(sock);</span><br><span class="line"><span class="keyword">var</span> payload = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">'message'</span>:<span class="string">'Marco!'</span>&#125;);</span><br><span class="line">stomp.connect(<span class="string">'guest'</span>, <span class="string">'guest'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">  stomp.send(<span class="string">"/marco"</span>, &#123;&#125;, payload);<span class="comment">// 第二个参数是头信息的 map</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>@SubscribeMapping</code> 的主要应用场景是请求-回应模式。这种模式跟 HTTP GET 的请求-响应模式很像，不过是异步的。</p>
<h3 id="发送消息到客户端"><a href="#发送消息到客户端" class="headerlink" title="发送消息到客户端"></a>发送消息到客户端</h3><p><strong>在处理消息之后发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一条返回消息到指定目的地，所有订阅该目的地的客户端可以获取这条返回消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/example"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/custom/dest"</span>) <span class="comment">//不加这个注解的话默认会发到 /topic/example</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Example <span class="title">handleExample</span><span class="params">(Example incoming)</span> </span>&#123;</span><br><span class="line">    Example outgoing = <span class="keyword">new</span> Example();</span><br><span class="line">    outgoing.setMessage(<span class="string">"blahblah"</span>);</span><br><span class="line">    <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回消息会直接发给客户端，而不会经过消息代理。</span></span><br><span class="line"><span class="comment"> * 也可以添加 &#123;<span class="doctag">@code</span> SendTo&#125; 注解，这样就会经过消息代理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SubscribeMapping</span>(<span class="string">"/subs"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Example <span class="title">handleSubscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Example outgoing = <span class="keyword">new</span> Example();</span><br><span class="line">    outgoing.setMessage(<span class="string">"blahblah"</span>);</span><br><span class="line">    <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在应用的任意地方发送消息</strong></p>
<p>服务端把消息发布到一个主题上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleFeedServiceImpl</span> <span class="keyword">implements</span> <span class="title">SpittleFeedService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 配置 Spring 开启 STOMP 时就已经在上下文里创建了这个 bean</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SimpMessageSendingOperations messaging;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastSpittle</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    messaging.convertAndSend(<span class="string">"/topic/spittlefeed"</span>, spittle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端订阅一个 STOMP 主题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(<span class="string">'spittr'</span>);</span><br><span class="line"><span class="keyword">var</span> stomp = Stomp.over(sock);</span><br><span class="line"></span><br><span class="line">stomp.connect(<span class="string">'guest'</span>, <span class="string">'guest'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">  stomp.subscribe(<span class="string">"/topic/spittlefeed"</span>, handleSpittle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSpittle</span>(<span class="params">incoming</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> spittle = <span class="built_in">JSON</span>.parse(incoming.body);</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为目标用户发送消息"><a href="#为目标用户发送消息" class="headerlink" title="为目标用户发送消息"></a>为目标用户发送消息</h2><p>在使用 Spring 和 STOMP 消息功能时，有三种方式利用认证用户：</p>
<ul>
<li><code>@MessageMapping</code> 和 <code>@SubscribeMapping</code> 标注的方法能使用 <code>Principal</code> 来获取认证用户。</li>
<li><code>@MessageMapping</code>、<code>@SubscribeMapping</code> 和 <code>@MessageException</code> 方法返回的值能以消息的形式发送给认证用户。</li>
<li><code>SimpMessagingTemplate</code> 能发送消息给特定用户。</li>
</ul>
<h3 id="在控制器中处理用户的消息"><a href="#在控制器中处理用户的消息" class="headerlink" title="在控制器中处理用户的消息"></a>在控制器中处理用户的消息</h3><p>客户端订阅一个用户特定的目的地：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stomp.subscribe(<span class="string">"/user/queue/notifications"</span>, handleNotifications);</span><br></pre></td></tr></table></figure>
<p>在内部，以“/user”作为前缀的目的地会通过 <code>UserDestinationMessageHandler</code> 进行处理。它会去掉“/user”前缀，并基于用户会话添加一个后缀，例如把“/user/queue/notifications”的订阅路由到“/queue/notifications-user1234abcd”上。</p>
<p>在服务端把返回消息发布到用户特定的目的地：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/spittle"</span>)</span><br><span class="line"><span class="meta">@SendToUser</span>(<span class="string">"/queue/notifications"</span>) <span class="comment">// 会发布到 /queue/notifications-user1234abcd</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Notification <span class="title">handleSpittle</span><span class="params">(Principal principal, SpittleForm form)</span> </span>&#123;</span><br><span class="line">  Spittle spittle = <span class="keyword">new</span> Spittle(principal.getName(), form.getText(), <span class="keyword">new</span> Date());</span><br><span class="line">  spittleRepo.save(spittle);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">"Saved spittle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户已经认证过的话，会根据 STOMP 帧上的头信息得到 <code>Principal</code> 对象。</p>
<h3 id="为指定用户发送消息"><a href="#为指定用户发送消息" class="headerlink" title="为指定用户发送消息"></a>为指定用户发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleFeedServiceImpl</span> <span class="keyword">implements</span> <span class="title">SpittleFeedService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SimpMessagingTemplate messaging;</span><br><span class="line">  <span class="keyword">private</span> Pattern pattern = Pattern.compile(<span class="string">"\\@(\\S+)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastSpittle</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    messaging.convertAndSend(<span class="string">"/topic/spittlefeed"</span>, spittle);</span><br><span class="line">    <span class="comment">// 发送给指定用户</span></span><br><span class="line">    Matcher matcher = pattern.matcher(spittle.getMessage());</span><br><span class="line">    <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">      String username = matcher.group(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 会发到 /user/tom/queue/notifications 上</span></span><br><span class="line">      messaging.convertAndSendToUser(username, <span class="string">"/queue/notifications"</span>, <span class="keyword">new</span> Notification(<span class="string">"blabla"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理异常信息"><a href="#处理异常信息" class="headerlink" title="处理异常信息"></a>处理异常信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageExceptionHandler</span>(&#123;ExceptionA.class, ExceptionB.class&#125;) <span class="comment">// 标注处理异常的方法，可指定若干种异常</span></span><br><span class="line"><span class="meta">@SendToUser</span>(<span class="string">"/queue/errors"</span>) <span class="comment">// 可以将异常信息发送给指定用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpittleException <span class="title">handleException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">  logger.error(<span class="string">"blabla"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SpittleException(<span class="string">"blabla"</span>, throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第-19-章-使用-Spring-发送-Email"><a href="#第-19-章-使用-Spring-发送-Email" class="headerlink" title="第 19 章 使用 Spring 发送 Email"></a>第 19 章 使用 Spring 发送 Email</h1><h1 id="第-20-章-使用-JMX-管理-Spring-Bean"><a href="#第-20-章-使用-JMX-管理-Spring-Bean" class="headerlink" title="第 20 章 使用 JMX 管理 Spring Bean"></a>第 20 章 使用 JMX 管理 Spring Bean</h1><p>JMX</p>
<blockquote>
<p>Java Management Extensions</p>
</blockquote>
<p>使用 JMX 管理应用的核心组件是托管 bean （managed bean，MBean），即暴露特定方法的 JavaBean，这些方法定义了管理接口。</p>
<p>JMX 规范定义了 4 种类型的 MBean：</p>
<ul>
<li>标准 MBean：标准 MBean 的管理接口是通过在固定的接口上执行反射确定的，bean 类会实现这个接口；</li>
<li>动态 MBean：动态 MBean 的管理接口是在运行时通过调用 <code>DynamicMBean</code> 接口的方法来确定的。因为管理接口不是通过静态接口定义的，因此可以在运行时改变；</li>
<li>开放 MBean：开放 MBean 是一种特殊的动态 MBean，其属性和方法只限定于原始类型、原始类型的包装类以及可以分解为原始类型或原始类型包装类的任意类型；</li>
<li>模型 MBean：模型 MBean 也是一种特殊的动态 MBean，用于充当管理接口与受管资源的中介。模型 Bean 并不像它们所声明的那样来编写。它们通常通过工厂生成，工厂会使用元信息来组装管理接口。</li>
</ul>
<h2 id="将-Spring-bean-导出为-MBean"><a href="#将-Spring-bean-导出为-MBean" class="headerlink" title="将 Spring bean 导出为 MBean"></a>将 Spring bean 导出为 MBean</h2><p>Spring 的 <code>MBeanExporter</code> 可以把 Spring bean 导出为 MBean 服务器内的模型 MBean。MBean 服务器（也称为 MBean 代理）是 MBean 生存的容器。对 MBean 的访问也是通过 MBean 服务器来实现的。</p>
<p>声明一个 <code>MBeanExporter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MBeanExporter <span class="title">mbeanExporter</span><span class="params">(SpittleController spittleController)</span> </span>&#123;</span><br><span class="line">  MBeanExporter exporter = <span class="keyword">new</span> MBeanExporter();</span><br><span class="line">  Map&lt;String, Object&gt; beans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  beans.put(<span class="string">"spitter:name=SpittleController"</span>, spittleController);</span><br><span class="line">  exporter.setBeans(beans);</span><br><span class="line">  <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MBeanExporter</code> 会假设它正在一个应用服务器中或提供 MBean 服务器的其他上下文中运行。若运行的是独立的应用或运行的容器没有提供 MBean 服务器，就需要在 Spring 上下文中配置一个 MBean 服务器。</p>
<p>在 XML 中使用 <code>&lt;context:mbean-server&gt;</code> 元素。或者声明一个 <code>MBeanServerFactoryBean</code> bean。可以将该 bean 装配到 <code>MBeanExporter</code> 的 <code>server</code> 属性中来指定 MBean 暴露到哪个 MBean 服务器中。</p>
<p>将 Spring bean 导出为 JMX MBean 之后，可以使用基于 JMX 的管理工具（如 JConsole 或 VisualVM）查看正在运行的应用，显示 bean 的属性并调用 bean 的方法。</p>
<p>为了对 MBean 的属性和操作获得更细粒度的控制，Spring 提供了几种选择：</p>
<ul>
<li>通过名称来声明需要暴露或忽略的 bean 方法；</li>
<li>通过为 bean 增加接口来选择要暴露的方法；</li>
<li>通过注解标注 bean 来标识托管的属性和操作。</li>
</ul>
<h3 id="通过名称暴露方法"><a href="#通过名称暴露方法" class="headerlink" title="通过名称暴露方法"></a>通过名称暴露方法</h3><p>MBean 信息装配器（MBean info assembler）是限制哪些方法和属性将在 MBean 上暴露的关键。</p>
<p>其中一个 MBean 信息装配器是 <code>MethodNameBasedMBeanInfoAssembler</code>。另一个基于方法名称的装配器是 <code>MethodExclusionMBeanInfoAssembler</code>。它是前者的反操作，指定了不需要暴露为 MBean 托管操作的方法名称列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodNameBasedMBeanInfoAssembler <span class="title">assembler1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MethodNameBasedInfoAssembler assembler = <span class="keyword">new</span> MethodNameBasedMBeanInfoAssembler();</span><br><span class="line">  assembler.setManagedMethods(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">    <span class="string">"getSpittlesPerPage"</span>, <span class="string">"setSpittlesPerPage"</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> assembler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodExclusionMBeanInfoAssembler <span class="title">assembler2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MethodExclusionMBeanInfoAssembler assembler = <span class="keyword">new</span> MethodExclusionMBeanInfoAssembler();</span><br><span class="line">  assembler.setIgnoreMethods(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">    <span class="string">"spittles"</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> assembler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将装配器装配进 MBeanExporter 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MBeanExporter <span class="title">mbeanExporter</span><span class="params">(SpittleController spittleController, MBeanInfoAssembler assembler)</span> </span>&#123;</span><br><span class="line">  MBeanExporter exporter = <span class="keyword">new</span> MBeanExporter();</span><br><span class="line">  Map&lt;String, Object&gt; beans = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">  beans.put(<span class="string">"spitter:name=SpittleController"</span>, spittleController);</span><br><span class="line">  exporter.setBeans(beans);</span><br><span class="line">  exporter.setAssembler(assembler);</span><br><span class="line">  <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用接口定义-MBean-的操作和属性"><a href="#使用接口定义-MBean-的操作和属性" class="headerlink" title="使用接口定义 MBean 的操作和属性"></a>使用接口定义 MBean 的操作和属性</h3><p>Spring 的 <code>InterfaceBasedMBeanInfoAssembler</code> 是另一种 MBean 信息装配器。通过使用接口选择 bean 的哪些方法需要暴露为 MBean 的托管操作。</p>
<p>假设有如下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleControllerManagedOperations</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSpittlesPerPage</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSpittlesPerPage</span><span class="params">(<span class="keyword">int</span> spittlesPerPage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需用如下的 bean 替换掉之前基于方法名的装配器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterfaceBasedMBeanInfoAssembler <span class="title">assembler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InterfaceBasedMBeanInfoAssembler assembler =</span><br><span class="line">    <span class="keyword">new</span> InterfaceBasedMBeanInfoAssembler();</span><br><span class="line">  assembler.setManagedInterfaces(</span><br><span class="line">    <span class="keyword">new</span> Class&lt;?&gt;[] &#123;SpittleControllerManagedOperations.class&#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> assembler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被托管的实现类不是必须实现 <code>SpittleControllerManagedOperation</code> 接口的。这个接口只是为了标识导出的内容。不过为了保证 MBean 和实现类之间保持一致，最好还是让实现类实现该接口。</p>
<h3 id="使用注解驱动的-MBean"><a href="#使用注解驱动的-MBean" class="headerlink" title="使用注解驱动的 MBean"></a>使用注解驱动的 MBean</h3><p>Spring 还提供另一种装配器 <code>MetadataMBeanInfoAssembler</code>，它可以使用注解标识哪些 bean 的方法需要暴露为 MBean 的托管操作和属性。</p>
<p>手动装配这种装配器很繁杂，简单的做法是使用 <code>&lt;context:mbean-exporter&gt;</code> 元素，用这种装配器代替之前的 <code>MBeanExporter</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:mbean-exporter</span> <span class="attr">server</span>=<span class="string">"mbeanServer"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//将 SpitteController 导出为 MBean</span></span><br><span class="line"><span class="comment">//objectName 标识了域（Spitter）和 MBean 的名称</span></span><br><span class="line"><span class="meta">@ManagedResource</span>(objectName=<span class="string">"spitter:name=SpittleController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleController</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//将 spittlesPerPage 暴露为托管属性</span></span><br><span class="line">  <span class="meta">@ManagedAttribute</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpittlesPerPage</span><span class="params">(<span class="keyword">int</span> spittlesPerPage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.spittlesPerPage = spittlesPerPage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ManagedAttribute</span></span><br><span class="line">  <span class="comment">//不会把属性暴露为 MBean 的托管属性，因为此注解是严格限制方法的。</span></span><br><span class="line">  <span class="comment">//@ManagedOperation</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpittlePerPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spittlePerPage;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理-MBean-冲突"><a href="#处理-MBean-冲突" class="headerlink" title="处理 MBean 冲突"></a>处理 MBean 冲突</h3><p>Spring 提供了 3 种借助 <code>registrationBehaviorName</code> 属性来处理 MBean 名字冲突的机制：</p>
<ul>
<li><code>FAIL_ON_EXISTING</code>：如果已存在相同名字的 MBean，则失败（默认）</li>
<li><code>IGNORE_EXISTING</code>：忽略冲突，不注册新的 MBean</li>
<li><code>REPLACING_EXISTING</code>：用新的覆盖旧的 MBean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">pubilc MBeanExporter <span class="title">mbeanExporter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SpittleController spittleController,</span></span></span><br><span class="line"><span class="function"><span class="params">  MBeanInfoAssembler assembler)</span> </span>&#123;</span><br><span class="line">  MBeanExporter exporter = <span class="keyword">new</span> MBeanExporter();</span><br><span class="line">  Map&lt;String, Object&gt; beans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  beans.put(<span class="string">"spitter:name=SpittleController"</span>, spittleController);</span><br><span class="line">  exporter.setBeans(beans);</span><br><span class="line">  exporter.setAssembler(assembler);</span><br><span class="line">  exporter.setRegistrationPolicy(RegistrationPolicy.IGNORE_EXISTING);</span><br><span class="line">  <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="远程-MBean"><a href="#远程-MBean" class="headerlink" title="远程 MBean"></a>远程 MBean</h2><p>为了满足以标准方式进行远程访问 JMX 的需求，JCP（Java Community Process）制订了 JSR-160:Java 管理扩展远程访问 API 规范（Java Management Extensions Remote API Specification）。该规范定义了 JMX 远程访问的标准，该标准至少需要绑定 RMI 和可选的 JMX 消息协议（JMX Messaging Protocol, JMXMP）。</p>
<h3 id="暴露远程-MBean"><a href="#暴露远程-MBean" class="headerlink" title="暴露远程 MBean"></a>暴露远程 MBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectorServerFactoryBean <span class="title">connectorServerFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConnectorServerFactoryBean csfb =</span><br><span class="line">    <span class="keyword">new</span> ConnectorServerFactoryBean();</span><br><span class="line">  <span class="comment">//（可选）绑定到一个 RMI 注册表</span></span><br><span class="line">  csfb.setServiceUrl(</span><br><span class="line">    <span class="string">"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/spitter"</span>);</span><br><span class="line">  <span class="keyword">return</span> csfb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConnectorServerFactoryBean</code> 会创建和启动 <code>JSR-160 JMXConnectorServer</code>。服务器默认使用 JMXMP 协议并监听 9875 端口，即绑定 <code>service:jmx:jmxmp://localhost:9875</code>。</p>
<h3 id="访问远程-MBean"><a href="#访问远程-MBean" class="headerlink" title="访问远程 MBean"></a>访问远程 MBean</h3><p>//TODO</p>
<h3 id="代理-MBean"><a href="#代理-MBean" class="headerlink" title="代理 MBean"></a>代理 MBean</h3><p>//TODO</p>
<h3 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h3><p>//TODO</p>
<h3 id="监听通知"><a href="#监听通知" class="headerlink" title="监听通知"></a>监听通知</h3><p>//TODO</p>
<h1 id="第-21-章-借助-Spring-Boot-简化-Spring-开发"><a href="#第-21-章-借助-Spring-Boot-简化-Spring-开发" class="headerlink" title="第 21 章 借助 Spring Boot 简化 Spring 开发"></a>第 21 章 借助 Spring Boot 简化 Spring 开发</h1><h2 id="Spring-Boot-简介"><a href="#Spring-Boot-简介" class="headerlink" title="Spring Boot 简介"></a>Spring Boot 简介</h2><h3 id="添加-Starter-依赖"><a href="#添加-Starter-依赖" class="headerlink" title="添加 Starter 依赖"></a>添加 Starter 依赖</h3><table>
<thead>
<tr>
<th style="text-align:left">Starter</th>
<th style="text-align:left">所提供的依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">spring-boot-starter-actuator</td>
<td style="text-align:left">spring-boot-starter、spring-boot-actuator、spring-core</td>
</tr>
<tr>
<td style="text-align:left">spring-boot-starter-amqp</td>
<td style="text-align:left">spring-boot-starter、spring-boot-rabbit、spring-core、spring-tx</td>
</tr>
<tr>
<td style="text-align:left">spring-boot-starter-aop</td>
<td style="text-align:left">spring-boot-starter、spring-aop、AspectJ Runtime、AspectJ Weaver、spring-core</td>
</tr>
<tr>
<td style="text-align:left">spring-boot-starter-batch</td>
<td style="text-align:left">spring-boot-starter、HSQLDB、spring-jdbc、spring-batch-core、spring-core</td>
</tr>
</tbody>
</table>
<p>//TODO</p>
<h2 id="通过-Acutator-获取了解应用内部状况"><a href="#通过-Acutator-获取了解应用内部状况" class="headerlink" title="通过 Acutator 获取了解应用内部状况"></a>通过 Acutator 获取了解应用内部状况</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>GET /autoconfig</code> 描述了 Spring Boot 在使用自动配置的时候所做出的决策；</li>
<li><code>GET /beans</code> 列出运行应用所配置的 bean；</li>
<li><code>GET /configprops</code> 列出应用中能够用来配置 bean 的所有属性及其当前的值；</li>
<li><code>GET /dump</code> 列出应用的线程，包括每个线程的栈跟踪信息；</li>
<li><code>GET /env</code> 列出应用上下文中所有可用的环境和系统属性变量；</li>
<li><code>GET /env/{name}</code> 展现某个特定环境变量和属性变量的值；</li>
<li><code>GET /health</code> 展现当前应用的健康状况；</li>
<li><code>GET /info</code> 展现应用特定的信息；</li>
<li><code>GET /metrics</code> 列出应用相关的指标，包括请求特定端点的运行次数；</li>
<li><code>GET /metrics/{name}</code> 展现应用特定指标项的指标状况；</li>
<li><code>POST /shutdown</code> 强制关闭应用；</li>
<li><code>GET /trace</code> 列出应用最近请求相关的元数据，包括请求和相应头。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/01/XML/SAX/" rel="next" title="SAX">
                <i class="fa fa-chevron-left"></i> SAX
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/13/Java/Apache Commons/" rel="prev" title="Apache Commons">
                Apache Commons <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zeerho</p>
              <p class="site-description motion-element" itemprop="description">Just a repo for documents</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZephyrHuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zephyrhuang21@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-Spring-之旅"><span class="nav-number">1.</span> <span class="nav-text">第 1 章 Spring 之旅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#xml-扫描的大致流程"><span class="nav-number">1.1.</span> <span class="nav-text">xml 扫描的大致流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">1.2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概览"><span class="nav-number">1.2.1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext-主要继承结构及重要方法"><span class="nav-number">1.2.2.</span> <span class="nav-text">ApplicationContext 主要继承结构及重要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器初始化"><span class="nav-number">1.2.3.</span> <span class="nav-text">容器初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean-的生命周期"><span class="nav-number">1.3.</span> <span class="nav-text">bean 的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-模块"><span class="nav-number">1.4.</span> <span class="nav-text">Spring 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-的新功能"><span class="nav-number">1.5.</span> <span class="nav-text">Spring 的新功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-装配-bean"><span class="nav-number">2.</span> <span class="nav-text">第 2 章 装配 bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置的可选方案"><span class="nav-number">2.1.</span> <span class="nav-text">配置的可选方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-XML-装配-bean"><span class="nav-number">2.2.</span> <span class="nav-text">通过 XML 装配 bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-Java-代码装配-bean"><span class="nav-number">2.3.</span> <span class="nav-text">通过 Java 代码装配 bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式的-bean-发现机制和自动装配"><span class="nav-number">2.4.</span> <span class="nav-text">隐式的 bean 发现机制和自动装配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入和混合配置"><span class="nav-number">2.5.</span> <span class="nav-text">导入和混合配置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-高级装配"><span class="nav-number">3.</span> <span class="nav-text">第 3 章 高级装配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#环境与-profile"><span class="nav-number">3.1.</span> <span class="nav-text">环境与 profile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件化的-bean"><span class="nav-number">3.2.</span> <span class="nav-text">条件化的 bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理自动装配的歧义性"><span class="nav-number">3.3.</span> <span class="nav-text">处理自动装配的歧义性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标示首选的-bean"><span class="nav-number">3.3.1.</span> <span class="nav-text">标示首选的 bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限定自动装配的-bean"><span class="nav-number">3.3.2.</span> <span class="nav-text">限定自动装配的 bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean-的作用域"><span class="nav-number">3.4.</span> <span class="nav-text">bean 的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用会话和请求作用域"><span class="nav-number">3.4.1.</span> <span class="nav-text">使用会话和请求作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时值注入"><span class="nav-number">3.5.</span> <span class="nav-text">运行时值注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注入外部的值"><span class="nav-number">3.5.1.</span> <span class="nav-text">注入外部的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Spring-表达式进行装配"><span class="nav-number">3.5.2.</span> <span class="nav-text">使用 Spring 表达式进行装配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-4-章-面向切面的-Spring"><span class="nav-number">4.</span> <span class="nav-text">第 4 章 面向切面的 Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-AOP-术语"><span class="nav-number">4.0.1.</span> <span class="nav-text">定义 AOP 术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-对-AOP-的支持"><span class="nav-number">4.0.2.</span> <span class="nav-text">Spring 对 AOP 的支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过切点来选择连接点"><span class="nav-number">4.1.</span> <span class="nav-text">通过切点来选择连接点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写切点"><span class="nav-number">4.1.1.</span> <span class="nav-text">编写切点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在切点中选择-bean"><span class="nav-number">4.1.2.</span> <span class="nav-text">在切点中选择 bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注解创建切面"><span class="nav-number">4.2.</span> <span class="nav-text">使用注解创建切面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义切面"><span class="nav-number">4.2.1.</span> <span class="nav-text">定义切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过注解引入新功能"><span class="nav-number">4.2.2.</span> <span class="nav-text">通过注解引入新功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-XML-中声明切面"><span class="nav-number">4.3.</span> <span class="nav-text">在 XML 中声明切面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切面的一些实践细节"><span class="nav-number">4.4.</span> <span class="nav-text">切面的一些实践细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连接点对象-ProceedingJoinPoint"><span class="nav-number">4.4.1.</span> <span class="nav-text">连接点对象 ProceedingJoinPoint</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务管理"><span class="nav-number">5.</span> <span class="nav-text">事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务管理器"><span class="nav-number">5.1.</span> <span class="nav-text">事务管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC-事务"><span class="nav-number">5.1.1.</span> <span class="nav-text">JDBC 事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hibernate-事务"><span class="nav-number">5.1.2.</span> <span class="nav-text">Hibernate 事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA-事务"><span class="nav-number">5.1.3.</span> <span class="nav-text">JPA 事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JTA-事务"><span class="nav-number">5.1.4.</span> <span class="nav-text">JTA 事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-Spring-中的编码事务"><span class="nav-number">5.2.</span> <span class="nav-text">在 Spring 中的编码事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明式事务"><span class="nav-number">5.3.</span> <span class="nav-text">声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义事务属性"><span class="nav-number">5.3.1.</span> <span class="nav-text">定义事务属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-XML-中声明事务"><span class="nav-number">5.3.2.</span> <span class="nav-text">在 XML 中声明事务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-构建-Spring-Web-应用程序"><span class="nav-number">6.</span> <span class="nav-text">第 5 章 构建 Spring Web 应用程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-渲染-Web-视图"><span class="nav-number">7.</span> <span class="nav-text">第 6 章 渲染 Web 视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-Spring-MVC-的高级技术"><span class="nav-number">8.</span> <span class="nav-text">第 7 章 Spring MVC 的高级技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC"><span class="nav-number">8.2.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#资源访问"><span class="nav-number">8.2.1.</span> <span class="nav-text">资源访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet"><span class="nav-number">8.3.</span> <span class="nav-text">DispatcherServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">8.3.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部逻辑"><span class="nav-number">8.3.2.</span> <span class="nav-text">内部逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息转换器-HttpMessageConverter"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">消息转换器 HttpMessageConverter</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-8-章-使用-Spring-Web-Flow"><span class="nav-number">9.</span> <span class="nav-text">第 8 章 使用 Spring Web Flow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-9-章-保护-Web-应用"><span class="nav-number">10.</span> <span class="nav-text">第 9 章 保护 Web 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Security-的模块"><span class="nav-number">10.1.</span> <span class="nav-text">Spring Security 的模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-10-章-通过-Spring-和-JDBC-征服数据库"><span class="nav-number">11.</span> <span class="nav-text">第 10 章 通过 Spring 和 JDBC 征服数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-11-章-使用对象-关系映射持久化数据"><span class="nav-number">12.</span> <span class="nav-text">第 11 章 使用对象-关系映射持久化数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JPA"><span class="nav-number">12.1.</span> <span class="nav-text">JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置应用程序管理类型的-JPA"><span class="nav-number">12.1.1.</span> <span class="nav-text">配置应用程序管理类型的 JPA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置容器管理类型的-JPA"><span class="nav-number">12.1.2.</span> <span class="nav-text">配置容器管理类型的 JPA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-data-JPA"><span class="nav-number">12.1.3.</span> <span class="nav-text">Spring-data JPA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-12-章-使用-NoSQL-数据库"><span class="nav-number">13.</span> <span class="nav-text">第 12 章 使用 NoSQL 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Redis-操作-key-value-数据"><span class="nav-number">13.1.</span> <span class="nav-text">使用 Redis 操作 key-value 数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连接到-Redis"><span class="nav-number">13.1.1.</span> <span class="nav-text">连接到 Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-RedisTemplate"><span class="nav-number">13.1.2.</span> <span class="nav-text">使用 RedisTemplate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-key-和-value-的序列化器"><span class="nav-number">13.1.3.</span> <span class="nav-text">使用 key 和 value 的序列化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Repositories"><span class="nav-number">13.1.4.</span> <span class="nav-text">Redis Repositories</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-13-章-缓存数据"><span class="nav-number">14.</span> <span class="nav-text">第 13 章 缓存数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-14-章-保护方法应用"><span class="nav-number">15.</span> <span class="nav-text">第 14 章 保护方法应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-15-章-使用远程服务"><span class="nav-number">16.</span> <span class="nav-text">第 15 章 使用远程服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-16-章-使用-Spring-MVC-创建-REST-API"><span class="nav-number">17.</span> <span class="nav-text">第 16 章 使用 Spring MVC 创建 REST API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-17-章-Spring-消息"><span class="nav-number">18.</span> <span class="nav-text">第 17 章 Spring 消息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-JMS-发送消息"><span class="nav-number">18.1.</span> <span class="nav-text">使用 JMS 发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Spring-中搭建消息代理"><span class="nav-number">18.1.1.</span> <span class="nav-text">在 Spring 中搭建消息代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建消息驱动的-POJO"><span class="nav-number">18.1.2.</span> <span class="nav-text">创建消息驱动的 POJO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用基于消息的-RPC"><span class="nav-number">18.1.3.</span> <span class="nav-text">使用基于消息的 RPC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-AMQP-实现消息功能"><span class="nav-number">18.2.</span> <span class="nav-text">使用 AMQP 实现消息功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-Spring-支持-AMQP-消息"><span class="nav-number">18.2.1.</span> <span class="nav-text">配置 Spring 支持 AMQP 消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-RabbitTemplate-发送消息"><span class="nav-number">18.2.2.</span> <span class="nav-text">使用 RabbitTemplate 发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接受-AMQP-消息"><span class="nav-number">18.2.3.</span> <span class="nav-text">接受 AMQP 消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-RabbitTemplate-来接受消息"><span class="nav-number">18.2.3.1.</span> <span class="nav-text">使用 RabbitTemplate 来接受消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义消息驱动的-AMQP-POJO"><span class="nav-number">18.2.3.2.</span> <span class="nav-text">定义消息驱动的 AMQP POJO</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-18-章-使用-WebSocket-和-STOMP-实现消息功能"><span class="nav-number">19.</span> <span class="nav-text">第 18 章 使用 WebSocket 和 STOMP 实现消息功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Spring-的低层级-WebSocket-API"><span class="nav-number">19.1.</span> <span class="nav-text">使用 Spring 的低层级 WebSocket API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用-STOMP-消息功能"><span class="nav-number">19.2.</span> <span class="nav-text">启用 STOMP 消息功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理来自客户端的-STOMP-消息"><span class="nav-number">19.2.1.</span> <span class="nav-text">处理来自客户端的 STOMP 消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送消息到客户端"><span class="nav-number">19.2.2.</span> <span class="nav-text">发送消息到客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为目标用户发送消息"><span class="nav-number">19.3.</span> <span class="nav-text">为目标用户发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在控制器中处理用户的消息"><span class="nav-number">19.3.1.</span> <span class="nav-text">在控制器中处理用户的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为指定用户发送消息"><span class="nav-number">19.3.2.</span> <span class="nav-text">为指定用户发送消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理异常信息"><span class="nav-number">19.4.</span> <span class="nav-text">处理异常信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-19-章-使用-Spring-发送-Email"><span class="nav-number">20.</span> <span class="nav-text">第 19 章 使用 Spring 发送 Email</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-20-章-使用-JMX-管理-Spring-Bean"><span class="nav-number">21.</span> <span class="nav-text">第 20 章 使用 JMX 管理 Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#将-Spring-bean-导出为-MBean"><span class="nav-number">21.1.</span> <span class="nav-text">将 Spring bean 导出为 MBean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过名称暴露方法"><span class="nav-number">21.1.1.</span> <span class="nav-text">通过名称暴露方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用接口定义-MBean-的操作和属性"><span class="nav-number">21.1.2.</span> <span class="nav-text">使用接口定义 MBean 的操作和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用注解驱动的-MBean"><span class="nav-number">21.1.3.</span> <span class="nav-text">使用注解驱动的 MBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-MBean-冲突"><span class="nav-number">21.1.4.</span> <span class="nav-text">处理 MBean 冲突</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程-MBean"><span class="nav-number">21.2.</span> <span class="nav-text">远程 MBean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴露远程-MBean"><span class="nav-number">21.2.1.</span> <span class="nav-text">暴露远程 MBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问远程-MBean"><span class="nav-number">21.2.2.</span> <span class="nav-text">访问远程 MBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理-MBean"><span class="nav-number">21.2.3.</span> <span class="nav-text">代理 MBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理通知"><span class="nav-number">21.2.4.</span> <span class="nav-text">处理通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听通知"><span class="nav-number">21.2.5.</span> <span class="nav-text">监听通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-21-章-借助-Spring-Boot-简化-Spring-开发"><span class="nav-number">22.</span> <span class="nav-text">第 21 章 借助 Spring Boot 简化 Spring 开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-简介"><span class="nav-number">22.1.</span> <span class="nav-text">Spring Boot 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加-Starter-依赖"><span class="nav-number">22.1.1.</span> <span class="nav-text">添加 Starter 依赖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-Acutator-获取了解应用内部状况"><span class="nav-number">22.2.</span> <span class="nav-text">通过 Acutator 获取了解应用内部状况</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeerho</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
